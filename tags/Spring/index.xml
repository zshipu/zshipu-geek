<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 知识铺的博客</title>
    <link>https://geek.zshipu.com/tags/Spring/</link>
    <description>Recent content in Spring on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 06 Mar 2024 13:28:00 +0000</lastBuildDate>
    <atom:link href="https://geek.zshipu.com/tags/Spring/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring-mvc-MappingRegistry</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/mvc/Spring-mvc-MappingRegistry/</link>
      <pubDate>Wed, 06 Mar 2024 13:28:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/mvc/Spring-mvc-MappingRegistry/</guid>
      <description>MappingRegistry Author: HuiFer 源码阅读仓库: SourceHot-spring 源码路径: org.springframework.jms.annotation.EnableJms 类全路径 org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry 基本属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MappingRegistry { /** * key:mapping * value: mapping registration */ private final Map&amp;lt;T, MappingRegistration&amp;lt;T&amp;gt;&amp;gt; registry = new HashMap&amp;lt;&amp;gt;(); /** * key: mapping * value: handlerMethod */ private final Map&amp;lt;T, HandlerMethod&amp;gt; mappingLookup = new LinkedHashMap&amp;lt;&amp;gt;(); /** * key: url * value: list mapping */ private final MultiValueMap&amp;lt;String, T&amp;gt; urlLookup = new LinkedMultiValueMap&amp;lt;&amp;gt;(); /** * key: name * value: handler method */ private final Map&amp;lt;String, List&amp;lt;HandlerMethod&amp;gt;&amp;gt; nameLookup = new ConcurrentHashMap&amp;lt;&amp;gt;(); /** * key:handler method * value: 跨域</description>
    </item>
    <item>
      <title>Spring-MVC-HandlerMapping</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/mvc/Spring-MVC-HandlerMapping/</link>
      <pubDate>Wed, 06 Mar 2024 13:27:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/mvc/Spring-MVC-HandlerMapping/</guid>
      <description>Spring HandlerMapping Author: HuiFer 源码阅读仓库: SourceHot-spring 源码路径: org.springframework.jms.annotation.EnableJms org.springframework.web.servlet.HandlerMapping HandlerMapping 处理映射关系, 通过请求转换成对象HandlerExecutionChain 1 2 3 4 public interface HandlerMapping { HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; // 其他静态变量省略 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Override @Nullable public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception { // 转换成handler Object handler</description>
    </item>
    <item>
      <title>Spring-MessageConverter</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-MessageConverter/</link>
      <pubDate>Wed, 06 Mar 2024 13:26:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-MessageConverter/</guid>
      <description>Spring MessageConverter Author: HuiFer 源码阅读仓库: SourceHot-spring 源码路径: org.springframework.messaging.converter.MessageConverter MessageConverter 消息转换接口 类图如下 两个方法 fromMessage: 从消息转换到 Object 1 Object fromMessage(Message&amp;lt;?&amp;gt; message, Class&amp;lt;?&amp;gt; targetClass); toMessage: 从 Object 转换到消息 1 Message&amp;lt;?&amp;gt; toMessage(Object payload, @Nullable MessageHeaders headers); 序号 class 作用 1 ByteArrayMessageConverter byte 数组消息转换器 2 MappingJackson2MessageConverter jackson2 的消息转换器 3 MarshallingMessageConverter xml 的消息转换器 4 StringMessageConverter 字符串消息转换器 AbstractMessageConverter 类图: fromMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @Override @Nullable public final Object fromMessage(Message&amp;lt;?&amp;gt; message,</description>
    </item>
    <item>
      <title>Spring-JmsTemplate</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-JmsTemplate/</link>
      <pubDate>Wed, 06 Mar 2024 13:25:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-JmsTemplate/</guid>
      <description>Spring JmsTemplate Author: HuiFer 源码阅读仓库: SourceHot-spring 源码路径: org.springframework.jms.core.JmsTemplate 源码分析 send 发送消息 1 2 3 4 5 6 7 8 9 @Override public void send(final String destinationName, final MessageCreator messageCreator) throws JmsException { // 执行. execute(session -&amp;gt; { Destination destination = resolveDestinationName(session, destinationName); doSend(session, destination, messageCreator); return null; }, false); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Nullable public &amp;lt;T&amp;gt; T execute(SessionCallback&amp;lt;T&amp;gt; action, boolean startConnection) throws JmsException { Assert.notNull(action, &amp;#34;Callback object must not be null&amp;#34;); Connection conToClose = null; Session sessionToClose = null; try { Session sessionToUse = ConnectionFactoryUtils.doGetTransactionalSession( obtainConnectionFactory(), this.transactionalResourceFactory, startConnection); if (sessionToUse ==</description>
    </item>
    <item>
      <title>Spring-EnableJms</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-EnableJms/</link>
      <pubDate>Wed, 06 Mar 2024 13:24:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/message/Spring-EnableJms/</guid>
      <description>Spring EnableJms 注解 Author: HuiFer 源码阅读仓库: SourceHot-spring 源码路径: org.springframework.jms.annotation.EnableJms 源码分析 1 2 3 4 5 6 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Import(JmsBootstrapConfiguration.class) public @interface EnableJms { } 该类的切入点在@Import(JmsBootstrapConfiguration.class) , 直接看JmsBootstrapConfiguration就可以了 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</description>
    </item>
    <item>
      <title>Spring-scan</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-scan/</link>
      <pubDate>Wed, 06 Mar 2024 13:16:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-scan/</guid>
      <description>Spring scan Author: HuiFer 源码阅读仓库: SourceHot-Spring 解析 Spring 注解形式使用有下面两种方式 通过AnnotationConfigApplicationContext参数:扫描包 通过 xml 配置context:component-scan属性base-package 1 2 AnnotationConfigApplicationContext aac = new AnnotationConfigApplicationContext(&amp;#34;com.huifer.source.spring.ann&amp;#34;); 1 2 &amp;lt;context:component-scan base-package=&amp;#34;com.huifer.source.spring.ann&amp;#34;&amp;gt; &amp;lt;/context:component-scan&amp;gt; 目标明确开始找入口方法 Annota</description>
    </item>
    <item>
      <title>Spring-beanFactory</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-beanFactory/</link>
      <pubDate>Wed, 06 Mar 2024 13:15:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-beanFactory/</guid>
      <description>Spring BeanFactory Author: HuiFer 源码阅读仓库: SourceHot-spring BeanFactory 概述 org.springframework.beans.factory.BeanFactory 类图 方法列表 贴出部分代码. 仅表示方法作用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface BeanFactory { // 从容器中根据beanname获取 Object getBean(String name) throws BeansException; // 延迟加载对象 &amp;lt;T&amp;gt; ObjectProvider&amp;lt;T&amp;gt; getBeanProvider(Class&amp;lt;T&amp;gt; requiredType); // 是否存在beanName boolean containsBean(String name); // 这个 beanName 是否是单例的. 映射成 bean boolean isSingleton(String name) throws NoSuchBeanDefinitionException; // 是否多例. boolean isPrototype(String name) throws NoSuchBeanDefinitionException; // 类</description>
    </item>
    <item>
      <title>Spring-SystemPropertyUtils</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SystemPropertyUtils/</link>
      <pubDate>Wed, 06 Mar 2024 13:14:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SystemPropertyUtils/</guid>
      <description>Spring SystemPropertyUtils spring 中获取系统属性的工具类 内部属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * * Prefix for system property placeholders: &amp;#34;${&amp;#34;. * 前缀占位符 * */ public static final String PLACEHOLDER_PREFIX = &amp;#34;${&amp;#34;; /** * Suffix for system property placeholders: &amp;#34;}&amp;#34;. * 后缀占位符 * */ public static final String PLACEHOLDER_SUFFIX = &amp;#34;}&amp;#34;; /** * Value separator for system property placeholders: &amp;#34;:&amp;#34;. * 值分割符号 * */ public static final String VALUE_SEPARATOR = &amp;#34;:&amp;#34;; /** * 占位符解析类 */ private static final PropertyPlaceholderHelper strictHelper = new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, false);</description>
    </item>
    <item>
      <title>Spring-StopWatch</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-StopWatch/</link>
      <pubDate>Wed, 06 Mar 2024 13:13:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-StopWatch/</guid>
      <description>Spring StopWatch Author: HuiFer 源码阅读仓库: SourceHot-spring 全路径: org.springframework.util.StopWatch 属性 taskList: 任务信息列表 keepTaskList: 是否保留任务信息列表 startTimeMillis: 任务开始的时间 currentTaskName: 任务名称 lastTaskInfo: 任务信息 taskCount: 任务数量 totalTimeMillis: 总共花费的时间 方法 org.springframework.util.StopWatch.start(java.lang.String) 1 2 3 4 5 6 7 public void start(String taskName) throws IllegalStateException { if (this.currentTaskName != null) { throw new IllegalStateException(&amp;#34;Can&amp;#39;t start StopWatch: it&amp;#39;s already running&amp;#34;); } this.currentTaskName = taskName; this.startTimeMillis = System.currentTimeMillis(); } org.springframework.util.StopWatch.stop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void stop() throws IllegalStateException { if (this.currentTaskName == null) { throw new IllegalStateException(&amp;#34;Can&amp;#39;t stop StopWatch: it&amp;#39;s not</description>
    </item>
    <item>
      <title>Spring-SpringFactoriesLoader</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SpringFactoriesLoader/</link>
      <pubDate>Wed, 06 Mar 2024 13:12:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SpringFactoriesLoader/</guid>
      <description>SpringFactoriesLoader Author: HuiFer 源码阅读仓库: SourceHot-spring-boot 全路径 : org.springframework.core.io.support.SpringFactoriesLoader 测试类 : org.springframework.core.io.support.SpringFactoriesLoaderTests loadFactories 加载并实例化工厂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; loadFactories(Class&amp;lt;T&amp;gt; factoryType, @Nullable ClassLoader classLoader) { Assert.notNull(factoryType, &amp;#34;&amp;#39;factoryType&amp;#39; must not be null&amp;#34;); ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) { classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); } // 工厂实现类名称 List&amp;lt;String&amp;gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse); if (logger.isTraceEnabled()) { logger.trace(&amp;#34;Loaded [&amp;#34; + factoryType.getName() + &amp;#34;] names: &amp;#34; + factoryImplementationNames); } List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(factoryImplementationNames.size()); for (String factoryImplementationName : factoryImplementationNames) { // 将实例化的工厂放入结果集合 result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse)); } // 排序 AnnotationAwareOrderComparator.sort(result); return</description>
    </item>
    <item>
      <title>Spring-SimpleAliasRegistry</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SimpleAliasRegistry/</link>
      <pubDate>Wed, 06 Mar 2024 13:11:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-SimpleAliasRegistry/</guid>
      <description>Spring-SimpleAliasRegistry Author: HuiFer 源码阅读仓库: huifer-spring AliasRegistry SimpleAliasRegistry继承org.springframework.core.AliasRegistry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public interface AliasRegistry { /** * Given a name, register an alias for it. * 别名注册 * * @param name the canonical</description>
    </item>
    <item>
      <title>Spring-Scheduling</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Scheduling/</link>
      <pubDate>Wed, 06 Mar 2024 13:10:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Scheduling/</guid>
      <description>Spring 定时任务 Author: HuiFer 源码阅读仓库: SourceHot-spring EnableScheduling 首先关注的类为启动定时任务的注解@EnableScheduling 1 2 3 4 5 6 7 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Import(SchedulingConfiguration.class) @Documented public @interface EnableScheduling { } SchedulingConfiguration 注册定时任务相关信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Configuration @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public class SchedulingConfiguration { /** * 开启定时任务 * @return */ @Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME) @Role(BeanDefinition.ROLE_INFRASTRUCTURE) public ScheduledAnnotationBeanPostProcessor scheduledAnnotationProcessor() { // 注册 ScheduledAnnotationBeanPostProcessor return new ScheduledAnnotationBeanPostProcessor(); } } ScheduledAnnotationBeanPostProcessor 关注 application 事件,以及 spring 生命周期</description>
    </item>
    <item>
      <title>Spring-PropertySources</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-PropertySources/</link>
      <pubDate>Wed, 06 Mar 2024 13:09:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-PropertySources/</guid>
      <description>Spring PropertySources Author: HuiFer 源码阅读仓库: SourceHot-spring MutablePropertySources 全路径: org.springframework.core.env.MutablePropertySources MutablePropertySources类内部存储了List&amp;lt;PropertySource&amp;lt;?&amp;gt;&amp;gt;对象,主要是针对List&amp;lt;PropertySource&amp;lt;?&amp;gt;&amp;gt; 进行的操作.换句话说就是对 list 操作</description>
    </item>
    <item>
      <title>Spring-PropertyPlaceholderHelper</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-PropertyPlaceholderHelper/</link>
      <pubDate>Wed, 06 Mar 2024 13:08:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-PropertyPlaceholderHelper/</guid>
      <description>Spring PropertyPlaceholderHelper 类全路径: org.springframework.util.PropertyPlaceholderHelper parseStringValue org.springframework.util.PropertyPlaceholderHelper#parseStringValue 这个方法是主要方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 protected String parseStringValue( String value, PlaceholderResolver placeholderResolver, @Nullable Set&amp;lt;String&amp;gt; visitedPlaceholders) { // 占位符所在位置 int startIndex = value.indexOf(this.placeholderPrefix); if (startIndex == -1) { return value; } // 返回值 StringBuilder result = new StringBuilder(value); while (startIndex != -1) { // 寻找结尾占位符</description>
    </item>
    <item>
      <title>Spring-Property</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Property/</link>
      <pubDate>Wed, 06 Mar 2024 13:07:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Property/</guid>
      <description>Spring Property Author: HuiFer 源码阅读仓库: SourceHot-spring 相关类 org.springframework.beans.PropertyValues org.springframework.beans.PropertyValue org.springframework.beans.MutablePropertyValues 类图如下 在 Spring IoC 中,非 Web 工程,使用 xml 或者注解进行配置主要使用到的是 PropertyValues ，PropertyValue ，MutablePropertyValues 三个 其中 PropertyValues 是继承迭代器，具体实现在MutablePropertyValues 他们处理的对象是Propert</description>
    </item>
    <item>
      <title>Spring-OrderUtils</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-OrderUtils/</link>
      <pubDate>Wed, 06 Mar 2024 13:06:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-OrderUtils/</guid>
      <description>Spring OrderUtils Author: HuiFer 源码阅读仓库: SourceHot-Spring org.springframework.core.annotation.OrderUtils主要方法如下 getOrder getPriority 测试类org.springframework.core.annotation.OrderUtilsTests 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20</description>
    </item>
    <item>
      <title>Spring-OrderComparator</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-OrderComparator/</link>
      <pubDate>Wed, 06 Mar 2024 13:05:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-OrderComparator/</guid>
      <description>Spring OrderComparator Author: HuiFer 源码阅读仓库: SourceHot-Spring 1 2 3 4 5 6 7 8 9 10 11 12 13 14 private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) { boolean p1 = (o1 instanceof PriorityOrdered); boolean p2 = (o2 instanceof PriorityOrdered); if (p1 &amp;amp;&amp;amp; !p2) { return -1; } else if (p2 &amp;amp;&amp;amp; !p1) { return 1; } int i1 = getOrder(o1, sourceProvider); int i2 = getOrder(o2, sourceProvider); // 对比两个Order值得大小返回 return Integer.compare(i1, i2); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 private int getOrder(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider) { Integer order = null; if (obj != null &amp;amp;&amp;amp; sourceProvider</description>
    </item>
    <item>
      <title>Spring-MultiValueMap</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MultiValueMap/</link>
      <pubDate>Wed, 06 Mar 2024 13:04:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MultiValueMap/</guid>
      <description>Spring MultiValueMap Author: HuiFer 源码阅读仓库: SourceHot-spring 类路径: org.springframework.util.MultiValueMap 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public interface MultiValueMap&amp;lt;K, V&amp;gt; extends Map&amp;lt;K, List&amp;lt;V&amp;gt;&amp;gt; { /** * 获取value的第一 */ @Nullable V getFirst(K key); /** * 添加元素 */ void add(K key, @Nullable V value); /** * 添加所有元素 */ void addAll(K key, List&amp;lt;? extends V&amp;gt; values); /** * 添加要给 {@link MultiValueMap} 对象 */ void addAll(MultiValueMap&amp;lt;K, V&amp;gt; values); default void addIfAbsent(K key, @Nullable V value) {</description>
    </item>
    <item>
      <title>Spring-MethodOverride</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MethodOverride/</link>
      <pubDate>Wed, 06 Mar 2024 13:03:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MethodOverride/</guid>
      <description>Spring MethodOverride Author: HuiFer 源码阅读仓库: SourceHot-spring org.springframework.beans.factory.support.MethodOverride org.springframework.beans.factory.support.LookupOverride org.springframework.beans.factory.support.ReplaceOverride org.springframework.beans.factory.support.MethodOverrides MethodOverride MethodOverride 方法重载类 在MethodOverride定义了下面三个属性 方法名称 是否重载 源 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class MethodOverride implements BeanMetadataElement { /** * 方法名称 */ private final String methodName; /** * 是否重载 */ private boolean overloaded = true; /** * 源 */ @Nullable private Object source; } 定义了一个抽象方法, 交由子类实现 1 public abstract boolean matches(Method method); 类图 在 Spring 中</description>
    </item>
    <item>
      <title>Spring-Metadata</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Metadata/</link>
      <pubDate>Wed, 06 Mar 2024 13:02:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Metadata/</guid>
      <description>Spring 元信息 Author: HuiFer 源码阅读仓库: SourceHot-Spring ClassMetadata 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 public interface ClassMetadata { /** * 类名 */ String getClassName(); /** * 是否是接口 */ boolean isInterface(); /** * 是否是注解 */ boolean isAnnotation(); /** * 是否是超类 */ boolean isAbstract(); /** * 是否允许创</description>
    </item>
    <item>
      <title>Spring-MessageSource</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MessageSource/</link>
      <pubDate>Wed, 06 Mar 2024 13:01:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-MessageSource/</guid>
      <description>Spring MessageSource Author: HuiFer 源码阅读仓库: SourceHot-Spring 初始化入口 org.springframework.context.support.AbstractApplicationContext.refresh方法有initMessageSource()方法进行了MessageSource初始化 1 2 3 4 5 6 7 8 9 10</description>
    </item>
    <item>
      <title>Spring-Import</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Import/</link>
      <pubDate>Wed, 06 Mar 2024 13:00:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Import/</guid>
      <description>Spring Import Author: HuiFer 源码阅读仓库: SourceHot-spring 分析 org.springframework.context.annotation.Import 1 2 3 4 5 6 7 8 9 10 11 12 13 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Import { /** * {@link Configuration @Configuration}, {@link ImportSelector}, * {@link ImportBeanDefinitionRegistrar}, or regular component classes to import. * * 需要导入的类 */ Class&amp;lt;?&amp;gt;[] value(); } ImportBeanDefinitionRegistrar 注册 Import Bean org.springframework.context.annotation.ImportBeanDefinitionRegistrar 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public interface ImportBeanDefinitionRegistrar { /** * Register bean definitions as necessary based on the given annotation metadata of * the importing {@code @Configuration} class. * &amp;lt;p&amp;gt;Note that {@link BeanDefinitionRegistryPostProcessor} types may &amp;lt;em&amp;gt;not&amp;lt;/em&amp;gt; be * registered here, due to lifecycle constraints related to {@code @Configuration} * class processing. * * 对impor</description>
    </item>
    <item>
      <title>Spring-EntityResolver</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-EntityResolver/</link>
      <pubDate>Wed, 06 Mar 2024 12:59:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-EntityResolver/</guid>
      <description>EntityResolver Author: HuiFer 源码阅读仓库: huifer-spring 源码路径: org.xml.sax.EntityResolver,非 Spring 类 DelegatingEntityResolver#resolveEntity org.springframework.beans.factory.xml.DelegatingEntityResolver.resolveEntity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Override @Nullable public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws SAXException, IOException { if (systemId != null) { if (systemId.endsWith(DTD_SUFFIX)) { return this.dtdResolver.resolveEntity(publicId, systemId); } else if (systemId.endsWith(XSD_SUFFIX)) { return this.schemaResolver.resolveEntity(publicId, systemId); } } // Fall back to the parser&amp;#39;s default behavior. return null; } 上述这段代码是针对 xml 进行校验 1 2 3 &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; 如上所示以.x</description>
    </item>
    <item>
      <title>Spring-DefaultSingletonBeanRegistry</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-DefaultSingletonBeanRegistry/</link>
      <pubDate>Wed, 06 Mar 2024 12:58:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-DefaultSingletonBeanRegistry/</guid>
      <description>DefaultSingletonBeanRegistry Author: HuiFer 源码阅读仓库: SourceHot-Spring 源码路径: org.springframework.beans.factory.support.DefaultSingletonBeanRegistry 官方提供的测试类: org.springframework.beans.factory.support.DefaultSingletonBeanRegistryTests 类图 注册方法解析 从名字可以看出这是一个单例对象的注册类 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.registerSingleton 测试用例出发 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Test public void testSingletons() { DefaultSingletonBeanRegistry beanRegistry = new DefaultSingletonBeanRegistry(); TestBean tb = new TestBean(); beanRegistry.registerSingleton(&amp;#34;tb&amp;#34;, tb); assertSame(tb, beanRegistry.getSingleton(&amp;#34;tb&amp;#34;)); TestBean tb2 = (TestBean) beanRegistry.getSingleton(&amp;#34;tb2&amp;#34;, new ObjectFactory&amp;lt;Object&amp;gt;() { @Override public Object getObject() throws BeansException { return new TestBean(); } }); assertSame(tb2, beanRegistry.getSingleton(&amp;#34;tb2&amp;#34;)); assertSame(tb, beanRegistry.getSingleton(&amp;#34;tb&amp;#34;)); assertSame(tb2, beanRegistry.getSingleton(&amp;#34;tb2&amp;#34;)); assertEquals(2, beanRegistry.getSingletonCount()); String[] names = beanRegistry.getSingletonNames();</description>
    </item>
    <item>
      <title>Spring-Custom-label-resolution</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Custom-label-resolution/</link>
      <pubDate>Wed, 06 Mar 2024 12:57:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Custom-label-resolution/</guid>
      <description>Spring 自定义标签解析 Author: HuiFer 源码阅读仓库: SourceHot-Spring 与自定义标签解析相关的类 org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser org.springframework.beans.factory.xml.NamespaceHandlerSupport 开始源码之前先搭建一个环境 环境搭建 创建对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class UserXtd { private String userName; private String emailAddress; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getEmailAddress() { return emailAddress; } public void setEmailAddress(String emailAddress) { this.emailAddress = emailAddress; } } 创建 xsd 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34; ?&amp;gt; &amp;lt;schema xmlns=&amp;#34;http://www.w3.org/2001/XMLSchema&amp;#34;</description>
    </item>
    <item>
      <title>Spring-Custom-attribute-resolver</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Custom-attribute-resolver/</link>
      <pubDate>Wed, 06 Mar 2024 12:56:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Custom-attribute-resolver/</guid>
      <description>Spring 自定义属性解析器 Author: HuiFer 源码阅读仓库: SourceHot-Spring 用例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;bean class=&amp;#34;org.springframework.beans.factory.config.CustomEditorConfigurer&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;propertyEditorRegistrars&amp;#34;&amp;gt; &amp;lt;list&amp;gt; &amp;lt;bean class=&amp;#34;com.huifer.source.spring.bean.DatePropertyRegister&amp;#34;/&amp;gt; &amp;lt;/list&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;property name=&amp;#34;customEditors&amp;#34;&amp;gt; &amp;lt;map&amp;gt; &amp;lt;entry key=&amp;#34;java.util.Date&amp;#34; value=&amp;#34;com.huifer.source.spring.bean.DatePropertyEditor&amp;#34;&amp;gt; &amp;lt;/entry&amp;gt; &amp;lt;/map&amp;gt; &amp;lt;/property&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;bean id=&amp;#34;apple&amp;#34; class=&amp;#34;com.huifer.source.spring.bean.Apple&amp;#34;&amp;gt; &amp;lt;property name=&amp;#34;date&amp;#34; value=&amp;#34;2020-01-01 01:01:01&amp;#34;/&amp;gt; &amp;lt;/bean&amp;gt; &amp;lt;/beans&amp;gt; 1 2 3 4 5 6 7 8 public class DatePropertyRegister implements PropertyEditorRegistrar { @Override public void registerCustomEditors(PropertyEditorRegistry registry) { registry.registerCustomEditor(Date.class, new CustomDateEditor( new SimpleDateFormat(&amp;#34;yyyy-MM-dd&amp;#34;), true) ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class DatePropertyEditor extends PropertyEditorSupport {</description>
    </item>
    <item>
      <title>Spring-Conditional</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Conditional/</link>
      <pubDate>Wed, 06 Mar 2024 12:55:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-Conditional/</guid>
      <description>Spring Conditional Author: HuiFer 源码阅读仓库: SourceHot-spring Conditional 1 2 3 4 5 6 7 8 9 10 11 @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Conditional { /** * 多个匹配器接口 */ Class&amp;lt;? extends Condition&amp;gt;[] value(); } Condition @FunctionalInterface public interface Condition { /** * 匹配,如果匹配返回true进行初始化,返回false跳过初始化 */ boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } ConditionContext 上下文 AnnotatedTypeMetadata 注解信息 ConditionContext public interface ConditionContext { /** * bean的定义 */ BeanDefinitionRegistry getRegistry(); /** * bean 工厂 */ @Nullable ConfigurableListableBeanFactory getBeanFactory(); /** * 环境 */ Environment getEnvironment(); /** * 资</description>
    </item>
    <item>
      <title>Spring-BeanNameGenerator</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanNameGenerator/</link>
      <pubDate>Wed, 06 Mar 2024 12:54:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanNameGenerator/</guid>
      <description>Spring BeanNameGenerator Author: HuiFer 源码阅读仓库: SourceHot-spring org.springframework.beans.factory.support.BeanNameGenerator 方法用来生成 beanName 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface BeanNameGenerator { /** * Generate a bean name for the given bean definition. * 生成 beanName * @param definition the bean definition to generate a name for * @param registry the bean definition registry that the given definition * is supposed to be registered with * @return the generated bean name */ String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry); } DefaultBeanNameGenerator org.springframework.beans.factory.support.DefaultBeanNameGenerator 调用工具类方法进行生成 1 2 3 4 @Override public String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) { return BeanDefinitionReaderUtils.generateBeanName(definition, registry); } ClassName + # + 十六进制字符 parentName + $child + # + 十</description>
    </item>
    <item>
      <title>Spring-BeanFactoryPostProcessor</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanFactoryPostProcessor/</link>
      <pubDate>Wed, 06 Mar 2024 12:53:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanFactoryPostProcessor/</guid>
      <description>Spring BeanFactoryPostProcessor Author: HuiFer 源码阅读仓库: SourceHot-Spring 作用: 定制或修改BeanDefinition的属性 Demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 public class ChangeAttrBeanPostProcessor implements BeanFactoryPostProcessor { private Set&amp;lt;String&amp;gt; attr; public ChangeAttrBeanPostProcessor() { attr = new HashSet&amp;lt;&amp;gt;(); } public Set&amp;lt;String&amp;gt; getAttr() { return attr; } public void setAttr(Set&amp;lt;String&amp;gt; attr) { this.attr = attr; } @Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { String[] beanDefinitionNames = beanFactory.getBeanDefinitionNames(); for (String beanName : beanDefinitionNames) { BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName); StringValueResolver stringValueResolver = new StringValueResolver() { @Override public String resolveStringValue(String</description>
    </item>
    <item>
      <title>Spring-BeanDefinitionReaderUtils</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanDefinitionReaderUtils/</link>
      <pubDate>Wed, 06 Mar 2024 12:52:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanDefinitionReaderUtils/</guid>
      <description>Spring BeanDefinitionReaderUtils Author: HuiFer 源码阅读仓库: SourceHot-spring createBeanDefinition org.springframework.beans.factory.support.BeanDefinitionReaderUtils.createBeanDefinition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static AbstractBeanDefinition createBeanDefinition( @Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException { GenericBeanDefinition bd = new GenericBeanDefinition(); // 设置 父bean bd.setParentName(parentName); if (className != null) { if (classLoader != null) { // 设置 class // 内部是通过反射创建 class bd.setBeanClass(ClassUtils.forName(className, classLoader)); } else { // 设置 class name bd.setBeanClassName(className); } } return bd; } generateBeanName org.springframework.beans.factory.support.BeanDefinitionReaderUtils.generateBeanName(org.springframework.beans.factory.config.BeanDefinition, org.springframework.beans.factory.support.BeanDefinitionRegistry, boolean) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32</description>
    </item>
    <item>
      <title>Spring-BeanDefinitionParserDelegate</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanDefinitionParserDelegate/</link>
      <pubDate>Wed, 06 Mar 2024 12:51:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-BeanDefinitionParserDelegate/</guid>
      <description>Spring BeanDefinitionParserDelegate Author: HuiFer 源码阅读仓库: SourceHot-spring 全路径org.springframework.beans.factory.xml.BeanDefinitionParserDelegate 解析 xml 中标签的委托类 在这个类中定义常量如下，为后续解析提供帮助 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28</description>
    </item>
    <item>
      <title>Spring-ApplicationListener</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-ApplicationListener/</link>
      <pubDate>Wed, 06 Mar 2024 12:50:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-ApplicationListener/</guid>
      <description>Spring initApplicationEventMulticaster Author: HuiFer 源码阅读仓库: SourceHot-Spring demo 1 2 3 4 5 6 7 8 9 10 11 package com.huifer.source.spring.applicationListener; import org.springframework.context.ApplicationEvent; import org.springframework.context.ApplicationListener; public class DemoApplicationListener implements ApplicationListener { @Override public void onApplicationEvent(ApplicationEvent event) { System.out.println(&amp;#34;com.huifer.source.spring.applicationListener.DemoApplicationListener.onApplicationEvent&amp;#34;); } } 1 2 3 4 5 6 7 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;bean id=&amp;#34;demoApplicationListener&amp;#34; class=&amp;#34;com.huifer.source.spring.applicationListener.DemoApplicationListener&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 1 2 3 4 5 public class ListenerSourceCode { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&amp;#34;Listener-demo.xml&amp;#34;); } } 初始化入口 org.springframework.context.support.AbstractAppli</description>
    </item>
    <item>
      <title>Spring-AnnotationUtils</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-AnnotationUtils/</link>
      <pubDate>Wed, 06 Mar 2024 12:49:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/clazz/Spring-AnnotationUtils/</guid>
      <description>Spring AnnotationUtils Author: HuiFer 源码阅读仓库: SourceHot-Spring org.springframework.core.annotation.AnnotationUtils提供了注解相关的方法 getAnnotation: 获取注解 findAnnotation: 寻找注解 getValue: 获取属性值 getDefaultValue: 获取默认值 getAnnotation 测试用例如下 1 2 3 4 5 6 7 @Test public void findMethodAnnotationOnLeaf() throws Exception { Method m = Leaf.class.getMethod(&amp;#34;annotatedOnLeaf&amp;#34;); assertNotNull(m.getAnnotation(Order.class)); assertNotNull(getAnnotation(m, Order.class)); assertNotNull(findAnnotation(m, Order.class)); } org.springframework.core.annotation.AnnotationUtils.getAnnotation(java.lang.reflect.Method, java.lang.Class&amp;lt;A&amp;gt;) 1 2 3 4 5 6 7 8 9 10 11 12</description>
    </item>
    <item>
      <title>Spring-transaction</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/TX/Spring-transaction/</link>
      <pubDate>Wed, 06 Mar 2024 12:31:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/TX/Spring-transaction/</guid>
      <description>Spring 事务 Author: HuiFer 源码阅读仓库: SourceHot-Spring 声明式事务 Propagation 事务传播 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public enum Propagation { /** * 有事务则加入，没有则新建 */ REQUIRED(TransactionDefinition.PROPAGATION_REQUIRED), /** * 有事务就用，如果没有就不开启(继承关系) * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */ SUPPORTS(TransactionDefinition.PROPAGATION_SUPPORTS), /** * 必须在已有事务中 */ MANDATORY(TransactionDefinition.PROPAGATION_MANDATORY), /** * 不管</description>
    </item>
    <item>
      <title>面筋哥IoC容器的一天(上)</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/Spring%E6%BA%90%E7%A0%81%E6%95%85%E4%BA%8B%E7%9E%8E%E7%BC%96%E7%89%88/%E9%9D%A2%E7%AD%8B%E5%93%A5IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E5%A4%A9%E4%B8%8A/</link>
      <pubDate>Wed, 06 Mar 2024 12:30:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/Spring%E6%BA%90%E7%A0%81%E6%95%85%E4%BA%8B%E7%9E%8E%E7%BC%96%E7%89%88/%E9%9D%A2%E7%AD%8B%E5%93%A5IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E5%A4%A9%E4%B8%8A/</guid>
      <description>引言：庞大的代码量让人心生怠倦，有趣的故事让技术也疯狂。 大家好，我是 IoC 容器家族的第 17 代传人，我们家族世世代代在 spring 商业街上卖烤面筋，大家都叫我“面筋哥”，另外我爹还给我起了个高大上的英文名字，叫“FileSystemXmlApplicationContext”，但有群臭猴子嫌麻烦，</description>
    </item>
    <item>
      <title>16张图解锁Spring的整体脉络</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/Spring%E6%95%B4%E4%BD%93%E8%84%89%E7%BB%9C/16%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%94%81Spring%E7%9A%84%E6%95%B4%E4%BD%93%E8%84%89%E7%BB%9C/</link>
      <pubDate>Wed, 06 Mar 2024 12:29:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/Spring%E6%95%B4%E4%BD%93%E8%84%89%E7%BB%9C/16%E5%BC%A0%E5%9B%BE%E8%A7%A3%E9%94%81Spring%E7%9A%84%E6%95%B4%E4%BD%93%E8%84%89%E7%BB%9C/</guid>
      <description>作者: Java4ye 概览 本文将讲解 Spring 的原理，看看一个 Bean 是怎么被创建出来的，中间经历过那几道工序加工，它的生命周期是怎样的，以及有哪些扩展点，后置处理器可以使用，让你对 Spring 多一些了解！ 目录 本文会先大概介绍下这些知识点 👇 印象中的 Spring 脑海中有这么一条公式： 👉 IOC = 工厂模式 + XML + 反射 👉 而 DI , AOP ， 事务 等也都</description>
    </item>
    <item>
      <title>Spring声明式事务处理</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2024 12:28:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</guid>
      <description>1 设计原理与基本过程 在使用 Spring 声明式事务处理 的时候，一种常用的方法是结合 IoC 容器 和 Spring 已有的 TransactionProxyFactoryBean 对事务管理进行配置，比如，可以在这个 TransactionProxyFactoryBean 中为事务方法配置传播行为、并发事务隔离级别等事务处理属性，从而对声明式事务的处理提供指导。具体来说，在对声明式事务处理的原理分析中，声明式事务处理的实现大</description>
    </item>
    <item>
      <title>Spring事务管理器的设计与实现</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Mar 2024 12:27:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>1 Spring 事务处理的应用场景 下面，我们以 DataSourceTransactionManager 事务管理器 为例，看一下在具体的事务管理器中如何实现事务创建、提交和回滚这些底层的事务处理操作。DataSourceTransationManager 和其他事务管理器一样，如 JtaTransactionManager，JpaTransaction</description>
    </item>
    <item>
      <title>Spring事务处理的设计与实现</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Mar 2024 12:26:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>1 事务处理的编程式使用 1 2 3 4 5 6 7 8 9 10 11 TransactionDefinition td = new DefaultTransactionDefinition(); // transactionManager 是某一个具体的 PlatformTransactionManager实现类 的对象 TransactionStatus ts = transactionManager.getTransaction(td); try { // 这里是需要进行事务处理的方法调用 } catch (Exception e) { transactionManager.rollback(ts); throw e; } transactionManager.commit(ts); 在使用编程式事务处理的过程中，利用 DefaultTransactionDefinition 对象 来持有事务处理属性。同时，在创建事务的</description>
    </item>
    <item>
      <title>Spring与事务处理</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2024 12:25:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringTransaction/Spring%E4%B8%8E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</guid>
      <description>JavaEE 应用中的事务处理是一个重要并且涉及范围很广的领域。事务管理的实现往往涉及并发和数据一致性方面的问题。作为应用平台的 Spring，具有在多种环境中配置和使用事务处理的能力，也就是说通过使用 Spring 的事务组件，可以把事务处理的工作统一起来，并为事务处理提供通用的支持。 在涉及单个数据库局部</description>
    </item>
    <item>
      <title>温习一下servlet</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/%E6%B8%A9%E4%B9%A0%E4%B8%80%E4%B8%8Bservlet/</link>
      <pubDate>Wed, 06 Mar 2024 12:24:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/%E6%B8%A9%E4%B9%A0%E4%B8%80%E4%B8%8Bservlet/</guid>
      <description>Servlet 温习 Servlet 是 Java 平台上用于扩展基于请求-响应模式的 Web 应用程序功能的一种技术。在这篇博客中，我们将温习一下 Servlet 的基本概念和使用方法。 1. Servlet 的基本概念 Servlet 是 Java 平台上运行的一个小程序，它可以接收和响应来自客户端的请求，并向客户端发送响应。Servlet 容器（如 Tomcat）负责管理 Servlet 的生命周期，</description>
    </item>
    <item>
      <title>SpringMVC的设计与实现</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Mar 2024 12:23:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/SpringMVC%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>1 SpringMVC 应用场景 在使用 SpringMVC 时，除了要在 web.xml 中配置 ContextLoaderListener 外，还要对 DispatcherServlet 进行配置。作为一个 Servlet，这个 DispatcherServlet 实现的是 Sun 的 J2EE 核心模式 中的 前端控制器模式(Front Controller)， 作为一个前端控制器，所有的 Web 请求 都需要通过它来进行转发、匹配、数据处理，然后转由页面进行展现，因此这个 DispatcerServlet 可以看</description>
    </item>
    <item>
      <title>SpringMVC-CROS</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/SpringMVC-CROS/</link>
      <pubDate>Wed, 06 Mar 2024 12:22:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/SpringMVC-CROS/</guid>
      <description>Spring-MVC 跨域 CrossOrigin 注解 通过注解设置跨域 demo 如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package com.huifer.source.controller; import org.springframework.web.bind.annotation.*; import java.util.HashMap; @CrossOrigin(maxAge = 3600) @RequestMapping(&amp;#34;/&amp;#34;) @RestController public class JSONController { @ResponseBody @GetMapping(value = &amp;#34;/json&amp;#34;) public Object ob() { HashMap&amp;lt;String, String&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); hashMap.put(&amp;#34;1&amp;#34;, &amp;#34;a&amp;#34;); return hashMap; } } 切入点: org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#registerHandlerMethod org.springframework.web.servlet.handler.AbstractHandlerMethodMapp</description>
    </item>
    <item>
      <title>IoC容器在Web环境中的启动</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/IoC%E5%AE%B9%E5%99%A8%E5%9C%A8Web%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Wed, 06 Mar 2024 12:21:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/SpringMVC/IoC%E5%AE%B9%E5%99%A8%E5%9C%A8Web%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%90%AF%E5%8A%A8/</guid>
      <description>1 Web 环境中的 SpringMVC 在 Web 环境 中，SpringMVC 是建立在 IoC 容器 基础上的。了解 SpringMVC，首先要了解 Spring 的 IoC 容器 是如何在 Web 环境 中被载入并起作用的。 Spring 的 IoC 是一个独立模块，它并不直接在 Web 容器 中发挥作用，如果要在 Web 环境 中使用 IoC 容器，需要 Spring 为 IoC 设计一个启动过程，把 IoC 容器 导入，并在 Web 容器 中</description>
    </item>
    <item>
      <title>Spring-spring-components</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/Spring5%E6%96%B0%E7%89%B9%E6%80%A7/Spring-spring-components/</link>
      <pubDate>Wed, 06 Mar 2024 12:20:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/Spring5%E6%96%B0%E7%89%B9%E6%80%A7/Spring-spring-components/</guid>
      <description>Spring5 新特性 - spring.components Author: HuiFer 源码阅读仓库: SourceHot-Spring 解析 相关类: org.springframework.context.index.CandidateComponentsIndexLoader 测试用例: org.springframework.context.annotation.ClassPathScanningCandidateComponentProviderTests.defaultsWithIndex,org.springframework.context.index.CandidateComponentsIndexLoaderTests CandidateComponentsIndexLoader是怎么找出来的,全文搜索spring.components 使用介绍 下面是从resources/example/scannable/spring.component</description>
    </item>
    <item>
      <title>Spring-RMI</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/RMI/Spring-RMI/</link>
      <pubDate>Wed, 06 Mar 2024 12:19:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/RMI/Spring-RMI/</guid>
      <description>Spring RMI Author: HuiFer 源码阅读仓库: SourceHot-Spring Spring 远程服务调用 DEMO 服务提供方 服务提供方需要准备接口、接口实现泪 接口 1 2 3 public interface IDemoRmiService { int add(int a, int b); } 接口实现 1 2 3 4 5 6 public class IDemoRmiServiceImpl implements IDemoRmiService { @Override public int add(int a, int b) { return a + b; } } xml 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&amp;#34;&amp;gt; &amp;lt;bean id=&amp;#34;demoRmiService&amp;#34; class=&amp;#34;com.huifer.source.spring.rmi.impl.IDemoRmiServiceImpl&amp;#34;/&amp;gt; &amp;lt;bean id=&amp;#34;demoRmi&amp;#34; class=&amp;#34;org.springframework.remoting.rmi.RmiServiceExporter&amp;#34;&amp;gt; &amp;lt;!-- 服务--&amp;gt; &amp;lt;property name=&amp;#34;service&amp;#34; ref=&amp;#34;demoRmiService&amp;#34;/&amp;gt; &amp;lt;!-- 服务名称</description>
    </item>
    <item>
      <title>Spring-jdbc</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/JDBC/Spring-jdbc/</link>
      <pubDate>Wed, 06 Mar 2024 12:18:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/JDBC/Spring-jdbc/</guid>
      <description>Spring JDBC Author: HuiFer 源码阅读仓库: SourceHot-Spring 环境搭建 依赖 1 2 3 compile(project(&amp;#34;:spring-jdbc&amp;#34;)) compile group: &amp;#39;com.alibaba&amp;#39;, name: &amp;#39;druid&amp;#39;, version: &amp;#39;1.1.21&amp;#39; compile group: &amp;#39;mysql&amp;#39;, name: &amp;#39;mysql-connector-java&amp;#39;, version: &amp;#39;5.1.47&amp;#39; db 配置 1 2 3 4 jdbc.url= jdbc.driverClass= jdbc.username= jdbc.password= 实体对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class HsLog { private Integer id; private String source; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getSource() { return source; } public void setSource(String source) { this.source = source; } } DAO 1 2 3 4 5 public interface HsLogDao { List&amp;lt;HsLog&amp;gt; findAll(); void save(HsLog hsLog); } 实现类 1 2 3 4 5 6</description>
    </item>
    <item>
      <title>循环依赖</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Wed, 06 Mar 2024 12:17:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</guid>
      <description>循环依赖 一个对象依赖对象闭环到自己 A -&amp;gt; B -&amp;gt; &amp;hellip;. -&amp;gt;A tip: 不涉及代理对象问题 解决方法：当一个对象已经实例化完毕了，还未初始化的时候，将它注入到它所依赖的已经实例好的对象（提前暴露对象），使得它所依赖的对象是个完整对象（实例化+初始化），然后再将这个完整对象注入给它。 简单工程（Spring-</description>
    </item>
    <item>
      <title>BeanPostProcessor</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/BeanPostProcessor/</link>
      <pubDate>Wed, 06 Mar 2024 12:16:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/BeanPostProcessor/</guid>
      <description>BeanPostProcessor 源码分析 BeanPostProcessor 接口也叫 Bean 后置处理器，作用是在 Bean 对象实例化和依赖注入完成后，在配置文件 bean 的 init-method(初始化方法)或者 InitializingBean 的 afterPropertiesSet 的前后添加我们自己的处理逻辑。注意是 Bean 实例化完毕后及依赖注入完成后触发的，接口的源码如下。 1 2 3 4 5 6 7 8 9 10 11 12 public interface BeanPostProcessor { /** * 实例化、依赖注入完毕，</description>
    </item>
    <item>
      <title>BeanFactoryPostProcessor</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/BeanFactoryPostProcessor/</link>
      <pubDate>Wed, 06 Mar 2024 12:15:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/BeanFactoryPostProcessor/</guid>
      <description>BeanFactoryBeanPostProcessor 源码分析 BeanFactoryBeanPostProcessor 是当 BeanDefinition 读取完元数据（也就是从任意资源中定义的 bean 数据）后还未实例化之前可以进行修改 抄录并翻译官方的语句 BeanFactoryPostProcessor 操作 bean 的元数据配置. 也就是说,Spring IoC 容器允许 BeanFactoryPostProcessor 读取配置元数据, 并可能在容器实例化除 BeanFactoryPostProcessor 实例之外的任何 bean 之前 更改它 tip: 在 BeanFactoryPostProcessor (例如使用 BeanFactory.getBean()) 中使用这些 bean 的实例虽然在技术上</description>
    </item>
    <item>
      <title>4、依赖注入(DI)</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/4%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/</link>
      <pubDate>Wed, 06 Mar 2024 12:14:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/4%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5DI/</guid>
      <description>前言 前面我们主要分析了 FileSystemXmlApplicationContext 这个具体的 IoC 容器实现类 的初始化源码，在 IoC 容器 中建立了 beanName 到 BeanDefinition 的数据映射，通过一个 ConcurrentHashMap。现在我们来看一下 Spring 是如何将 IoC 容器中存在依赖关系的 bean 根据配置联系在一起的。 Spring 中触发 IoC 容器“依赖注入” 的方式有两种，一个是应用程序通过 getBea</description>
    </item>
    <item>
      <title>3、将BeanDefinition注册进IoC容器</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/3%E5%B0%86BeanDefinition%E6%B3%A8%E5%86%8C%E8%BF%9BIoC%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Wed, 06 Mar 2024 12:13:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/3%E5%B0%86BeanDefinition%E6%B3%A8%E5%86%8C%E8%BF%9BIoC%E5%AE%B9%E5%99%A8/</guid>
      <description>前言 这篇文章分享一下 spring IoC 容器初始化第三部分的代码，也就是将前面解析出来的 BeanDefinition 对象 注册进 IoC 容器，其实就是存入一个 ConcurrentHashMap&amp;lt;String, BeanDefinition&amp;gt; 中。 （PS：可以结合我 GitHub 上对 Spring 框架源码的翻译注释一起看，会更有助于各位同学理解，地址： spring-beans https://github.com/AmyliaY/spring-beans-reading spring-context https://github.com/AmyliaY/spring-context-reading ） 正文 回过头看一下前面在 DefaultBeanDefinitionDocumentReader 中实现的 processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) 方法。 1 2 3 4 5 6 7 8 9 10 11 12 13</description>
    </item>
    <item>
      <title>2、将bean解析封装成BeanDefinition</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/2%E5%B0%86bean%E8%A7%A3%E6%9E%90%E5%B0%81%E8%A3%85%E6%88%90BeanDefinition/</link>
      <pubDate>Wed, 06 Mar 2024 12:12:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/2%E5%B0%86bean%E8%A7%A3%E6%9E%90%E5%B0%81%E8%A3%85%E6%88%90BeanDefinition/</guid>
      <description>前言 接着上一篇的 BeanDefinition 资源定位开始讲。Spring IoC 容器 BeanDefinition 解析过程就是把用户在配置文件中配置的 bean，解析并封装成 IoC 容器可以装载的 BeanDefinition 对象，BeanDefinition 是 Spring 定义的基本数据结构，其中的属性与配置文件中 bean 的属性相对应。 （PS：可以结合我 GitHub 上对 Spring 框架源码的阅读及个人理解一起</description>
    </item>
    <item>
      <title>1、BeanDefinition的资源定位过程</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/IoC/1BeanDefinition%E7%9A%84%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 06 Mar 2024 12:11:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/IoC/1BeanDefinition%E7%9A%84%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E8%BF%87%E7%A8%8B/</guid>
      <description>前言 之前一直想系统的拜读一下 spring 的源码，看看它到底是如何吸引身边的大神们对它的设计赞不绝口，虽然每天工作很忙，每天下班后总感觉脑子内存溢出，想去放松一下，但总是以此为借口，恐怕会一直拖下去。所以每天下班虽然有些疲惫，但还是按住自己啃下这块硬骨头。 spring 源码这种东西真的是一回生二回熟，第</description>
    </item>
    <item>
      <title>Spring-Aop如何生效</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/AOP/Spring-Aop%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88/</link>
      <pubDate>Wed, 06 Mar 2024 12:10:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/AOP/Spring-Aop%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88/</guid>
      <description>Spring AOP 如何生效 Author: HuiFer 源码阅读仓库: SourceHot-Spring 解析 在使用 Spring AOP 技术的时候会有下面这段代码在 xml 配置文件中出现,来达到 Spring 支持 AOP 1 &amp;lt;aop:aspectj-autoproxy/&amp;gt; 源码阅读目标找到了,那么怎么去找入口或者对这句话的标签解析方法呢?项目中使用搜索 这样就找到了具体解析方法了 org.springframework.aop.config.AspectJAutoProxyBeanDefinitionParser 类图 1 2 3 4 5 6 7 8 9 @Override @Nullable public BeanDefinition parse(Element element, ParserContext parserContext) { // 注册 &amp;lt;aop:aspectj-autoproxy/&amp;gt; AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); // 子类解析</description>
    </item>
    <item>
      <title>JDK动态代理的实现原理解析</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/AOP/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 12:09:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/AOP/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</guid>
      <description>最近在看 Spring AOP 部分的源码，所以对 JDK 动态代理具体是如何实现的这件事产生了很高的兴趣，而且能从源码上了解这个原理的话，也有助于对 spring-aop 模块的理解。话不多说，上代码。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63</description>
    </item>
    <item>
      <title>AOP源码实现及分析</title>
      <link>https://geek.zshipu.com/post/code/docs/Spring/AOP/AOP%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 12:08:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Spring/AOP/AOP%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E5%8F%8A%E5%88%86%E6%9E%90/</guid>
      <description>理论性的文字，我觉得就没必要再扯一遍咯，大道理讲这么多，越听越迷糊。不如直接看源码加注释来的明白痛快。所以话不多说，直接上源码。 1 主要的接口 1.1 Advice 通知 本接口定义了切面的增强方式，如：前置增强 BeforeAdvice，后置增强 AfterAdvice，异常增强 ThrowsAdvice 等。下面看两个主要的子接</description>
    </item>
  </channel>
</rss>
