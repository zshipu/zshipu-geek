<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RocketMQ on 知识铺的博客</title>
    <link>https://geek.zshipu.com/tags/RocketMQ/</link>
    <description>Recent content in RocketMQ on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 15 Mar 2022 09:08:41 +0800</lastBuildDate>
    <atom:link href="https://geek.zshipu.com/tags/RocketMQ/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>消息中间件消息消费三消息消费重试</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B8%89%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95/</link>
      <pubDate>Tue, 15 Mar 2022 09:08:41 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B8%89%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95/</guid>
      <description>摘要：如果Consumer端消费消息失败，那么RocketMQ是如何对失败的异常情况进行处理？ 前面两篇RocketMQ消息消费（一）/（二）篇，主要从Push/Pull两种消费模式的简要流程、长轮询机制和Consumer端负载均衡这几点内容出发，介绍了RocketMQ消息消费的正</description>
    </item>
    <item>
      <title>消息中间件消息存储一</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E4%B8%80/</link>
      <pubDate>Tue, 15 Mar 2022 09:06:38 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E4%B8%80/</guid>
      <description>文章摘要：MQ分布式消息队列大致流程在于消息的一发一收一存，本篇将为大家主要介绍下RocketMQ存储部分的架构 消息存储是MQ消息队列中最为复杂和最为重要的一部分，所以小编也就放在RocketMQ系列篇幅中最后一部分来进行阐述和介绍。本文先从目前几种比较常用的MQ消息队列存储方式</description>
    </item>
    <item>
      <title>消息中间件的通信二</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E4%BA%8C/</link>
      <pubDate>Tue, 15 Mar 2022 09:06:30 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E4%BA%8C/</guid>
      <description>文章摘要：如何设计RPC通信层模型是任何一款性能强劲的MQ所要重点考虑的问题 在（一）篇中主要介绍了RocketMQ的协议格式，消息编解码，通信方式(同步/异步/单向)、消息发送/接收以及异步回调的主要通信流程。而本篇将主要对RocketMQ消息队列RPC通信部分的Netty多线程</description>
    </item>
    <item>
      <title>消息中间件消息发送</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</link>
      <pubDate>Tue, 15 Mar 2022 09:05:14 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</guid>
      <description>大道至简，消息队列可以简单概括为：“一发一存一收”，在这三个过程中消息发送最为简单，也比较容易入手，适合初中阶童鞋作为MQ研究和学习的切入点。因此，本篇主要从一条消息发送为切入点，详细阐述在RocketMQ这款分布式消息队列中发送一条普通消息的大致流程和细节。在阅读本篇之前希望读</description>
    </item>
    <item>
      <title>消息中间件的通信一</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%80/</link>
      <pubDate>Tue, 15 Mar 2022 09:02:29 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%80/</guid>
      <description>文章摘要：借用小厮的一句话“消息队列的本质在于消息的发送、存储和接收”。那么，对于一款消息队列来说，如何做到消息的高效发送与接收是重点和关键 一、RocketMQ中Remoting通信模块概览 RocketMQ消息队列的整体部署架构如下图所示： 先来说下RocketMQ消息队列集群中的</description>
    </item>
    <item>
      <title>消息中间件消息消费一</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B8%80/</link>
      <pubDate>Tue, 15 Mar 2022 08:59:36 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B8%80/</guid>
      <description>文章摘要：在发送消息给RocketMQ后，消费者需要消费。消息的消费比发送要复杂一些，那么RocketMQ是如何来做的呢？ 在RocketMQ系列文章的前面几篇幅中已经对其“RPC通信部分”和“普通消息发送”两部分进行了详细的阐述，本文将主要从消息消费为切入点简要地介绍下“Rock</description>
    </item>
    <item>
      <title>消息中间件消息消费二模式实现</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 14 Mar 2022 17:45:49 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</guid>
      <description>摘要：在RocketMQ中，消息消费都是基于Pull消息方式，那么Push模式中又是如何实现Consumer端准实时消费的呢？ 在上一篇—“消息中间件—RocketMQ消息消费（一）”中，已经简要地介绍了下RocketMQ中“Pull和Push两种消费方式的简要流程”以及“Push</description>
    </item>
    <item>
      <title>同程旅行网基于高可用架构实践</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E5%90%8C%E7%A8%8B%E6%97%85%E8%A1%8C%E7%BD%91%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 14 Mar 2022 17:32:56 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E5%90%8C%E7%A8%8B%E6%97%85%E8%A1%8C%E7%BD%91%E5%9F%BA%E4%BA%8E%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/</guid>
      <description>作者： 刘树东 背景介绍 为何选择 RocketMQ 我们在几年前决定引入 MQ 时，市场上已经有不少成熟的解决方案，比如 RabbitMQ , ActiveMQ，NSQ，Kafka 等。考虑到稳定性、维护成本、公司技术栈等因素，我们选择了 RocketMQ ： 纯 Java 开发，无依赖，使用简单，出现问题能 hold ； 经过阿里双十一考验，性能、稳定性可以保障； 功能</description>
    </item>
    <item>
      <title>消息中间件消息存储二</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E4%BA%8C/</link>
      <pubDate>Mon, 14 Mar 2022 17:32:43 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E4%BA%8C/</guid>
      <description>http://www.6aiq.com/article/1563128272857 http://www.6aiq.com/article/1563128435731 http://www.6aiq.com/article/1563129642050 http://www.6aiq.com/article/1563129820252 http://www.6aiq.com/article/1563130068940 http://www.6aiq.com/article/1563130337444 http://www.6aiq.com/article/1563130479801 RokcetMQ文件存储设计架构_v2.jpg 上面图中假设Consumer端默认设置的是同一个ConsumerGroup，因此Consumer端线程采用的是负载订阅的方式进行消费。从架构图中可以总结出如下几个关键点： （1） 消息生产与消息消费相互分离，Producer</description>
    </item>
    <item>
      <title>滴滴出行基于构建企业级消息队列服务的实践</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E5%9F%BA%E4%BA%8E%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 14 Mar 2022 16:42:25 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E5%9F%BA%E4%BA%8E%E6%9E%84%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%9E%E8%B7%B5/</guid>
      <description>作者： 江海挺 2018-11-20 本文整理自滴滴出行消息队列负责人 江海挺 在 Apache RocketMQ 开发者沙龙北京站的分享。 滴滴出行的消息技术选型 历史 初期，公司内部没有专门的团队维护消息队列服务，所以消息队列使用方式较多，主要以 Kafka 为主，有业务直连的，也有通过独立的服务转发消息的。另外有一些团队也会用 RocketMQ、Re</description>
    </item>
  </channel>
</rss>
