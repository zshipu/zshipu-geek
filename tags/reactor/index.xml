<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reactor on 知识铺的博客</title>
    <link>https://geek.zshipu.com/tags/reactor/</link>
    <description>Recent content in reactor on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 14 Mar 2022 17:24:56 +0800</lastBuildDate>
    <atom:link href="https://geek.zshipu.com/tags/reactor/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>架构服务端网络层架构</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 14 Mar 2022 17:24:56 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%9E%B6%E6%9E%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9E%B6%E6%9E%84/</guid>
      <description>1. Reactor 模式 Kafka 网络层采用的是Reactor模式，是一种基于事件驱动模式。对应于Java的NIO 提供了Reactor模式的API.常见的单线程Java NIO 的线程模型为 流程： 首先创建ServerSocketChannel 对象并在Selector 上注册OP_ACCEPT 事件，ServerSo</description>
    </item>
    <item>
      <title>深入剖析源码设计二模式到底干了啥</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/</link>
      <pubDate>Mon, 14 Mar 2022 16:49:02 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/</guid>
      <description>前言 周末向往常一样睡了一上午，惆怅了一个中午，下午学了会习，梳理了下Netty的线程模型是如何体现Reactor模式的。继上一篇对一些通信底层IO的C函数学习，这一篇主要是总结Java里对底层IO不同层次的抽象，每一层都为了解决什么问题？为什么Reator模型使得现在Netty处</description>
    </item>
  </channel>
</rss>
