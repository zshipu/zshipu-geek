<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrentCoding on 知识铺的博客</title>
    <link>https://geek.zshipu.com/tags/concurrentCoding/</link>
    <description>Recent content in concurrentCoding on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 06 Mar 2024 11:03:00 +0000</lastBuildDate>
    <atom:link href="https://geek.zshipu.com/tags/concurrentCoding/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>详解AbstractQueuedSynchronizer</title>
      <link>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/%E8%AF%A6%E8%A7%A3AbstractQueuedSynchronizer/</link>
      <pubDate>Wed, 06 Mar 2024 11:03:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/%E8%AF%A6%E8%A7%A3AbstractQueuedSynchronizer/</guid>
      <description>简介 AbstractQueuedSynchronizer 是 Doug Lea 大师创作的用来构建锁或者其他同步组件的基础框架类。J.U.C 中许多锁和并发工具类的核心实现都依赖于 AQS，如：ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch 等。 AQS 的源码中 方法很多，但主要做了三</description>
    </item>
    <item>
      <title>Semaphore</title>
      <link>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Semaphore/</link>
      <pubDate>Wed, 06 Mar 2024 11:02:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Semaphore/</guid>
      <description>Semaphore 信号量，可用于控制一定时间内，并发执行的线程数，基于 AQS 实现。可应用于网关限流、资源限制 (如 最大可发起连接数)。由于 release() 释放许可时，未对释放许可数做限制，所以可以通过该方法增加总的许可数量。 获取许可 支持公平和非公平模式，默认非公平模式。公平模式无论是否有许可，都会先判断是否有线程在</description>
    </item>
    <item>
      <title>Lock锁组件</title>
      <link>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Lock%E9%94%81%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:01:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Lock%E9%94%81%E7%BB%84%E4%BB%B6/</guid>
      <description>类图结构 J.U.C 的锁组件中 类相对较少，从 JDK 相应的包中也能看出来，下图标记了其中最主要的几个接口和类，也是本文要分析的重点。 下图 将这几个接口和类 以类图的方式展现出来，其中包含了它们所声明的主要方法。 Lock 组件 Lock 组件的结构很简单，只有一个接口和一个实现类，源码如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14</description>
    </item>
    <item>
      <title>JUC并发包UML全量类图</title>
      <link>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/JUC%E5%B9%B6%E5%8F%91%E5%8C%85UML%E5%85%A8%E9%87%8F%E7%B1%BB%E5%9B%BE/</link>
      <pubDate>Wed, 06 Mar 2024 11:00:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/JUC%E5%B9%B6%E5%8F%91%E5%8C%85UML%E5%85%A8%E9%87%8F%E7%B1%BB%E5%9B%BE/</guid>
      <description>利用 IDEA 整理类图还是蛮不错的，虽然这个功能 BUG 很多。下图是 J.U.C 并发包中所有类组成的类图，源码看多了 再去整理这个图，感觉还是很爽的。 根据功能，主要划分了六个部分，其中比较重要的是：线程池及其相关类、并发容器、AQS 与锁与同步工具类、原子类。图可能整理的不够细致，但看着这些类，回想一下其中</description>
    </item>
    <item>
      <title>Executor线程池组件</title>
      <link>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 10:59:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/JDK/concurrentCoding/Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%84%E4%BB%B6/</guid>
      <description>线程池核心组件图解 看源码之前，先了解一下该组件 最主要的几个 接口、抽象类和实现类的结构关系。 该组件中，Executor 和 ExecutorService 接口 定义了线程池最核心的几个方法，提交任务 submit ()、关闭线程池 shutdown()。抽象类 AbstractExecutorService 主要对公共行为 submit()系列方法进行了实现，这些 submit()</description>
    </item>
  </channel>
</rss>
