<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Netty on 知识铺的博客</title>
    <link>https://geek.zshipu.com/tags/Netty/</link>
    <description>Recent content in Netty on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 06 Mar 2024 12:02:00 +0000</lastBuildDate>
    <atom:link href="https://geek.zshipu.com/tags/Netty/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于Netty的服务端开发</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/%E5%9F%BA%E4%BA%8ENetty%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 06 Mar 2024 12:02:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/%E5%9F%BA%E4%BA%8ENetty%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/</guid>
      <description>Netty 服务端创建源码分析 当我们直接使用 JDK 的 NIO 类库 开发基于 NIO 的异步服务端时，需要用到 多路复用器 Selector、ServerSocketChannel、SocketChannel、ByteBuffer、SelectionKey 等，相比于传统的 BIO 开发，NIO 的开发要复杂很多，开发出稳定、</description>
    </item>
    <item>
      <title>基于Netty的客户端开发</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/%E5%9F%BA%E4%BA%8ENetty%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 06 Mar 2024 12:01:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/%E5%9F%BA%E4%BA%8ENetty%E5%BC%80%E5%8F%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%8A%E5%AE%A2%E6%88%B7%E7%AB%AF/%E5%9F%BA%E4%BA%8ENetty%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91/</guid>
      <description>相对于服务端，Netty 客户端 的创建更加复杂，除了要考虑线程模型、异步连接、客户端连接超时等因素外，还需要对连接过程中的各种异常进行考虑。本章将对 Netty 客户端 创建的关键流程和源码进行分析，以期读者能够了解客户端创建的细节。 基于 Netty 创建客户端的流程分析 Netty 为了向使用者屏蔽 NIO 通信 的底层细节，</description>
    </item>
    <item>
      <title>TCP粘拆包问题及Netty中的解决方案</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/TCP%E7%B2%98%E6%8B%86%E5%8C%85/TCP%E7%B2%98%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8ANetty%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Wed, 06 Mar 2024 12:00:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/TCP%E7%B2%98%E6%8B%86%E5%8C%85/TCP%E7%B2%98%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E5%8F%8ANetty%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>TCP 粘包/拆包 熟悉 TCP 编程的都知道，无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑 TCP 底层 的 粘包/拆包机制。TCP 粘包/拆包问题，在功能测试时往往不会怎么出现，而一旦并发压力上来，或者发送大报文之后，就很容易出现 粘包 / 拆包问题。如果代码没有考虑，往往就会出现解码错位或</description>
    </item>
    <item>
      <title>Java序列化缺点与主流编解码框架</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E7%BC%96%E8%A7%A3%E7%A0%81/Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%BC%BA%E7%82%B9%E4%B8%8E%E4%B8%BB%E6%B5%81%E7%BC%96%E8%A7%A3%E7%A0%81%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:59:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E7%BC%96%E8%A7%A3%E7%A0%81/Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%BC%BA%E7%82%B9%E4%B8%8E%E4%B8%BB%E6%B5%81%E7%BC%96%E8%A7%A3%E7%A0%81%E6%A1%86%E6%9E%B6/</guid>
      <description></description>
    </item>
    <item>
      <title>内存池之从内存池申请内存</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E6%B1%A0%E4%B9%8B%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 06 Mar 2024 11:58:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E6%B1%A0%E4%B9%8B%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98/</guid>
      <description>该文所涉及的 netty 源码版本为 4.1.16。 Netty 内存池申请内存流程 在通过 PooledByteBufAllocator 中向内存池中进行内存申请的时候，最先开始的步骤便是从 PooledByteBufAllocator 中一系列 PoolArena 数组中，选择其中一个 PoolArena 进行分配。 这时将会从 PoolArena 数组中选取当前使用量最小的 PoolArena 与当前线程通过 ThreadLocal 进行绑定，之后涉及到内存申请将会直接从这个 PoolArena 进行获取，这个做法</description>
    </item>
    <item>
      <title>内存池之PoolChunk设计与实现</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E6%B1%A0%E4%B9%8BPoolChunk%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Wed, 06 Mar 2024 11:57:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%86%85%E5%AD%98%E6%B1%A0%E4%B9%8BPoolChunk%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</guid>
      <description>该文所涉及的 netty 源码版本为 4.1.16。 在一开始需要明确的几个概念 在 Netty 的内存池的 PoolChunk 中，先要明确以下几个概念。 page: page 是 chunk 中所能申请到的最小内存单位。 chunk: 一个 chunk 是一组 page 的集合 在 PoolChunk 中，chunkSize 的大小是 2^maxOrder * pageSize，其中 2^maxOrder 是 PoolChunk 中的完全二叉树叶子结点的数量，pageSize 则是</description>
    </item>
    <item>
      <title>Recycler对象池原理分析</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 11:56:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Recycler%E5%AF%B9%E8%B1%A1%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>该文所涉及的 netty 源码版本为 4.1.6。 Netty 的对象池 Recycler 是什么 Recycler 是 Netty 中基于 ThreadLocal 的轻量化的对象池实现。既然是基于 ThreadLocal，那么就可以将其理解为当前线程在通过对象池 Recycler 得到一个对象之后，在回收对象的时候，不需要将其销毁，而是放回到该线程的对象池中即可，在该线程下一次用到该对象的时候</description>
    </item>
    <item>
      <title>MpscLinkedQueue队列原理分析</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MpscLinkedQueue%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 11:55:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/MpscLinkedQueue%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>该文所涉及的 netty 源码版本为 4.1.6。 MpscLinkedQueue 是什么 在 Netty 的核心中的核心成员 NioEventLoop 中，其中任务队列的实现 taskQueue 便是 MpscLinkedQueue。MpscLinkedQueue 是 Netty 所实现的一个基于多生产者单消费者的无锁队列，针对 NioEventLoop 中任务队列的特点，其单消费者的场景在一开始就避免了从队列中取数据时加</description>
    </item>
    <item>
      <title>HashedWheelTimer时间轮原理分析</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 11:54:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashedWheelTimer%E6%97%B6%E9%97%B4%E8%BD%AE%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid>
      <description>该文所涉及的 Netty 源码版本为 4.1.6。 HashedWheelTimer 是什么 Netty 的时间轮 HashedWheelTimer 给出了一个粗略的定时器实现，之所以称之为粗略的实现是因为该时间轮并没有严格的准时执行定时任务，而是在每隔一个时间间隔之后的时间节点执行，并执行当前时间节点之前到期的定时任务。 当然具体的定时任务的时间执行精度可以通过调节 HashedWheelTimer 构造</description>
    </item>
    <item>
      <title>HashedWheelTimer&amp;schedule</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashedWheelTimerschedule/</link>
      <pubDate>Wed, 06 Mar 2024 11:53:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/HashedWheelTimerschedule/</guid>
      <description>前言 前段时间在给自己的玩具项目设计的时候就遇到了一个场景需要定时任务，于是就趁机了解了目前主流的一些定时任务方案，比如下面这些： Timer（halo 博客源码中用到了） ScheduledExecutorService ThreadPoolTaskScheduler（基于 ScheduledExecutorService） Netty 的 sch</description>
    </item>
    <item>
      <title>FastThreadLocal源码分析</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/FastThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Wed, 06 Mar 2024 11:52:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/FastThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>Netty 的 FastThreadLocal 源码解析 该文中涉及到的 Netty 源码版本为 4.1.6。 Netty 的 FastThreadLocal 是什么 A special variant of ThreadLocal that yields higher access performance when accessed from a FastThreadLocalThread. Internally, a FastThreadLocal uses a constant index in an array, instead of using hash code and hash table, to look for a variable. Although seemingly very subtle, it yields slight performance advantage over using a hash table, and it is useful when accessed frequently. To take advantage of this thread-local variable, your thread must be a FastThreadLocalThread or its subtype. By default, all threads created by DefaultThreadFactory are FastThreadLocalThread due to this reason. Note that the fast path is only possible on threads that extend FastThreadLocalThread, because it requires a special field to</description>
    </item>
    <item>
      <title>ByteBuf的内存泄漏原因与检测原理</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ByteBuf%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0%E4%B8%8E%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 06 Mar 2024 11:51:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ByteBuf%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E5%9B%A0%E4%B8%8E%E6%A3%80%E6%B5%8B%E5%8E%9F%E7%90%86/</guid>
      <description>该文所涉及的 netty 源码版本为 4.1.6。 Netty 中的 ByteBuf 为什么会发生内存泄漏 在 Netty 中，ByetBuf 并不是只采用可达性分析来对 ByteBuf 底层的 byte[] 数组来进行垃圾回收，而同时采用引用计数法来进行回收，来保证堆外内存的准确时机的释放。 在每个 ByteBuf 中都维护着一个 refCnt 用来对 ByteBuf 的被引用数进行记录，当 ByteBuf 的 retain() 方法被调用时，</description>
    </item>
    <item>
      <title>基于自定义协议的Netty开发</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 06 Mar 2024 11:50:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</guid>
      <description>基于自定义协议的Netty开发 在某些情况下，我们需要基于TCP/IP协议栈开发自己的应用层协议，以满足特定的业务需求。在这篇博客中，我们将使用Netty开发一个基于自定义协议的客户端和服务器。 1. 环境准备 首先，我们需要在项目中引入Netty的依赖。在Maven项目中，添加以下依赖：</description>
    </item>
    <item>
      <title>基于WebSocket协议的Netty开发</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8EWebSocket%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 06 Mar 2024 11:49:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8EWebSocket%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</guid>
      <description>基于WebSocket协议的Netty开发 WebSocket是一种在单个TCP连接上进行全双工通信的协议。在这篇博客中，我们将使用Netty开发一个基于WebSocket协议的实时聊天系统。 1. 环境准备 首先，我们需要在项目中引入Netty的依赖。在Maven项目中，添加以下依赖： 1</description>
    </item>
    <item>
      <title>基于HTTP协议的Netty开发</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</link>
      <pubDate>Wed, 06 Mar 2024 11:48:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E5%A4%9A%E5%8D%8F%E8%AE%AE%E5%BC%80%E5%8F%91/%E5%9F%BA%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%E7%9A%84Netty%E5%BC%80%E5%8F%91/</guid>
      <description>基于HTTP协议的Netty开发 Netty是一个高性能、易于使用的NIO客户端服务器框架，用于快速开发可维护的高性能协议服务器和客户端程序。在这篇博客中，我们将使用Netty开发一个基本的HTTP服务器。 1. 环境准备 首先，我们需要在项目中引入Netty的依赖。在Maven项目中，添</description>
    </item>
    <item>
      <title>Future和Promise组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Future%E5%92%8CPromise%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:47:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Future%E5%92%8CPromise%E7%BB%84%E4%BB%B6/</guid>
      <description>Netty 中的 Future 和 Promise 组件是用于处理异步操作结果的两个接口。Future 表示一个异步操作的结果，它可以用于检查操作是否完成、获取操作结果、取消操作等。Promise 是 Future 的子接口，它可以用于设置操作结果、通知操作完成等。以下是 Netty 中 Future 和 Promise 组件的部分代码，并添加了中文注释： 1 2 3 4 5 6 7 8 9 10 11</description>
    </item>
    <item>
      <title>EventLoop组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventLoop%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:46:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/EventLoop%E7%BB%84%E4%BB%B6/</guid>
      <description>Netty 的线程模型 Netty 线程模型 的设计，也是基于 Reactor 模型，尽管不同的 NIO 框架 对于 Reactor 模式 的实现存在差异，但本质上还是遵循了 Reactor 的基础线程模型。 Reactor 单线程模型 Reactor 单线程模型，是指所有的 I/O 操作 都在同一个 NIO 线程 上完成。NIO 线程 的职责如下。 作为 NIO 服务端，接收客户端的 TCP 连接； 作为 NIO 客户端，向服务端发起 TCP 连接；</description>
    </item>
    <item>
      <title>Channel和Unsafe组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Channel%E5%92%8CUnsafe%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:45:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Channel%E5%92%8CUnsafe%E7%BB%84%E4%BB%B6/</guid>
      <description>类似于 java.nio 包 的 Channel，Netty 提供了自己的 Channel 和其子类实现，用于异步 I/O 操作 等。Unsafe 是 Channel 的内部接口，聚合在 Channel 中协助进行网络读写相关的操作，因为它的设计初衷就是 Channel 的内部辅助类，不应该被 Netty 框架 的上层使用者调用，所以被命名为 Unsafe。 Channel 组件 Netty 的 Channel 组件 是 Netty 对网络操作的封装</description>
    </item>
    <item>
      <title>ChannelPipeline和ChannelHandler组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ChannelPipeline%E5%92%8CChannelHandler%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:44:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ChannelPipeline%E5%92%8CChannelHandler%E7%BB%84%E4%BB%B6/</guid>
      <description>Netty 的 ChannelPipeline 和 ChannelHandler 机制类似于 Servlet 和 Filter 过滤器，这类拦截器实际上是职责链模式的一种变形，主要是为了方便事件的拦截和用户业务逻辑的定制。 Servlet Filter 能够以声明的方式（web.xml 配置文件）插入到 HTTP 请求响应的处理过程中，用于拦截请求和响应，以便能够查看、提取或以某种方式操作正在客户端和服务器之间交换的数</description>
    </item>
    <item>
      <title>ByteBuf组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ByteBuf%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:43:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/Netty%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/ByteBuf%E7%BB%84%E4%BB%B6/</guid>
      <description>Netty 中的 ByteBuf 组件是一个高性能的字节缓冲区，它可以用于网络通信、文件 IO 等场景。ByteBuf 的实现基于 Netty 的内存管理机制，可以有效地减少内存拷贝和内存分配的开销。以下是 Netty 中 ByteBuf 组件的部分代码，并添加了中文注释： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40</description>
    </item>
    <item>
      <title>详解selector、poll和epoll</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E8%AF%A6%E8%A7%A3selectorpoll%E5%92%8Cepoll/</link>
      <pubDate>Wed, 06 Mar 2024 11:42:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E8%AF%A6%E8%A7%A3selectorpoll%E5%92%8Cepoll/</guid>
      <description>Netty 是一个高性能、异步事件驱动的网络应用程序框架，它使用了 NIO 技术来提供高性能的网络通信。在 NIO 中，有三种常用的多路复用器（Multiplexor）：Selector、Poll 和 Epoll。这些多路复用器可以同时监听多个网络连接的 IO 事件，从而提高网络通信的效率。 Selector Selector 是 Java NIO 中的一种多路复</description>
    </item>
    <item>
      <title>把被说烂的BIO、NIO、AIO再从头到尾扯一遍</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E6%8A%8A%E8%A2%AB%E8%AF%B4%E7%83%82%E7%9A%84BIONIOAIO%E5%86%8D%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%AF%E4%B8%80%E9%81%8D/</link>
      <pubDate>Wed, 06 Mar 2024 11:41:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E6%8A%8A%E8%A2%AB%E8%AF%B4%E7%83%82%E7%9A%84BIONIOAIO%E5%86%8D%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%AF%E4%B8%80%E9%81%8D/</guid>
      <description>网上关于各种 IO 的博文已经多到飞起，如果你是大神，可以跳过我这个菜鸟的拙文，本博文没有什么特别 NB 的东西，只是集百家之长，并且以自己感到简单舒适的方式输出自己的理解，及学习过程中的经验。 IO 及基本概念 1、流的概念和作用 流：代表任何有能力产出数据的数据源对象或者是有能力接受数据的接收端对</description>
    </item>
    <item>
      <title>四种IO编程及对比</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E5%9B%9B%E7%A7%8DIO%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Wed, 06 Mar 2024 11:40:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/%E5%9B%9B%E7%A7%8DIO%E7%BC%96%E7%A8%8B%E5%8F%8A%E5%AF%B9%E6%AF%94/</guid>
      <description>传统的 BIO 编程 网络编程的基本模型是 Client/Server 模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息(绑定的 IP 地址和监听端口)，客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果连接建立成功，双方就可以通过网络套接字(Socket) 进行通信。 在基于传统同步阻塞</description>
    </item>
    <item>
      <title>Selector、SelectionKey及Channel组件</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/SelectorSelectionKey%E5%8F%8AChannel%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 06 Mar 2024 11:39:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/SelectorSelectionKey%E5%8F%8AChannel%E7%BB%84%E4%BB%B6/</guid>
      <description>Selector、SelectionKey 和 Channel 这三个组件构成了 Java nio 包的核心，也是 Reactor 模型在代码层面的体现。Selector 能让单线程同时处理多个客户端 Channel，非常适用于高并发，传输数据量较小的场景。要使用 Selector，首先要将对应的 Channel 及 IO 事件（读、写、连接）注册到 Sel</description>
    </item>
    <item>
      <title>IO模型</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/IO%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 06 Mar 2024 11:38:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/IOTechnologyBase/IO%E6%A8%A1%E5%9E%8B/</guid>
      <description>Linux 网络 IO 模型简介 Linux 的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个 fd (file descriptor，文件描述符)。而对一个 socket 的读写也会有相应的描述符，称为 socket fd (socket 描述符)，描述符就是一个数字，它指向内核中的一个结构体(文件路径，数据区等一些属</description>
    </item>
    <item>
      <title>Netty高性能之道</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/</link>
      <pubDate>Wed, 06 Mar 2024 11:37:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E9%AB%98%E6%80%A7%E8%83%BD%E4%B9%8B%E9%81%93/</guid>
      <description>作为一个高性能的 NIO 通信框架，Netty 被广泛应用于大数据处理、互联网消息中间件、游戏和金融行业等。大多数应用场景对底层的通信框架都有很高的性能要求，作为综合性能最高的 NIO 框架 之一，Netty 可以完全满足不同领域对高性能通信的需求。本章我们将从架构层对 Netty 的高性能设计和关键代码实现进行</description>
    </item>
    <item>
      <title>Netty高可靠性设计</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 06 Mar 2024 11:36:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E9%AB%98%E5%8F%AF%E9%9D%A0%E6%80%A7%E8%AE%BE%E8%AE%A1/</guid>
      <description>简介 Netty 是一个高性能的 NIO 客户端服务器框架，它用于快速开发可维护的高性能协议服务器和客户端程序，例如协议服务器、文件服务器、代理服务器等。Netty 在设计上强调了可扩展性、可复用性和高性能，是一个非常优秀的网络应用程序开发框架。 下面，我们将介绍 Netty 的一些高级特性和高可靠性设计。 高级特性</description>
    </item>
    <item>
      <title>Netty架构设计</title>
      <link>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Wed, 06 Mar 2024 11:35:00 +0000</pubDate>
      <guid>https://geek.zshipu.com/post/code/docs/Netty/AdvancedFeaturesOfNetty/Netty%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
      <description>本博文用于重点分析 Netty 的逻辑架构及关键的架构质量属性，希望有助于大家从 Netty 的架构设计中汲取营养，设计出高性能、高可靠 性和可扩展的程序。 Netty 的三层架构设计 Netty 采用了典型的三层网络架构进行设计和开发，其逻辑架构图如下所示。 通信调度层 Reactor 它由一系列辅助类完成，包括 Reactor 线程 NioEventLoop 及其父类，NioSock</description>
    </item>
    <item>
      <title>Netty那点事（八）理解Netty中的异步</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/detail/ch1-async-in-netty/</link>
      <pubDate>Sun, 01 May 2022 20:07:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/detail/ch1-async-in-netty/</guid>
      <description>理解Netty中的异步 首先，事件驱动的Handler机制本身就是异步的。其次，ChannelFuture为异步操作提供了同步的方式。与Future对应的还有ChannelListener。 Future可以理解为化异步为同步的一个方式。JDK里的Future就是如此。 异步的概念和同</description>
    </item>
    <item>
      <title>Netty那点事（七）层层分析Netty中的Channel(下)</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/trival-notes/</link>
      <pubDate>Sun, 01 May 2022 20:06:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/trival-notes/</guid>
      <description>层层分析Netty中的Channel(下) 上篇文章讲到了Netty的Channel内部的运作机制和生命周期。这篇文章会走进Netty处理的内部，结合NIO，讲讲Netty中是如何实现Reactor模式的。 上篇文章讲到了Netty的Channel内部的运作机制，这篇文章详细分析Ch</description>
    </item>
    <item>
      <title>Netty那点事（六）使用netty构建一个socks proxy</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/socks-proxy-by-netty/</link>
      <pubDate>Sun, 01 May 2022 20:05:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/socks-proxy-by-netty/</guid>
      <description>【netty实战】使用netty构建一个socks proxy 最近在做的项目，需要自己搭建一个socks代理。netty4.0附带了一个socks代理的样例，但是3.x就没有这个东西了，碰巧使用的又是3.7，就只能自己摸索并实现一遍，也算是对netty和socks协议的一个熟悉。 socks</description>
    </item>
    <item>
      <title>Netty那点事（五）讲讲Handler</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/</link>
      <pubDate>Sun, 01 May 2022 20:02:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/</guid>
      <description>Netty那点事（五）讲讲Handler 至上部分为止，我觉得Netty的架构部分已经差不多说完了，还有些细节，可以在实践中慢慢掌握。 但是对于实践来说，Netty还有不容忽视的一部分：Netty提供了大量的ChannelHandler，可以完成不同的任务。用好它们，会使Netty在</description>
    </item>
    <item>
      <title>Netty那点事（四）Netty与Reactor模式</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch4-reactor/</link>
      <pubDate>Sun, 01 May 2022 20:01:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch4-reactor/</guid>
      <description>Netty那点事（四）Netty与Reactor模式 一：Netty、NIO、多线程？ 时隔很久终于又更新了！之前一直迟迟未动也是因为积累不够，后面比较难下手。过年期间@李林锋hw发布了一个Netty5.0架构剖析和源码解读 http://vdisk.weibo.com/s/C9LV9</description>
    </item>
    <item>
      <title>Netty那点事（三）Channel中的Pipeline</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch3-pipeline/</link>
      <pubDate>Sun, 01 May 2022 19:57:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch3-pipeline/</guid>
      <description>Netty那点事（三）Channel中的Pipeline Channel是理解和使用Netty的核心。Channel的涉及内容较多，这里我使用由浅入深的介绍方法。在这篇文章中，我们主要介绍Channel部分中Pipeline实现机制。为了避免枯燥，借用一下《盗梦空间》的“梦境”概念</description>
    </item>
    <item>
      <title>Netty那点事（二）Netty中的buffer</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch2-buffer/</link>
      <pubDate>Sun, 01 May 2022 19:56:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch2-buffer/</guid>
      <description>Netty那点事（二）Netty中的buffer 上一篇文章我们概要介绍了Netty的原理及结构，下面几篇文章我们开始对Netty的各个模块进行比较详细的分析。Netty的结构最底层是buffer机制，这部分也相对独立，我们就先从buffer讲起。 What：buffer二三事 buf</description>
    </item>
    <item>
      <title>Netty那点事（一）概述</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch1-overview/</link>
      <pubDate>Sun, 01 May 2022 19:55:57 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch1-overview/</guid>
      <description>Netty那点事（一）概述 起：Netty是什么 大概用Netty的，无论新手还是老手，都知道它是一个“网络通讯框架”。所谓框架，基本上都是一个作用：基于底层API，提供更便捷的编程模型。那么&amp;quot;通讯框架&amp;quot;到底做了什么事情呢？回答这个问题并不太容易，我们不妨反过来看</description>
    </item>
    <item>
      <title>深入剖析源码设计一深入理解机制</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 15 Mar 2022 09:23:58 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%9C%BA%E5%88%B6/</guid>
      <description>前言 打算输出一系列 Netty 源码分析与实践的文章，也作为后端开发学习过程中的沉淀，此文章为第一篇，从操作系统底层的IO讲起，为 Netty 的出场做下知识准备。 一些概念 文件描述符 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现</description>
    </item>
    <item>
      <title>学习和进阶策略</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5/</link>
      <pubDate>Tue, 15 Mar 2022 08:54:33 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E5%AD%A6%E4%B9%A0%E5%92%8C%E8%BF%9B%E9%98%B6%E7%AD%96%E7%95%A5/</guid>
      <description>作者 | 李林锋 编辑 | 小智 《Netty 进阶之路》、《分布式服务框架原理与实践》作者李林锋手把手教你 Netty 框架如何学习和进阶。李林锋此后还将在 InfoQ 公众号上开设 Netty 专题持续出稿，感兴趣的同学可以持续关注。 背 景 Netty 框架的特点 Netty 的一个特点就是入门相对比较容易，但是真正掌握并精通是非常困难的，原因有如下</description>
    </item>
    <item>
      <title>深入剖析源码设计二模式到底干了啥</title>
      <link>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/</link>
      <pubDate>Mon, 14 Mar 2022 16:49:02 +0800</pubDate>
      <guid>https://geek.zshipu.com/post/%E4%BA%92%E8%81%94%E7%BD%91/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E4%BA%8C%E6%A8%A1%E5%BC%8F%E5%88%B0%E5%BA%95%E5%B9%B2%E4%BA%86%E5%95%A5/</guid>
      <description>前言 周末向往常一样睡了一上午，惆怅了一个中午，下午学了会习，梳理了下Netty的线程模型是如何体现Reactor模式的。继上一篇对一些通信底层IO的C函数学习，这一篇主要是总结Java里对底层IO不同层次的抽象，每一层都为了解决什么问题？为什么Reator模型使得现在Netty处</description>
    </item>
  </channel>
</rss>
