<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>让你更懂 JavaScript：Javascript 与 V8 | 知识铺的博客</title>
    <meta property="og:title" content="让你更懂 JavaScript：Javascript 与 V8 - 知识铺的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2022-03-14T23:22:10&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2022-03-14T23:22:10&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="让你更懂 JavaScript：Javascript 与 V8">
        <meta name="author" content="知识铺">
        
    <meta property="og:url" content="https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript09-Javascript-%E4%B8%8E-V8/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
    
    
    
    
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
    
</head>


<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://geek.zshipu.com/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://geek.zshipu.com/">首页</a>
                    
                    <a  href="https://geek.zshipu.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://geek.zshipu.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#9-1-一等公民的定义">9.1、一等公民的定义</a></li>
<li><a href="#9-2-动态作用域与静态作用域">9.2、动态作用域与静态作用域</a></li>
<li><a href="#9-3-闭包的三个基础特性">9.3、闭包的三个基础特性</a></li>
<li><a href="#9-4-惰性解析">9.4、惰性解析</a></li>
<li><a href="#9-5-预解析器">9.5、预解析器</a></li>
<li><a href="#9-6-v8-内部是如何存储对象的-快属性和慢属性">9.6、V8 内部是如何存储对象的：快属性和慢属性</a></li>
<li><a href="#9-7-堆空间和栈空间">9.7、堆空间和栈空间</a>
<ul>
<li><a href="#栈空间">栈空间</a></li>
<li><a href="#堆空间">堆空间</a></li>
</ul></li>
<li><a href="#9-8-继承">9.8、继承</a></li>
<li><a href="#9-9-构造函数是怎么创建对象的">9.9、构造函数是怎么创建对象的？</a></li>
<li><a href="#9-10-隐藏类和内联缓存">9.10、隐藏类和内联缓存</a>
<ul>
<li><a href="#将静态的特性引入到-v8">将静态的特性引入到 V8</a></li>
<li><a href="#通过-d8-查看隐藏类">通过 d8 查看隐藏类</a></li>
<li><a href="#多个对象共用一个隐藏">多个对象共用一个隐藏</a></li>
<li><a href="#重新构建隐藏类">重新构建隐藏类</a></li>
<li><a href="#最佳实践">最佳实践</a></li>
<li><a href="#通过内联缓存来提升函数执行效率">通过内联缓存来提升函数执行效率</a></li>
<li><a href="#内联缓存及其原理">内联缓存及其原理：</a></li>
<li><a href="#单态-多态和超态">单态、多态和超态：</a></li>
</ul></li>
<li><a href="#9-11-异步编程与消息队列">9.11、异步编程与消息队列</a>
<ul>
<li><a href="#1-v8-是如何执行回调函数的">1、V8 是如何执行回调函数的?</a></li>
<li><a href="#2-宏任务和微任务">2、宏任务和微任务</a></li>
<li><a href="#3-前端异步编程方案史">3、前端异步编程方案史</a></li>
</ul></li>
<li><a href="#9-12-垃圾回收">9.12、垃圾回收</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">让你更懂 JavaScript：Javascript 与 V8</h1>
        </header>
        <date class="post-meta meta-date">
            2022年3月14日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h3 id="9-1-一等公民的定义">9.1、一等公民的定义</h3>

<p>在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。</p>

<p>例如，字符串在几乎所有编程语言中都是一等公民，字符串可以做为函数参数，字符串可以作为函数返回值，字符串也可以赋值给变量。对于各种编程语言来说，函数就不一定是一等公民了，比如 Java 8 之前的版本。</p>

<p>对于 JavaScript 来说，函数可以赋值给变量，也可以作为函数参数，还可以作为函数返回值，因此 JavaScript 中函数是一等公民。</p>

<h3 id="9-2-动态作用域与静态作用域">9.2、动态作用域与静态作用域</h3>

<p>如果一门语言的作用域是静态作用域，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量。即静态作用域可以由程序代码决定，在编译时就能完全确定。大多数语言都是静态作用域的。</p>

<p>动态作用域（Dynamic Scope）。也就是说，变量引用跟变量声明不是在编译时就绑定死了的。在运行时，它是在运行环境中动态地找一个相同名称的变量。在 macOS 或 Linux 中用的 bash 脚本语言，就是动态作用域的。</p>

<h3 id="9-3-闭包的三个基础特性">9.3、闭包的三个基础特性</h3>

<ul>
<li>JavaScript 语言允许在函数内部定义新的函数</li>
<li>可以在内部函数中访问父函数中定义的变量</li>

<li><p>因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值</p>

<pre><code>// 闭包（静态作用域，一等公民，调用栈的矛盾体）
function foo() {
var d = 20;
return function inner(a, b) {
const c = a + b + d;
return c;
};
}
const f = foo();
</code></pre></li>
</ul>

<h3 id="9-4-惰性解析">9.4、惰性解析</h3>

<p>惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。</p>

<p>在编译 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：</p>

<ul>
<li>首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码很大，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；</li>
<li>其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存。</li>
</ul>

<p>基于以上的原因，所有主流的 JavaScript 虚拟机都实现了惰性解析。闭包给惰性解析带来的问题：上文的 d 不能随着 foo 函数的执行上下文被销毁掉。</p>

<h3 id="9-5-预解析器">9.5、预解析器</h3>

<p>V8 引入预解析器，比如当解析顶层代码的时候，遇到了一个函数，那么预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析。</p>

<ul>
<li>判断当前函数是不是存在一些语法上的错误，发现了语法错误，那么就会向 V8 抛出语法错误；</li>
<li>检查函数内部是否引用了外部变量，如果引用了外部的变量，预解析器会将栈中的变量复制到堆中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。</li>
</ul>

<h3 id="9-6-v8-内部是如何存储对象的-快属性和慢属性">9.6、V8 内部是如何存储对象的：快属性和慢属性</h3>

<p>下面的代码会输出什么：</p>

<pre><code>// test.js
function Foo() {
this[200] = 'test-200';
this[1] = 'test-1';
this[100] = 'test-100';
this['B'] = 'bar-B';
this[50] = 'test-50';
this[9] = 'test-9';
this[8] = 'test-8';
this[3] = 'test-3';
this[5] = 'test-5';
this['D'] = 'bar-D';
this['C'] = 'bar-C';
}
var bar = new Foo();

for (key in bar) {
console.log(`index:${key} value:${bar[key]}`);
}
//输出：
// index:1 value:test-1
// index:3 value:test-3
// index:5 value:test-5
// index:8 value:test-8
// index:9 value:test-9
// index:50 value:test-50
// index:100 value:test-100
// index:200 value:test-200
// index:B value:bar-B
// index:D value:bar-D
// index:C value:bar-C
</code></pre>

<p>在 ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。在这里我们把对象中的数字属性称为排序属性，在 V8 中被称为 elements，字符串属性就被称为常规属性，在 V8 中被称为 properties。在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。同时 v8 将部分常规属性直接存储到对象本身，我们把这称为对象内属性 (in-object properties)，不过对象内属性的数量是固定的，默认是 10 个。</p>

<pre><code>function Foo(property_num, element_num) {
//添加可索引属性
for (let i = 0; i &lt; element_num; i++) {
this[i] = `element${i}`;
}
//添加常规属性
for (let i = 0; i &lt; property_num; i++) {
let ppt = `property${i}`;
this[ppt] = ppt;
}
}
var bar = new Foo(10, 10);
</code></pre>

<p>可以通过 Chrome 开发者工具的 Memory 标签，捕获查看当前的内存快照。通过增大第一个参数来查看存储变化。（Console 面板运行以上代码，打开 Memory 面板，通过点击 Take heap snapshot 记录内存快照，点击快照，筛选出 Foo 进行查看。可参考使用 chrome-devtools Memory 面板了解 Memory 面板。）</p>

<p>我们将保存在线性数据结构中的属性称之为 “快属性”，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。因此，如果一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是“慢属性” 策略，但慢属性的对象内部会有独立的非线性数据结构 (字典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220318114311638.png" alt="image-20220318114311638" /></p>

<p>因为 JavaScript 中的对象是由一组组属性和值组成的，所以最简单的方式是使用一个字典来保存属性和值，但是由于字典是非线性结构，所以如果使用字典，读取效率会大大降低。为了提升查找效率，V8 在对象中添加了两个隐藏属性，排序属性和常规属性，element 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性。properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存常规属性。</p>

<p>通过引入这两个属性，加速了 V8 查找属性的速度，为了更加进一步提升查找效率，V8 还实现了内置内属性的策略，当常规属性少于一定数量时，V8 就会将这些常规属性直接写进对象中，这样又节省了一个中间步骤。</p>

<p>但是如果对象中的属性过多时，或者存在反复添加或者删除属性的操作，那么 V8 就会将线性的存储模式降级为非线性的字典存储模式，这样虽然降低了查找速度，但是却提升了修改对象的属性的速度。</p>

<h3 id="9-7-堆空间和栈空间">9.7、堆空间和栈空间</h3>

<h4 id="栈空间">栈空间</h4>

<p>现代语言都是基于函数的，每个函数在执行过程中，都有自己的生命周期和作用域，当函数执行结束时，其作用域也会被销毁，因此，我们会使用栈这种数据结构来管理函数的调用过程，我们也把管理函数调用过程的栈结构称之为调用栈。</p>

<p>栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是 “先进后出” 的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。</p>

<p>栈空间的最大的特点是空间连续，所以在栈中每个元素的地址都是固定的，因此栈空间的查找效率非常高，但是通常在内存中，很难分配到一块很大的连续空间，因此，V8 对栈空间的大小做了限制，如果函数调用层过深，那么 V8 就有可能抛出栈溢出的错误。</p>

<pre><code>// 栈溢出
function factorial(n) {
if (n === 1) {
return 1;
}
return n \* factorial(n - 1);
}
console.log(factorial(50000));
</code></pre>

<p>栈的优势和缺点：</p>

<ul>
<li>栈的结构非常适合函数调用过程。</li>
<li>在栈上分配资源和销毁资源的速度非常快，这主要归结于栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了。</li>
<li>虽然操作速度非常快，但是栈也是有缺点的，其中最大的缺点也是它的优点所造成的，那就是栈是连续的，所以要想在内存中分配一块连续的大空间是非常难的，因此栈空间是有限的。</li>
</ul>

<h4 id="堆空间">堆空间</h4>

<p>堆空间是一种树形的存储结构，用来存储对象类型的离散的数据，JavaScript 中除了原生类型的数据，其他的都是对象类型，诸如函数、数组，在浏览器中还有 window 对象、document 对象等，这些都是存在堆空间的。</p>

<p>宿主在启动 V8 的过程中，会同时创建堆空间和栈空间，再继续往下执行，产生的新数据都会存放在这两个空间中。</p>

<h3 id="9-8-继承">9.8、继承</h3>

<p>继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性</p>

<p>javaScript 的每个对象都包含了一个隐藏属性 <strong>proto</strong> ，我们就把该隐藏属性 <strong>proto</strong> 称之为该对象的原型 (prototype)，<strong>proto</strong> 指向了内存中的另外一个对象，我们就把 <strong>proto</strong> 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。</p>

<p>JavaScript 中的继承非常简洁，就是每个对象都有一个原型属性，该属性指向了原型对象，查找属性的时候，JavaScript 虚拟机会沿着原型一层一层向上查找，直至找到正确的属性。</p>

<pre><code>var animal = {
type: 'Default',
color: 'Default',
getInfo: function () {
return `Type is: ${this.type}，color is ${this.color}.`;
},
};
var dog = {
type: 'Dog',
color: 'Black',
};
</code></pre>

<p>利用 <strong>proto</strong> 实现继承：</p>

<pre><code>dog.**proto** = animal;
dog.getInfo();
</code></pre>

<p>通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 <strong>proto</strong>，但是在实际项目中，我们不应该直接通过 <strong>proto</strong> 来访问或者修改该属性，其主要原因有两个：</p>

<ul>
<li>首先，这是隐藏属性，并不是标准定义的;</li>
<li>其次，使用该属性会造成严重的性能问题。因为 JavaScript 通过隐藏类优化了很多原有的对象结构，所以通过直接修改 <strong>proto</strong> 会直接破坏现有已经优化的结构，触发 V8 重构该对象的隐藏类！</li>
</ul>

<h3 id="9-9-构造函数是怎么创建对象的">9.9、构造函数是怎么创建对象的？</h3>

<p>在 JavaScript 中，使用 new 加上构造函数的这种组合来创建对象和实现对象的继承。不过使用这种方式隐含的语义过于隐晦。其实是 JavaScript 为了吸引 Java 程序员、在语法层面去蹭 Java 热点，所以就被硬生生地强制加入了非常不协调的关键字 new。</p>

<pre><code>function DogFactory(type, color) {
this.type = type;
this.color = color;
}
var dog = new DogFactory('Dog', 'Black');
</code></pre>

<p>其实当 V8 执行上面这段代码时，V8 在背后悄悄地做了以下几件事情：</p>

<pre><code>var dog = {};
dog.**proto** = DogFactory.prototype;
DogFactory.call(dog, 'Dog', 'Black');
</code></pre>

<h3 id="9-10-隐藏类和内联缓存">9.10、隐藏类和内联缓存</h3>

<p>JavaScript 是一门动态语言，其执行效率要低于静态语言，V8 为了提升 JavaScript 的执行速度，借鉴了很多静态语言的特性，比如实现了 JIT 机制，为了提升对象的属性访问速度而引入了隐藏类，为了加速运算而引入了内联缓存。</p>

<p>为什么静态语言的效率更高?</p>

<p>静态语言中，如 C++ 在声明一个对象之前需要定义该对象的结构，代码在执行之前需要先被编译，编译的时候，每个对象的形状都是固定的，也就是说，在代码的执行过程中是无法被改变的。可以直接通过偏移量查询来查询对象的属性值，这也就是静态语言的执行效率高的一个原因。</p>

<p>JavaScript 在运行时，对象的属性是可以被修改的，所以当 V8 使用了一个对象时，比如使用了 obj.x 的时候，它并不知道该对象中是否有 x，也不知道 x 相对于对象的偏移量是多少，也就是说 V8 并不知道该对象的具体的形状。那么，当在 JavaScript 中要查询对象 obj 中的 x 属性时，V8 会按照具体的规则一步一步来查询，这个过程非常的慢且耗时。</p>

<h4 id="将静态的特性引入到-v8">将静态的特性引入到 V8</h4>

<p>V8 采用的一个思路就是将 JavaScript 中的对象静态化，也就是 V8 在运行 JavaScript 的过程中，会假设 JavaScript 中的对象是静态的。</p>

<p>具体地讲，V8 对每个对象做如下两点假设：</p>

<ul>
<li>对象创建好了之后就不会添加新的属性；</li>
<li>对象创建好了之后也不会删除属性。 符合这两个假设之后，V8 就可以对 JavaScript 中的对象做深度优化了。V8 会为每个对象创建一个隐藏类，对象的隐藏类中记录了该对象一些基础的布局信息，包括以下两点：</li>
<li>对象中所包含的所有的属性；</li>
<li>每个属性相对于对象的偏移量。 有了隐藏类之后，那么当 V8 访问某个对象中的某个属性时，就会先去隐藏类中查找该属性相对于它的对象的偏移量，有了偏移量和属性类型，V8 就可以直接去内存中取出对应的属性值，而不需要经历一系列的查找过程，那么这就大大提升了 V8 查找对象的效率。</li>
</ul>

<p>在 V8 中，把隐藏类又称为 map，每个对象都有一个 map 属性，其值指向内存中的隐藏类；</p>

<p>map 描述了对象的内存布局，比如对象都包括了哪些属性，这些数据对应于对象的偏移量是多少。</p>

<h4 id="通过-d8-查看隐藏类">通过 d8 查看隐藏类</h4>

<pre><code>// test.js
let point1 = { x: 100, y: 200 };
let point2 = { x: 200, y: 300 };
let point3 = { x: 100 };
%DebugPrint(point1);
%DebugPrint(point2);
%DebugPrint(point3);

./d8 --allow-natives-syntax ./test.js

# ===============

DebugPrint: 0x1ea3080c5bc5: [JS_OBJECT_TYPE]

# V8 为 point1 对象创建的隐藏类

- map: 0x1ea308284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
- properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
  #x: 100 (const data field 0)
  #y: 200 (const data field 1)
  }
  0x1ea308284ce9: [Map]
- type: JS_OBJECT_TYPE
- instance size: 20
- inobject properties: 2
- elements kind: HOLEY_ELEMENTS
- unused property fields: 0
- enum length: invalid
- stable_map
- back pointer: 0x1ea308284cc1 &lt;Map(HOLEY_ELEMENTS)&gt;
- prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
- instance descriptors (own) #2: 0x1ea3080c5bf5 &lt;DescriptorArray[2]&gt;
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
- dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
- construction counter: 0

# ===============

DebugPrint: 0x1ea3080c5c1d: [JS_OBJECT_TYPE]

# V8 为 point2 对象创建的隐藏类

- map: 0x1ea308284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
- properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
  #x: 200 (const data field 0)
  #y: 300 (const data field 1)
  }
  0x1ea308284ce9: [Map]
- type: JS_OBJECT_TYPE
- instance size: 20
- inobject properties: 2
- elements kind: HOLEY_ELEMENTS
- unused property fields: 0
- enum length: invalid
- stable_map
- back pointer: 0x1ea308284cc1 &lt;Map(HOLEY_ELEMENTS)&gt;
- prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
- instance descriptors (own) #2: 0x1ea3080c5bf5 &lt;DescriptorArray[2]&gt;
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
- dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
- construction counter: 0

# ===============

DebugPrint: 0x1ea3080c5c31: [JS_OBJECT_TYPE]

# V8 为 point3 对象创建的隐藏类

- map: 0x1ea308284d39 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- elements: 0x1ea3080406e9 &lt;FixedArray[0]&gt; [HOLEY_ELEMENTS]
- properties: 0x1ea3080406e9 &lt;FixedArray[0]&gt; {
  #x: 100 (const data field 0)
  }
  0x1ea308284d39: [Map]
- type: JS_OBJECT_TYPE
- instance size: 16
- inobject properties: 1
- elements kind: HOLEY_ELEMENTS
- unused property fields: 0
- enum length: invalid
- stable_map
- back pointer: 0x1ea308284d11 &lt;Map(HOLEY_ELEMENTS)&gt;
- prototype_validity cell: 0x1ea3081c0451 &lt;Cell value= 1&gt;
- instance descriptors (own) #1: 0x1ea3080c5c41 &lt;DescriptorArray[1]&gt;
- prototype: 0x1ea308241395 &lt;Object map = 0x1ea3082801c1&gt;
- constructor: 0x1ea3082413b1 &lt;JSFunction Object (sfi = 0x1ea3081c557d)&gt;
- dependent code: 0x1ea3080401ed &lt;Other heap object (WEAK_FIXED_ARRAY_TYPE)&gt;
- construction counter: 0
</code></pre>

<h4 id="多个对象共用一个隐藏">多个对象共用一个隐藏</h4>

<p>在 V8 中，每个对象都有一个 map 属性，该属性值指向该对象的隐藏类。不过如果两个对象的形状是相同的，V8 就会为其复用同一个隐藏类，这样有两个好处：</p>

<ul>
<li>减少隐藏类的创建次数，也间接加速了代码的执行速度；</li>
<li>减少了隐藏类的存储空间。 那么，什么情况下两个对象的形状是相同的，要满足以下两点：</li>
<li>相同的属性名称；</li>
<li>相等的属性个数。</li>
</ul>

<h4 id="重新构建隐藏类">重新构建隐藏类</h4>

<p>给一个对象添加新的属性，删除新的属性，或者改变某个属性的数据类型都会改变这个对象的形状，那么势必也就会触发 V8 为改变形状后的对象重建新的隐藏类。</p>

<pre><code>// test.js
let point = {};
%DebugPrint(point);
point.x = 100;
%DebugPrint(point);
point.y = 200;
%DebugPrint(point);

# ./d8 --allow-natives-syntax ./test.js

DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]

- map: 0x32c7082802d9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
  ...

DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]

- map: 0x32c708284cc1 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
  ...

DebugPrint: 0x32c7080c5b2d: [JS_OBJECT_TYPE]

- map: 0x32c708284ce9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]
  ...
  每次给对象添加了一个新属性之后，该对象的隐藏类的地址都会改变，这也就意味着隐藏类也随着改变了；如果删除对象的某个属性，那么对象的形状也就随着发生了改变，这时 V8 也会重建该对象的隐藏类；
</code></pre>

<h4 id="最佳实践">最佳实践</h4>

<ul>
<li>使用字面量初始化对象时，要保证属性的顺序是一致的；</li>
<li>尽量使用字面量一次性初始化完整对象属性；</li>
<li>尽量避免使用 delete 方法。</li>
</ul>

<h4 id="通过内联缓存来提升函数执行效率">通过内联缓存来提升函数执行效率</h4>

<p>虽然隐藏类能够加速查找对象的速度，但是在 V8 查找对象属性值的过程中，依然有查找对象的隐藏类和根据隐藏类来查找对象属性值的过程。如果一个函数中利用了对象的属性，并且这个函数会被多次执行</p>

<pre><code>function loadX(obj) {
return obj.x;
}
var obj = { x: 1, y: 3 };
var obj1 = { x: 3, y: 6 };
var obj2 = { x: 3, y: 6, z: 8 };
for (var i = 0; i &lt; 100; i++) {
// 对比时间差异
console.time(`---${i}----`)
loadX(obj);
console.timeEnd(`---${i}----`)
loadX(obj1);
// 产生多态
loadX(obj2);
}
</code></pre>

<p>通常 V8 获取 obj.x 的流程：</p>

<ul>
<li>找对象 obj 的隐藏类；</li>
<li>再通过隐藏类查找 x 属性偏移量；</li>
<li>然后根据偏移量获取属性值，在这段代码中 loadX 函数会被反复执行，那么获取 obj.x 的流程也需要反复被执行；</li>
</ul>

<h4 id="内联缓存及其原理">内联缓存及其原理：</h4>

<ul>
<li>函数 loadX 在一个 for 循环里面被重复执行了很多次，因此 V8 会想尽一切办法来压缩这个查找过程，以提升对象的查找效率。这个加速函数执行的策略就是内联缓存 (Inline Cache)，简称为 IC；</li>
<li>IC 的原理：在 V8 执行函数的过程中，会观察函数中一些调用点 (CallSite) 上的关键中间数据，然后将这些数据缓存起来，当下次再次执行该函数的时候，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程，因此 V8 利用 IC，可以有效提升一些重复代码的执行效率。</li>
<li>IC 会为每个函数维护一个反馈向量 (FeedBack Vector)，反馈向量记录了函数在执行过程中的一些关键的中间数据。</li>
<li>反馈向量其实就是一个表结构，它由很多项组成的，每一项称为一个插槽 (Slot)，V8 会依次将执行 loadX 函数的中间数据写入到反馈向量的插槽中。</li>
<li>当 V8 再次调用 loadX 函数时，比如执行到 loadX 函数中的 return obj.x 语句时，它就会在对应的插槽中查找 x 属性的偏移量，之后 V8 就能直接去内存中获取 obj.x 的属性值了。这样就大大提升了 V8 的执行效率。</li>
</ul>

<h4 id="单态-多态和超态">单态、多态和超态：</h4>

<ul>
<li>如果一个插槽中只包含 1 个隐藏类，那么我们称这种状态为单态 (monomorphic)；</li>
<li>如果一个插槽中包含了 2 ～ 4 个隐藏类，那我们称这种状态为多态 (polymorphic)；</li>
<li>如果一个插槽中超过 4 个隐藏类，那我们称这种状态为超态 (magamorphic)。</li>
<li>单态的性能优于多态和超态，所以我们需要稍微避免多态和超态的情况。要避免多态和超态，那么就尽量默认所有的对象属性是不变的，比如你写了一个 loadX(obj) 的函数，那么当传递参数时，尽量不要使用多个不同形状的 obj 对象。</li>
</ul>

<p>V8 引入了内联缓存（IC），IC 会监听每个函数的执行过程，并在一些关键的地方埋下监听点，这些包括了加载对象属性 (Load)、给对象属性赋值 (Store)、还有函数调用 (Call)，V8 会将监听到的数据写入一个称为反馈向量 (FeedBack Vector) 的结构中，同时 V8 会为每个执行的函数维护一个反馈向量。有了反馈向量缓存的临时数据，V8 就可以缩短对象属性的查找路径，从而提升执行效率。但是针对函数中的同一段代码，如果对象的隐藏类是不同的，那么反馈向量也会记录这些不同的隐藏类，这就出现了多态和超态的情况。我们在实际项目中，要尽量避免出现多态或者超态的情况。</p>

<h3 id="9-11-异步编程与消息队列">9.11、异步编程与消息队列</h3>

<h4 id="1-v8-是如何执行回调函数的">1、V8 是如何执行回调函数的?</h4>

<p>回调函数有两种类型：同步回调和异步回调，同步回调函数是在执行函数内部被执行的，而异步回调函数是在执行函数外部被执行的。通用 UI 线程宏观架构：</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220318114352004.png" alt="image-20220318114352004" /></p>

<p>UI 线程提供一个消息队列，并将待执行的事件添加到消息队列中，然后 UI 线程会不断循环地从消息队列中取出事件、执行事件。关于异步回调，这里也有两种不同的类型，其典型代表是 setTimeout 和 XMLHttpRequest：</p>

<ul>
<li>setTimeout 的执行流程其实是比较简单的，在 setTimeout 函数内部封装回调消息，并将回调消息添加进消息队列，然后主线程从消息队列中取出回调事件，并执行回调函数。</li>
<li>XMLHttpRequest 稍微复杂一点，因为下载过程需要放到单独的一个线程中去执行，所以执行 XMLHttpRequest.send 的时候，宿主会将实际请求转发给网络线程，然后 send 函数退出，主线程继续执行下面的任务。网络线程在执行下载的过程中，会将一些中间信息和回调函数封装成新的消息，并将其添加进消息队列中，然后主线程从消息队列中取出回调事件，并执行回调函数。</li>
</ul>

<h4 id="2-宏任务和微任务">2、宏任务和微任务</h4>

<p>「调用栈」：调用栈是一种数据结构，用来管理在主线程上执行的函数的调用关系。主线程在执行任务的过程中，如果函数的调用层次过深，可能造成栈溢出的错误，我们可以使用 setTimeout 来解决栈溢出的问题。setTimeout 的本质是将同步函数调用改成异步函数调用，这里的异步调用是将回调函数封装成宏任务，并将其添加进消息队列中，然后主线程再按照一定规则循环地从消息队列中读取下一个宏任务。</p>

<p>「宏任务」：就是指消息队列中的等待被主线程执行的事件。每个宏任务在执行时，V8 都会重新创建栈，然后随着宏任务中函数调用，栈也随之变化，最终，当该宏任务执行结束时，整个栈又会被清空，接着主线程继续执行下一个宏任务。</p>

<p>「微任务」：你可以把微任务看成是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>

<p>JavaScript 中之所以要引入微任务，主要是由于主线程执行消息队列中宏任务的时间颗粒度太粗了，无法胜任一些对精度和实时性要求较高的场景，微任务可以在实时性和效率之间做一个有效的权衡。另外使用微任务，可以改变我们现在的异步编程模型，使得我们可以使用同步形式的代码来编写异步调用。</p>

<p>微任务是基于消息队列、事件循环、UI 主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async 等现代前端经常使用的一些技术。</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220318114413645.png" alt="image-20220318114115429" /></p>

<pre><code>// 不会使浏览器卡死
function foo() {
setTimeout(foo, 0);
}
foo();
</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220318114427333.png" alt="image-20220318114427333" /></p>

<p>微任务</p>

<pre><code>// 浏览器 console 控制台可使浏览器卡死（无法响应鼠标事件等）
function foo() {
return Promise.resolve().then(foo);
}
foo();
</code></pre>

<p>如果当前的任务中产生了一个微任务，通过 Promise.resolve() 或者 Promise.reject() 都会触发微任务，触发的微任务不会在当前的函数中被执行，所以执行微任务时，不会导致栈的无限扩张</p>

<p>和异步调用不同，微任务依然会在当前任务执行结束之前被执行，这也就意味着在当前微任务执行结束之前，消息队列中的其他任务是不可能被执行的。因此在函数内部触发的微任务，一定比在函数内部触发的宏任务要优先执行。</p>

<p>微任务依然是在当前的任务中执行的，所以如果在微任务中循环触发新的微任务，那么将导致消息队列中的其他任务没有机会被执行。</p>

<h4 id="3-前端异步编程方案史">3、前端异步编程方案史</h4>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220318114440505.png" alt="image-20220318114440505" /></p>

<p>Callback 模式的异步编程模型需要实现大量的回调函数，大量的回调函数会打乱代码的正常逻辑，使得代码变得不线性、不易阅读，这就是我们所说的回调地狱问题。</p>

<p>Promise 能很好地解决回调地狱的问题，我们可以按照线性的思路来编写代码，这个过程是线性的，非常符合人的直觉。</p>

<p>但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着大量的 then，语义化不明显，代码不能很好地表示执行流程。我们想要通过线性的方式来编写异步代码，要实现这个理想，最关键的是要能实现函数暂停和恢复执行的功能。而生成器就可以实现函数暂停和恢复，我们可以在生成器中使用同步代码的逻辑来异步代码 (实现该逻辑的核心是协程)。</p>

<p>但是在生成器之外，我们还需要一个触发器来驱动生成器的执行。前端的最终方案就是 async/await，async 是一个可以暂停和恢复执行的函数，在 async 函数内部使用 await 来暂停 async 函数的执行，await 等待的是一个 Promise 对象，如果 Promise 的状态变成 resolve 或者 reject，那么 async 函数会恢复执行。因此，使用 async/await 可以实现以同步的方式编写异步代码这一目标。和生成器函数一样，使用了 async 声明的函数在执行时，也是一个单独的协程，我们可以使用 await 来暂停该协程，由于 await 等待的是一个 Promise 对象，我们可以 resolve 来恢复该协程</p>

<p>协程 是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程。比如，当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。</p>

<p>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。每一时刻，该线程只能执行其中某一个协程。最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。参考：co 函数库的含义和用法</p>

<h3 id="9-12-垃圾回收">9.12、垃圾回收</h3>

<p>1、垃圾数据</p>

<p>从 GC Roots 对象出发，遍历 GC Root 中的所有对象，如果通过 GC Roots 没有遍历到的对象，则这些对象便是垃圾数据。V8 会有专门的垃圾回收器来回收这些垃圾数据。</p>

<p>2、垃圾回收算法</p>

<p>垃圾回收大致可以分为以下几个步骤：</p>

<p>第一步，通过 GC Root 标记空间中活动对象和非活动对象。目前 V8 采用的可访问性（reachability）算法来判断堆中的对象是否是活动对象。具体地讲，这个算法是将一些 GC Root 作为初始存活的对象的集合，从 GC Roots 对象出发，遍历 GC Root 中的所有对象：</p>

<p>通过 GC Root 遍历到的对象，我们就认为该对象是可访问的（reachable），那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象；</p>

<p>通过 GC Roots 没有遍历到的对象，则是不可访问的（unreachable），那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。</p>

<p>在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)： 全局的 window 对象（位于每个 iframe 中）； 文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成； 存放栈上变量。</p>

<p>第二步，回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>

<p>第三步，做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大的连续内存时，就有可能出现内存不足的情况，所以最后一步需要整理这些内存碎片。但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片 (比如副垃圾回收器)。</p>

<p>3、垃圾回收</p>

<p>V8 依据代际假说，将堆内存划分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放生存时间久的对象。代际假说有两个特点：</p>

<p>第一个是大部分对象都是 “朝生夕死” 的，也就是说大部分对象在内存中存活的时间很短，比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问； 第二个是不死的对象，会活得更久，比如全局的 window、DOM、Web API 等对象。 为了提升垃圾回收的效率，V8 设置了两个垃圾回收器，主垃圾回收器和副垃圾回收器。</p>

<p>主垃圾回收器负责收集老生代中的垃圾数据，副垃圾回收器负责收集新生代中的垃圾数据。 副垃圾回收器采用了 Scavenge 算法，是把新生代空间对半划分为两个区域（有些地方也称作 From 和 To 空间），一半是对象区域，一半是空闲区域。新的数据都分配在对象区域，等待对象区域快分配满的时候，垃圾回收器便执行垃圾回收操作，之后将存活的对象从对象区域拷贝到空闲区域，并将两个区域互换。 这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。 副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。 副垃圾回收器还会采用对象晋升策略，也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。 主垃圾回收器回收器主要负责老生代中的垃圾数据的回收操作，会经历标记、清除和整理过程。 主垃圾回收器主要负责老生代中的垃圾回收。除了新生代中晋升的对象，一些大的对象会直接被分配到老生代里。 老生代中的对象有两个特点：一个是对象占用空间大；另一个是对象存活时间长。 4、Stop-The-World</p>

<p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。 V8 最开始的垃圾回收器有两个特点：</p>

<p>第一个是垃圾回收在主线程上执行， 第二个特点是一次执行一个完整的垃圾回收流程。 由于这两个原因，很容易造成主线程卡顿，所以 V8 采用了很多优化执行效率的方案。</p>

<p>第一个方案是并行回收，在执行一个完整的垃圾回收过程中，垃圾回收器会使用多个辅助线程来并行执行垃圾回收。 第二个方案是增量式垃圾回收，垃圾回收器将标记工作分解为更小的块，并且穿插在主线程不同的任务之间执行。采用增量垃圾回收时，垃圾回收器没有必要一次执行完整的垃圾回收过程，每次执行的只是整个垃圾回收过程中的一小部分工作。 第三个方案是并发回收，回收线程在执行 JavaScript 的过程，辅助线程能够在后台完成的执行垃圾回收的操作。 资料参考：深入解读 V8 引擎的「并发标记」技术</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://geek.zshipu.com/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript09-Javascript-%E4%B8%8E-V8/">https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript09-Javascript-%E4%B8%8E-V8/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript08-V8-%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84/">让你更懂 JavaScript：08 V8 是怎么执行一段 JavaScript 代码的</a></li>
        
        <li><a href="/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript07-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB/">让你更懂 JavaScript：07 解释执行和编译执行区别</a></li>
        
        <li><a href="/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript06-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/">让你更懂 JavaScript：V8 引擎的内部结构</a></li>
        
        <li><a href="/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript05-%E4%BB%80%E4%B9%88%E6%98%AF-V8/">让你更懂 JavaScript：05 什么是 V8</a></li>
        
        <li><a href="/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript04-%E4%BB%80%E4%B9%88%E6%98%AF-D8/">让你更懂 JavaScript：04 什么是 D8</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/JavaScript'>JavaScript</a></li>
                
                <li><a href='/tags/JS'>JS</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-geek"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://geek.zshipu.com/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://geek.zshipu.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://geek.zshipu.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://geek.zshipu.com/post/React-%E5%88%9D%E5%AD%A6%E8%80%85-JSX-%E7%AE%80%E4%BB%8B-%E5%9B%9B/" title="React 初学者： JSX 简介 四">React 初学者： JSX 简介 四</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%AD%A6%E4%B9%A0-ReactJS-%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84-5-%E5%A4%A7%E6%8A%80%E8%83%BD-%E4%B8%89/" title="React 初学者： 学习 ReactJS 之前必须了解的 5 大技能 三">React 初学者： 学习 ReactJS 之前必须了解的 5 大技能 三</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0-ReactJS-%E4%BA%8C/" title="React 初学者： 如何学习 ReactJS 二">React 初学者： 如何学习 ReactJS 二</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-React-%E5%BA%94%E7%94%A8-%E4%B8%80/" title="React 初学者： 创建新的 React 应用 一">React 初学者： 创建新的 React 应用 一</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/go/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E7%9A%84GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" title="深入理解Go的GC回收机制">深入理解Go的GC回收机制</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/nextjs/%E5%A6%82%E4%BD%95%E4%B8%BA%E6%82%A8%E7%9A%84Next.js%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%B6%E6%9E%84/" title="起步：如何为您的Next.js项目构建可扩展的架构">起步：如何为您的Next.js项目构建可扩展的架构</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9820-%E6%80%BB%E7%BB%93%E4%BA%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A110%E9%97%AE/" title="DDD实战：20 总结（二）：分布式架构关键设计10问">DDD实战：20 总结（二）：分布式架构关键设计10问</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9819-%E6%80%BB%E7%BB%93%E4%B8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%8B%86%E5%88%86%E8%A6%81%E5%9D%9A%E6%8C%81%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99/" title="DDD实战：19 总结（一）：微服务设计和拆分要坚持哪些原则">DDD实战：19 总结（一）：微服务设计和拆分要坚持哪些原则</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9818-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2%E5%9F%BA%E4%BA%8EDDD%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/" title="DDD实战：18 知识点串讲：基于DDD的微服务设计实例">DDD实战：18 知识点串讲：基于DDD的微服务设计实例</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9817-%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%88%B0%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/" title="DDD实战：17 从后端到前端：微服务后，前端如何设计">DDD实战：17 从后端到前端：微服务后，前端如何设计</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【2019双12】ALL IN CLoud 低至1折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1_rYHo7P2gK0jSZPxXXacQpXa-690-388.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="助力产业智慧升级，云服务器首年88元起，更有千元代金券礼包免费领！" target="_blank" style="color:red">
                
                    <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-7c71532bd4935fbdd9a67c1a71e577b1767b805c.200%E7%89%88%E6%9C%ACB.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【渠道专享低折扣】11月特惠 限时2折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1hblJl7Y2gK0jSZFgXXc5OFXa-750-400.jpg">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://geek.zshipu.com/categories/flutter/">flutter (30)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/iOS/">iOS (7)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/unix/">unix (9)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/%E7%AE%97%E6%B3%95/">算法 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://geek.zshipu.com/tags/BI/">BI</a>
    
    <a href="https://geek.zshipu.com/tags/DDD/">DDD</a>
    
    <a href="https://geek.zshipu.com/tags/DDD%E5%AE%9E%E6%88%98/">DDD实战</a>
    
    <a href="https://geek.zshipu.com/tags/DevOps/">DevOps</a>
    
    <a href="https://geek.zshipu.com/tags/JS/">JS</a>
    
    <a href="https://geek.zshipu.com/tags/Java/">Java</a>
    
    <a href="https://geek.zshipu.com/tags/JavaScript/">JavaScript</a>
    
    <a href="https://geek.zshipu.com/tags/Monorepo/">Monorepo</a>
    
    <a href="https://geek.zshipu.com/tags/NextJS/">NextJS</a>
    
    <a href="">Nextjs</a>
    
    <a href="https://geek.zshipu.com/tags/Typora/">Typora</a>
    
    <a href="https://geek.zshipu.com/tags/WebRTC/">WebRTC</a>
    
    <a href="https://geek.zshipu.com/tags/android/">android</a>
    
    <a href="https://geek.zshipu.com/tags/css/">css</a>
    
    <a href="https://geek.zshipu.com/tags/game/">game</a>
    
    <a href="https://geek.zshipu.com/tags/go/">go</a>
    
    <a href="https://geek.zshipu.com/tags/golang/">golang</a>
    
    <a href="">java</a>
    
    <a href="">js</a>
    
    <a href="https://geek.zshipu.com/tags/mysql/">mysql</a>
    
    <a href="https://geek.zshipu.com/tags/nifi/">nifi</a>
    
    <a href="https://geek.zshipu.com/tags/npm/">npm</a>
    
    <a href="https://geek.zshipu.com/tags/python/">python</a>
    
    <a href="https://geek.zshipu.com/tags/reactjs/">reactjs</a>
    
    <a href="https://geek.zshipu.com/tags/sqllit/">sqllit</a>
    
    <a href="https://geek.zshipu.com/tags/vuejs/">vuejs</a>
    
    <a href="https://geek.zshipu.com/tags/web3/">web3</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%B9%A6%E7%B1%8D/">书籍</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%88%86%E8%AF%8D/">分词</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%96%87%E6%91%98/">文摘</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9E%B6%E6%9E%84/">架构</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
    <a href="https://geek.zshipu.com/tags/%E8%B5%B7%E6%AD%A5/">起步</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://geek.zshipu.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>