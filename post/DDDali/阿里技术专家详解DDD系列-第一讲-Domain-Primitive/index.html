<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>阿里技术专家详解 DDD 系列 第一讲- Domain Primitive | 知识铺的博客</title>
    <meta property="og:title" content="阿里技术专家详解 DDD 系列 第一讲- Domain Primitive - 知识铺的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2021-10-14T15:42:00&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2021-10-14T15:42:00&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="阿里技术专家详解 DDD 系列 第一讲- Domain Primitive">
        
    <meta name="author" content="知识铺">
    <meta property="og:url" content="https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E8%AE%B2-Domain-Primitive/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
    
    
    
    
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
    
</head>


<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://geek.zshipu.com/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://geek.zshipu.com/">首页</a>
                    
                    <a  href="https://geek.zshipu.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://geek.zshipu.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#导读">导读</a></li>
<li><a href="#前言">前言</a></li>
<li><a href="#domain-primitive">Domain Primitive</a></li>
<li><a href="#案例分析">案例分析</a>
<ul>
<li><a href="#问题2-数据验证和错误处理">▍问题2 - 数据验证和错误处理</a></li>
<li><a href="#问题3-业务代码的清晰度">▍问题3 - 业务代码的清晰度</a></li>
<li><a href="#问题4-可测试性">▍问题4 - 可测试性</a></li>
</ul></li>
<li><a href="#解决方案">解决方案</a>
<ul>
<li><a href="#评估1-接口的清晰度">▍评估1 - 接口的清晰度</a></li>
<li><a href="#评估2-数据验证和错误处理">▍评估2 - 数据验证和错误处理</a></li>
<li><a href="#评估3-业务代码的清晰度">▍评估3 - 业务代码的清晰度</a></li>
<li><a href="#评估4-可测试性">▍评估4 - 可测试性</a></li>
<li><a href="#评估总结">▍评估总结</a></li>
</ul></li>
<li><a href="#进阶使用">进阶使用</a>
<ul>
<li><a href="#案例1-转账">▍案例1 - 转账</a></li>
<li><a href="#案例2-跨境转账">▍案例2 - 跨境转账</a></li>
</ul></li>
<li><a href="#讨论和总结">讨论和总结</a>
<ul>
<li><a href="#使用-domain-primitive-的三原则">▍使用 Domain Primitive 的三原则</a></li>
<li><a href="#domain-primitive-和-ddd-里-value-object-的区别">▍Domain Primitive 和 DDD 里 Value Object 的区别</a></li>
<li><a href="#domain-primitive-和-data-transfer-object-dto-的区别">▍Domain Primitive 和 Data Transfer Object (DTO) 的区别</a></li>
<li><a href="#什么情况下应该用-domain-primitive">▍什么情况下应该用 Domain Primitive</a></li>
</ul></li>
<li><a href="#实战-老应用重构的流程">实战 - 老应用重构的流程</a>
<ul>
<li><a href="#第一步-创建-domain-primitive-收集所有-dp-行为">▍第一步 - 创建 Domain Primitive，收集所有 DP 行为</a></li>
<li><a href="#第二步-替换数据校验和无状态逻辑">▍第二步 - 替换数据校验和无状态逻辑</a></li>
<li><a href="#第三步-创建新接口">▍第三步 - 创建新接口</a></li>
<li><a href="#第四步-修改外部调用">▍第四步 - 修改外部调用</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">阿里技术专家详解 DDD 系列 第一讲- Domain Primitive</h1>
        </header>
        <date class="post-meta meta-date">
            2021年10月14日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<p>转摘：<a href="https://zhuanlan.zhihu.com/p/340911587">https://zhuanlan.zhihu.com/p/340911587</a></p>

<h2 id="导读">导读</h2>

<p>对于一个架构师来说，在软件开发中如何降低系统复杂度是一个永恒的挑战，无论是 94 年 GoF 的 Design Patterns ， 99 年的 Martin Fowler 的 Refactoring ， 02 年的 P of EAA ，还是 03 年的 Enterprise Integration Patterns ，都是通过一系列的设计模式或范例来降低一些常见的复杂度。</p>

<p>但是问题在于，这些书的理念是通过技术手段解决技术问题，但并没有从根本上解决业务的问题。所以 03 年 Eric Evans 的 Domain Driven Design 一书，以及后续 Vaughn Vernon 的 Implementing DDD ， Uncle Bob 的 Clean Architecture 等书，真正的从业务的角度出发，为全世界绝大部分做纯业务的开发提供了一整套的架构思路。</p>

<p><strong>（本系列持续更新，感兴趣请关注们知乎号，不错过下一波干货）</strong></p>

<h2 id="前言">前言</h2>

<p>由于 DDD 不是一套框架，而是一种架构思想，所以在代码层面缺乏了足够的约束，导致 DDD 在实际应用中上手门槛很高，甚至可以说绝大部分人都对 DDD 的理解有所偏差。举个例子， Martin Fowler 在他个人博客里描述的一个 Anti-pattern，Anemic Domain Model ①（贫血域模型）在实际应用当中层出不穷，而一些仍然火热的 ORM 工具比如 Hibernate，Entity Framework 实际上助长了贫血模型的扩散。同样的，传统的基于数据库技术以及 MVC 的四层应用架构（UI、Business、Data Access、Database），在一定程度上和 DDD 的一些概念混淆，导致绝大部分人在实际应用当中仅仅用到了 DDD 的建模的思想，而其对于整个架构体系的思想无法落地。</p>

<p>第一次接触 DDD 应该是 2012 年，当时除了大型互联网公司，基本上商业应用都还处于单机的时代，服务化的架构还局限于单机 +LB 用 MVC 提供 Rest 接口供外部调用，或者用 SOAP 或 WebServices 做 RPC 调用，但其实更多局限于对外部依赖的协议。让关注到 DDD 思想的是一个叫 Anti-Corruption Layer（防腐层）的概念，特别是其在解决外部依赖频繁变更的情况下，如何将核心业务逻辑和外部依赖隔离的机制。到了 2014 年， SOA 开始大行其道，微服务的概念开始冒头，而如何将一个 Monolith 应用合理的拆分为多个微服务成为了各大论坛的热门话题，而 DDD 里面的 Bounded Context（限界上下文）的思想为微服务拆分提供了一套合理的框架。而在今天，在一个所有的东西都能被称之为“服务”的时代（XAAS）， DDD 的思想让们能冷静下来，去思考到底哪些东西可以被服务化拆分，哪些逻辑需要聚合，才能带来最小的维护成本，而不是简单的去追求开发效率。</p>

<p>所以今天，开始这个关于 DDD 的一系列文章，希望能继续在总结前人的基础上发扬光大 DDD 的思想，但是通过一套认为合理的代码结构、框架和约束，来降低 DDD 的实践门槛，提升代码质量、可测试性、安全性、健壮性。</p>

<p>未来会覆盖的内容包括：</p>

<ul>
<li>最佳架构实践：六边形应用架构 / Clean 架构的核心思想和落地方案</li>
<li>持续发现和交付：Event Storming &gt; Context Map &gt; Design Heuristics &gt; Modelling</li>
<li>降低架构腐败速度：通过 Anti-Corruption Layer 集成第三方库的模块化方案</li>
<li>标准组件的规范和边界：Entity, Aggregate, Repository, Domain Service, Application Service, Event, DTO Assembler 等</li>
<li>基于 Use Case 重定义应用服务的边界</li>
<li>基于 DDD 的微服务化改造及颗粒度控制</li>
<li>CQRS 架构的改造和挑战</li>
<li>基于事件驱动的架构的挑战</li>
<li>等等</li>
</ul>

<p>今天先给大家带来一篇最基础，但极其有价值的Domain Primitive的概念。</p>

<h2 id="domain-primitive">Domain Primitive</h2>

<p>就好像在学任何语言时首先需要了解的是基础数据类型一样，在全面了解 DDD 之前，首先给大家介绍一个最基础的概念: Domain Primitive（DP）。</p>

<p>Primitive 的定义是：</p>

<blockquote>
<p>不从任何其他事物发展而来
初级的形成或生长的早期阶段</p>
</blockquote>

<p>就好像 Integer、String 是所有编程语言的Primitive一样，在 DDD 里， DP 可以说是一切模型、方法、架构的基础，而就像 Integer、String 一样， DP 又是无所不在的。所以，第一讲会对 DP 做一个全面的介绍和分析，但们先不去讲概念，而是从案例入手，看看为什么 DP 是一个强大的概念。</p>

<h2 id="案例分析">案例分析</h2>

<p>们先看一个简单的例子，这个 case 的业务逻辑如下：</p>

<blockquote>
<p>一个新应用在全国通过 地推业务员 做推广，需要做一个用户注册系统，同时希望在用户注册后能够通过用户电话（先假设仅限座机）的地域（区号）对业务员发奖金。</p>
</blockquote>

<p>先不要去纠结这个根据用户电话去发奖金的业务逻辑是否合理，也先不要去管用户是否应该在注册时和业务员做绑定，这里们看的主要还是如何更加合理的去实现这个逻辑。一个简单的用户和用户注册的代码实现如下：</p>

<pre><code class="language-text">public class User {
    Long userId;
    String name;
    String phone;
    String address;
    Long repId;
}

public class RegistrationServiceImpl implements RegistrationService {

    private SalesRepRepository salesRepRepo;
    private UserRepository userRepo;

    public User register(String name, String phone, String address) 
      throws ValidationException {
        // 校验逻辑
        if (name == null || name.length() == 0) {
            throw new ValidationException(&quot;name&quot;);
        }
        if (phone == null || !isValidPhoneNumber(phone)) {
            throw new ValidationException(&quot;phone&quot;);
        }
        // 此处省略address的校验逻辑

        // 取电话号里的区号，然后通过区号找到区域内的SalesRep
        String areaCode = null;
        String[] areas = new String[]{&quot;0571&quot;, &quot;021&quot;, &quot;010&quot;};
        for (int i = 0; i &lt; phone.length(); i++) {
            String prefix = phone.substring(0, i);
            if (Arrays.asList(areas).contains(prefix)) {
                areaCode = prefix;
                break;
            }
        }
        SalesRep rep = salesRepRepo.findRep(areaCode);

        // 最后创建用户，落盘，然后返回
        User user = new User();
        user.name = name;
        user.phone = phone;
        user.address = address;
        if (rep != null) {
            user.repId = rep.repId;
        }

        return userRepo.save(user);
    }

    private boolean isValidPhoneNumber(String phone) {
        String pattern = &quot;^0[1-9]{2,3}-?\\d{8}$&quot;;
        return phone.matches(pattern);
    }
}
</code></pre>

<p>们日常绝大部分代码和模型其实都跟这个是类似的，乍一看貌似没啥问题，但们再深入一步，从以下四个维度去分析一下：接口的清晰度（可阅读性）、数据验证和错误处理、业务逻辑代码的清晰度、和可测试性。</p>

<p><strong>▍问题1 - 接口的清晰度</strong></p>

<p>在Java代码中，对于一个方法来说所有的参数名在编译时丢失，留下的仅仅是一个参数类型的列表，所以们重新看一下以上的接口定义，其实在运行时仅仅是：</p>

<pre><code class="language-text">User register(String, String, String);
</code></pre>

<p>所以以下的代码是一段编译器完全不会报错的，很难通过看代码就能发现的 bug ：</p>

<pre><code class="language-text">service.register(&quot;殷浩&quot;, &quot;浙江省杭州市余杭区文三西路969号&quot;, &quot;0571-12345678&quot;);
</code></pre>

<p>当然，在真实代码中运行时会报错，但这种 bug 是在运行时被发现的，而不是在编译时。普通的 Code Review 也很难发现这种问题，很有可能是代码上线后才会被暴露出来。这里的思考是，有没有办法在编码时就避免这种可能会出现的问题？</p>

<p>另外一种常见的，特别是在查询服务中容易出现的例子如下：</p>

<pre><code class="language-text">User findByName(String name);
User findByPhone(String phone);
User findByNameAndPhone(String name, String phone);
</code></pre>

<p>在这个场景下，由于入参都是 String 类型，不得不在方法名上面加上 <code>ByXXX</code>来区分，而 <code>findByNameAndPhone</code>同样也会陷入前面的入参顺序错误的问题，而且和前面的入参不同，这里参数顺序如果输错了，方法不会报错只会返回 <code>null</code>，而这种 bug 更加难被发现。这里的思考是，有没有办法让方法入参一目了然，避免入参错误导致的 bug ？</p>

<h3 id="问题2-数据验证和错误处理">▍问题2 - 数据验证和错误处理</h3>

<p>在前面这段数据校验代码：</p>

<pre><code class="language-text">if (phone == null || !isValidPhoneNumber(phone)) {
    throw new ValidationException(&quot;phone&quot;);
}
</code></pre>

<p>在日常编码中经常会出现，一般来说这种代码需要出现在方法的最前端，确保能够 fail-fast 。但是假设你有多个类似的接口和类似的入参，在每个方法里这段逻辑会被重复。而更严重的是如果未来们要拓展电话号去包含手机时，很可能需要加入以下代码：</p>

<pre><code class="language-text">if (phone == null || !isValidPhoneNumber(phone) || !isValidCellNumber(phone)) {
    throw new ValidationException(&quot;phone&quot;);
}
</code></pre>

<p>如果你有很多个地方用到了 phone 这个入参，但是有个地方忘记修改了，会造成 bug 。这是一个 DRY 原则被违背时经常会发生的问题。</p>

<p>如果有个新的需求，需要把入参错误的原因返回，那么这段代码就变得更加复杂：</p>

<pre><code class="language-text">if (phone == null) {
    throw new ValidationException(&quot;phone不能为空&quot;);
} else if (!isValidPhoneNumber(phone)) {
    throw new ValidationException(&quot;phone格式错误&quot;);
}
</code></pre>

<p>可以想像得到，代码里充斥着大量的类似代码块时，维护成本要有多高。</p>

<p>最后，在这个业务方法里，会（隐性或显性的）抛 <code>ValidationException</code>，所以需要外部调用方去try/catch，而业务逻辑异常和数据校验异常被混在了一起，是否是合理的？</p>

<p>在传统Java架构里有几个办法能够去解决一部分问题，常见的如BeanValidation注解或ValidationUtils类，比如：</p>

<pre><code class="language-text">// Use Bean Validation
User registerWithBeanValidation(
  @NotNull @NotBlank String name,
  @NotNull @Pattern(regexp = &quot;^0?[1-9]{2,3}-?\\d{8}$&quot;) String phone,
  @NotNull String address
);

// Use ValidationUtils:
public User registerWithUtils(String name, String phone, String address) {
    ValidationUtils.validateName(name); // throws ValidationException
    ValidationUtils.validatePhone(phone);
    ValidationUtils.validateAddress(address);
    ...
}
</code></pre>

<p>但这几个传统的方法同样有问题，</p>

<p><strong>BeanValidation：</strong></p>

<ul>
<li>通常只能解决简单的校验逻辑，复杂的校验逻辑一样要写代码实现定制校验器</li>
<li>在添加了新校验逻辑时，同样会出现在某些地方忘记添加一个注解的情况，DRY原则还是会被违背</li>
</ul>

<p><strong>ValidationUtils类：</strong></p>

<ul>
<li>当大量的校验逻辑集中在一个类里之后，违背了Single Responsibility单一性原则，导致代码混乱和不可维护</li>
<li>业务异常和校验异常还是会混杂</li>
</ul>

<p>所以，有没有一种方法，能够一劳永逸的解决所有校验的问题以及降低后续的维护成本和异常处理成本呢？</p>

<h3 id="问题3-业务代码的清晰度">▍问题3 - 业务代码的清晰度</h3>

<p>在这段代码里：</p>

<pre><code class="language-text">String areaCode = null;
String[] areas = new String[]{&quot;0571&quot;, &quot;021&quot;, &quot;010&quot;};
for (int i = 0; i &lt; phone.length(); i++) {
    String prefix = phone.substring(0, i);
    if (Arrays.asList(areas).contains(prefix)) {
        areaCode = prefix;
        break;
    }
}
SalesRep rep = salesRepRepo.findRep(areaCode);
</code></pre>

<p>实际上出现了另外一种常见的情况，那就是从一些入参里抽取一部分数据，然后调用一个外部依赖获取更多的数据，然后通常从新的数据中再抽取部分数据用作其他的作用。这种代码通常被称作“胶水代码”，其本质是由于外部依赖的服务的入参并不符合们原始的入参导致的。比如，如果<code>SalesRepRepository</code>包含一个<code>findRepByPhone</code>的方法，则上面大部分的代码都不必要了。</p>

<p>所以，一个常见的办法是将这段代码抽离出来，变成独立的一个或多个方法：</p>

<pre><code class="language-text">private static String findAreaCode(String phone) {
    for (int i = 0; i &lt; phone.length(); i++) {
        String prefix = phone.substring(0, i);
        if (isAreaCode(prefix)) {
            return prefix;
        }
    }
    return null;
}

private static boolean isAreaCode(String prefix) {
    String[] areas = new String[]{&quot;0571&quot;, &quot;021&quot;};
    return Arrays.asList(areas).contains(prefix);
}
</code></pre>

<p>然后原始代码变为：</p>

<pre><code class="language-text">String areaCode = findAreaCode(phone);
SalesRep rep = salesRepRepo.findRep(areaCode);
</code></pre>

<p>而为了复用以上的方法，可能会抽离出一个静态工具类 <code>PhoneUtils</code>。但是这里要思考的是，静态工具类是否是最好的实现方式呢？当你的项目里充斥着大量的静态工具类，业务代码散在多个文件当中时，你是否还能找到核心的业务逻辑呢？</p>

<h3 id="问题4-可测试性">▍问题4 - 可测试性</h3>

<p>为了保证代码质量，每个方法里的每个入参的每个可能出现的条件都要有 TC 覆盖（假设们先不去测试内部业务逻辑），所以在们这个方法里需要以下的 TC ：</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/v2-91a09472af63fccdcfd1231f2882fcfd_b.jpg" alt="img" /></p>

<p>假如一个方法有 N 个参数，每个参数有 M 个校验逻辑，至少要有 N * M 个 TC 。</p>

<p>如果这时候在该方法中加入一个新的入参字段 <code>fax</code> ，即使 <code>fax</code> 和 <code>phone</code> 的校验逻辑完全一致，为了保证 TC 覆盖率，也一样需要 M 个新的 TC 。</p>

<p>而假设有 P 个方法中都用到了 <code>phone</code>这个字段，这 P 个方法都需要对该字段进行测试，也就是说整体需要：</p>

<p><strong>P * N * M</strong></p>

<p>个测试用例才能完全覆盖所有数据验证的问题，在日常项目中，这个测试的成本非常之高，导致大量的代码没被覆盖到。而没被测试覆盖到的代码才是最有可能出现问题的地方。</p>

<p>在这个情况下，降低测试成本 == 提升代码质量，如何能够降低测试的成本呢？</p>

<h2 id="解决方案">解决方案</h2>

<p>们回头先重新看一下原始的 use case，并且标注其中可能重要的概念：</p>

<p>一个新应用在全国通过 地推业务员 做推广，需要做一个用户的注册系统，在用户注册后能够通过用户电话号的区号对业务员发奖金。</p>

<p>在分析了 use case 后，发现其中地推业务员、用户本身自带 ID 属性，属于 Entity（实体），而注册系统属于 Application Service（应用服务），这几个概念已经有存在。但是发现电话号这个概念却完全被隐藏到了代码之中。们可以问一下自己，取电话号的区号的逻辑是否属于用户（用户的区号？）？是否属于注册服务（注册的区号？）？如果都不是很贴切，那就说明这个逻辑应该属于一个独立的概念。所以这里引入们第一个原则：</p>

<p><strong>Make Implicit Concepts Explicit</strong></p>

<p><strong>将隐性的概念显性化</strong></p>

<p>在这里，们可以看到，原来电话号仅仅是用户的一个参数，属于隐形概念，但实际上电话号的区号才是真正的业务逻辑，而们需要将电话号的概念显性化，通过写一个Value Object：</p>

<pre><code class="language-text">public class PhoneNumber {
  
    private final String number;
    public String getNumber() {
        return number;
    }

    public PhoneNumber(String number) {
        if (number == null) {
            throw new ValidationException(&quot;number不能为空&quot;);
        } else if (isValid(number)) {
            throw new ValidationException(&quot;number格式错误&quot;);
        }
        this.number = number;
    }

    public String getAreaCode() {
        for (int i = 0; i &lt; number.length(); i++) {
            String prefix = number.substring(0, i);
            if (isAreaCode(prefix)) {
                return prefix;
            }
        }
        return null;
    }

    private static boolean isAreaCode(String prefix) {
        String[] areas = new String[]{&quot;0571&quot;, &quot;021&quot;, &quot;010&quot;};
        return Arrays.asList(areas).contains(prefix);
    }

    public static boolean isValid(String number) {
        String pattern = &quot;^0?[1-9]{2,3}-?\\d{8}$&quot;;
        return number.matches(pattern);
    }

}
</code></pre>

<p>这里面有几个很重要的元素：</p>

<ol>
<li>通过 <code>private final String number</code> 确保 <code>PhoneNumber</code> 是一个（Immutable）Value Object。（一般来说 VO 都是 Immutable 的，这里只是重点强调一下）</li>
<li>校验逻辑都放在了 constructor 里面，确保只要 <code>PhoneNumber</code>类被创建出来后，一定是校验通过的。</li>
<li>之前的 <code>findAreaCode</code> 方法变成了 <code>PhoneNumber</code>类里的 <code>getAreaCode</code>，突出了 <code>areaCode</code> 是 <code>PhoneNumber</code> 的一个计算属性。</li>
</ol>

<p>这样做完之后，们发现把 <code>PhoneNumber</code> 显性化之后，其实是生成了一个 Type（数据类型）和一个 Class（类）：</p>

<ul>
<li>Type 指们在今后的代码里可以通过 <code>PhoneNumber</code> 去显性的标识电话号这个概念</li>
<li>Class 指们可以把所有跟电话号相关的逻辑完整的收集到一个文件里</li>
</ul>

<p>这两个概念加起来，构造成了本文标题的 Domain Primitive（DP）。</p>

<p>们看一下全面使用了 DP 之后效果：</p>

<pre><code class="language-text">public class User {
    UserId userId;
    Name name;
    PhoneNumber phone;
    Address address;
    RepId repId;
}

public User register(
  @NotNull Name name,
  @NotNull PhoneNumber phone,
  @NotNull Address address
) {
    // 找到区域内的SalesRep
    SalesRep rep = salesRepRepo.findRep(phone.getAreaCode());

    // 最后创建用户，落盘，然后返回，这部分代码实际上也能用Builder解决
    User user = new User();
    user.name = name;
    user.phone = phone;
    user.address = address;
    if (rep != null) {
        user.repId = rep.repId;
    }

    return userRepo.saveUser(user);
}
</code></pre>

<p>们可以看到在使用了 DP 之后，所有的数据验证逻辑和非业务流程的逻辑都消失了，剩下都是核心业务逻辑，可以一目了然。们重新用上面的四个维度评估一下：</p>

<h3 id="评估1-接口的清晰度">▍评估1 - 接口的清晰度</h3>

<p>重构后的方法签名变成了很清晰的：</p>

<pre><code class="language-text">public User register(Name, PhoneNumber, Address)
</code></pre>

<p>而之前容易出现的bug，如果按照现在的写法</p>

<pre><code class="language-text">service.register(new Name(&quot;殷浩&quot;), new Address(&quot;浙江省杭州市余杭区文三西路969号&quot;), new PhoneNumber(&quot;0571-12345678&quot;));
</code></pre>

<p>让接口 API 变得很干净，易拓展。</p>

<h3 id="评估2-数据验证和错误处理">▍评估2 - 数据验证和错误处理</h3>

<pre><code class="language-text">public User register(
  @NotNull Name name,
  @NotNull PhoneNumber phone,
  @NotNull Address address
) // no throws
</code></pre>

<p>如前文代码展示的，重构后的方法里，完全没有了任何数据验证的逻辑，也不会抛 <code>ValidationException</code> 。原因是因为 DP 的特性，只要是能够带到入参里的一定是正确的或 null（Bean Validation 或 lombok 的注解能解决 null 的问题）。所以们把数据验证的工作量前置到了调用方，而调用方本来就是应该提供合法数据的，所以更加合适。</p>

<p>再展开来看，使用DP的另一个好处就是代码遵循了 DRY 原则和单一性原则，如果未来需要修改 <code>PhoneNumber</code>的校验逻辑，只需要在一个文件里修改即可，所有使用到了 <code>PhoneNumber</code> 的地方都会生效。</p>

<h3 id="评估3-业务代码的清晰度">▍评估3 - 业务代码的清晰度</h3>

<pre><code class="language-text">SalesRep rep = salesRepRepo.findRep(phone.getAreaCode());
User user = xxx;
return userRepo.save(user);
</code></pre>

<p>除了在业务方法里不需要校验数据之外，原来的一段胶水代码 <code>findAreaCode</code>被改为了 <code>PhoneNumber</code>类的一个计算属性 <code>getAreaCode</code>，让代码清晰度大大提升。而且胶水代码通常都不可复用，但是使用了 DP 后，变成了可复用、可测试的代码。们能看到，在刨除了数据验证代码、胶水代码之后，剩下的都是核心业务逻辑。（ Entity 相关的重构在后面文章会谈到，这次先忽略）</p>

<h3 id="评估4-可测试性">▍评估4 - 可测试性</h3>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/v2-78c099245efa683fb35a7d7f0ab27833_b.jpg" alt="img" /></p>

<p>当们将 <code>PhoneNumber</code>抽取出来之后，在来看测试的 TC ：</p>

<ul>
<li>首先 <code>PhoneNumber</code> 本身还是需要 M 个测试用例，但是由于们只需要测试单一对象，每个用例的代码量会大大降低，维护成本降低。</li>
<li>每个方法里的每个参数，现在只需要覆盖为 null 的情况就可以了，其他的 case 不可能发生（因为只要不是 null 就一定是合法的）</li>
</ul>

<p>所以，单个方法的 TC 从原来的 N * M 变成了今天的 N + M 。同样的，多个方法的 TC 数量变成了</p>

<p>N + M + P</p>

<p>这个数量一般来说要远低于原来的数量 N* M * P ，让测试成本极大的降低。</p>

<h3 id="评估总结">▍评估总结</h3>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/v2-014d1240f404c93353da3881bc78b8c3_b.jpg" alt="img" /></p>

<h2 id="进阶使用">进阶使用</h2>

<p>在上文介绍了 DP 的第一个原则：将隐性的概念显性化。在这里将介绍 DP 的另外两个原则，用一个新的案例。</p>

<h3 id="案例1-转账">▍案例1 - 转账</h3>

<p>假设现在要实现一个功能，让A用户可以支付 x 元给用户 B ，可能的实现如下：</p>

<pre><code class="language-text">public void pay(BigDecimal money, Long recipientId) {
    BankService.transfer(money, &quot;CNY&quot;, recipientId);
}
</code></pre>

<p>如果这个是境内转账，并且境内的货币永远不变，该方法貌似没啥问题，但如果有一天货币变更了（比如欧元区曾经出现的问题），或者们需要做跨境转账，该方法是明显的 bug ，因为 <code>money</code>对应的货币不一定是 CNY 。</p>

<p>在这个 case 里，当们说“支付 x 元”时，除了 x 本身的数字之外，实际上是有一个隐含的概念那就是货币“元”。但是在原始的入参里，之所以只用了 <code>BigDecimal</code> 的原因是们认为 CNY 货币是默认的，是一个隐含的条件，但是在们写代码时，需要把所有隐性的条件显性化，而这些条件整体组成当前的上下文。所以 DP 的第二个原则是：</p>

<p><strong>Make Implicit Context Explicit</strong></p>

<p><strong>将 隐性的 上下文 显性化</strong></p>

<p>所以当们做这个支付功能时，实际上需要的一个入参是支付金额 + 支付货币。们可以把这两个概念组合成为一个独立的完整概念：<code>Money</code>。</p>

<pre><code class="language-text">@Value
public class Money {
    private BigDecimal amount;
    private Currency currency;
    public Money(BigDecimal amount, Currency currency) {
        this.amount = amount;
        this.currency = currency;
    }
}
</code></pre>

<p>而原有的代码则变为：</p>

<pre><code class="language-text">public void pay(Money money, Long recipientId) {
    BankService.transfer(money, recipientId);
}
</code></pre>

<p>通过将默认货币这个隐性的上下文概念显性化，并且和金额合并为 <code>Money</code> ，们可以避免很多当前看不出来，但未来可能会暴雷的bug。</p>

<h3 id="案例2-跨境转账">▍案例2 - 跨境转账</h3>

<p>前面的案例升级一下，假设用户可能要做跨境转账从 CNY 到 USD ，并且货币汇率随时在波动：</p>

<pre><code class="language-text">public void pay(Money money, Currency targetCurrency, Long recipientId) {
    if (money.getCurrency().equals(targetCurrency)) {
        BankService.transfer(money, recipientId);
    } else {
        BigDecimal rate = ExchangeService.getRate(money.getCurrency(), targetCurrency);
        BigDecimal targetAmount = money.getAmount().multiply(new BigDecimal(rate));
        Money targetMoney = new Money(targetAmount, targetCurrency);
        BankService.transfer(targetMoney, recipientId);
    }
}
</code></pre>

<p>在这个case里，由于 <code>targetCurrency</code>不一定和 <code>money</code> 的 <code>Curreny</code>一致，需要调用一个服务去取汇率，然后做计算。最后用计算后的结果做转账。</p>

<p>这个case最大的问题在于，金额的计算被包含在了支付的服务中，涉及到的对象也有2个 <code>Currency</code> ，2 个 <code>Money</code> ，1 个 <code>BigDecimal</code>，总共 5 个对象。这种涉及到多个对象的业务逻辑，需要用 DP 包装掉，所以这里引出 DP 的第三个原则：</p>

<p><strong>Encapsulate Multi-Object Behavior</strong></p>

<p><strong>封装 多对象 行为</strong></p>

<p>在这个 case 里，可以将转换汇率的功能，封装到一个叫做 <code>ExchangeRate</code>的 DP 里：</p>

<pre><code class="language-text">@Value
public class ExchangeRate {
    private BigDecimal rate;
    private Currency from;
    private Currency to;

    public ExchangeRate(BigDecimal rate, Currency from, Currency to) {
        this.rate = rate;
        this.from = from;
        this.to = to;
    }

    public Money exchange(Money fromMoney) {
        notNull(fromMoney);
        isTrue(this.from.equals(fromMoney.getCurrency()));
        BigDecimal targetAmount = fromMoney.getAmount().multiply(rate);
        return new Money(targetAmount, to);
    }
}
</code></pre>

<p><code>ExchangeRate</code>汇率对象，通过封装金额计算逻辑以及各种校验逻辑，让原始代码变得极其简单：</p>

<pre><code class="language-text">public void pay(Money money, Currency targetCurrency, Long recipientId) {
    ExchangeRate rate = ExchangeService.getRate(money.getCurrency(), targetCurrency);
    Money targetMoney = rate.exchange(money);
    BankService.transfer(targetMoney, recipientId);
}
</code></pre>

<h2 id="讨论和总结">讨论和总结</h2>

<p><strong>▍Domain Primitive 的定义</strong></p>

<p>让们重新来定义一下 Domain Primitive ：Domain Primitive 是一个在特定领域里，拥有精准定义的、可自验证的、拥有行为的 Value Object 。</p>

<ul>
<li>DP是一个传统意义上的Value Object，拥有Immutable的特性</li>
<li>DP是一个完整的概念整体，拥有精准定义</li>
<li>DP使用业务域中的原生语言</li>
<li>DP可以是业务域的最小组成部分、也可以构建复杂组合</li>
</ul>

<p>注：Domain Primitive的概念和命名来自于Dan Bergh Johnsson &amp; Daniel Deogun的书 Secure by Design。</p>

<h3 id="使用-domain-primitive-的三原则">▍使用 Domain Primitive 的三原则</h3>

<ul>
<li>让隐性的概念显性化</li>
<li>让隐性的上下文显性化</li>
<li>封装多对象行为</li>
</ul>

<h3 id="domain-primitive-和-ddd-里-value-object-的区别">▍Domain Primitive 和 DDD 里 Value Object 的区别</h3>

<p>在 DDD 中， Value Object 这个概念其实已经存在：</p>

<ul>
<li>在 Evans 的 DDD 蓝皮书中，Value Object 更多的是一个非 Entity 的值对象</li>
<li>在Vernon的IDDD红皮书中，作者更多的关注了Value Object的Immutability、Equals方法、Factory方法等</li>
</ul>

<p>Domain Primitive 是 Value Object 的进阶版，在原始 VO 的基础上要求每个 DP 拥有概念的整体，而不仅仅是值对象。在 VO 的 Immutable 基础上增加了 Validity 和行为。当然同样的要求无副作用（side-effect free）。</p>

<h3 id="domain-primitive-和-data-transfer-object-dto-的区别">▍Domain Primitive 和 Data Transfer Object (DTO) 的区别</h3>

<p>在日常开发中经常会碰到的另一个数据结构是 DTO ，比如方法的入参和出参。DP 和 DTO 的区别如下：</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/v2-c534beeee92e2d54c7b7d5652d04f463_b.jpg" alt="img" /></p>

<h3 id="什么情况下应该用-domain-primitive">▍什么情况下应该用 Domain Primitive</h3>

<p>常见的 DP 的使用场景包括：</p>

<ul>
<li>有格式限制的 <code>String</code>：比如<code>Name</code>，<code>PhoneNumber</code>，<code>OrderNumber</code>，<code>ZipCode</code>，<code>Address</code>等</li>
<li>有限制的<code>Integer</code>：比如<code>OrderId</code>（&gt;0），<code>Percentage</code>（0-100%），<code>Quantity</code>（&gt;=0）等</li>
<li>可枚举的 <code>int</code>：比如 <code>Status</code>（一般不用Enum因为反序列化问题）</li>
<li><code>Double</code> 或 <code>BigDecimal</code>：一般用到的 <code>Double</code> 或 <code>BigDecimal</code>都是有业务含义的，比如 <code>Temperature</code>、<code>Money</code>、<code>Amount</code>、<code>ExchangeRate</code>、<code>Rating</code> 等</li>
<li>复杂的数据结构：比如 <code>Map&lt;String, List&lt;Integer&gt;&gt;</code>等，尽量能把 <code>Map</code> 的所有操作包装掉，仅暴露必要行为</li>
</ul>

<h2 id="实战-老应用重构的流程">实战 - 老应用重构的流程</h2>

<p>在新应用中使用 DP 是比较简单的，但在老应用中使用 DP 是可以遵循以下流程按部就班的升级。在此用本文的第一个 case 为例。</p>

<h3 id="第一步-创建-domain-primitive-收集所有-dp-行为">▍第一步 - 创建 Domain Primitive，收集所有 DP 行为</h3>

<p>在前文中，们发现取电话号的区号这个是一个可以独立出来的、可以放入 PhoneNumber 这个 Class 的逻辑。类似的，在真实的项目中，以前散落在各个服务或工具类里面的代码，可以都抽出来放在 DP 里，成为 DP 自己的行为或属性。这里面的原则是：所有抽离出来的方法要做到无状态，比如原来是 static 的方法。如果原来的方法有状态变更，需要将改变状态的部分和不改状态的部分分离，然后将无状态的部分融入 DP 。因为 DP 本身不能带状态，所以一切需要改变状态的代码都不属于 DP 的范畴。</p>

<p>(代码参考 PhoneNumber 的代码，这里不再重复)</p>

<h3 id="第二步-替换数据校验和无状态逻辑">▍第二步 - 替换数据校验和无状态逻辑</h3>

<p>为了保障现有方法的兼容性，在第二步不会去修改接口的签名，而是通过代码替换原有的校验逻辑和根 DP 相关的业务逻辑。比如：</p>

<pre><code class="language-text">public User register(String name, String phone, String address)
        throws ValidationException {
    if (name == null || name.length() == 0) {
        throw new ValidationException(&quot;name&quot;);
    }
    if (phone == null || !isValidPhoneNumber(phone)) {
        throw new ValidationException(&quot;phone&quot;);
    }
    
    String areaCode = null;
    String[] areas = new String[]{&quot;0571&quot;, &quot;021&quot;, &quot;010&quot;};
    for (int i = 0; i &lt; phone.length(); i++) {
        String prefix = phone.substring(0, i);
        if (Arrays.asList(areas).contains(prefix)) {
            areaCode = prefix;
            break;
        }
    }
    SalesRep rep = salesRepRepo.findRep(areaCode);
    // 其他代码...
}
</code></pre>

<p>通过 DP 替换代码后：</p>

<pre><code class="language-text">public User register(String name, String phone, String address)
        throws ValidationException {
    
    Name _name = new Name(name);
    PhoneNumber _phone = new PhoneNumber(phone);
    Address _address = new Address(address);
    
    SalesRep rep = salesRepRepo.findRep(_phone.getAreaCode());
    // 其他代码...
}
</code></pre>

<p>通过 new PhoneNumber(phone) 这种代码，替代了原有的校验代码。</p>

<p>通过 _phone.getAreaCode() 替换了原有的无状态的业务逻辑。</p>

<h3 id="第三步-创建新接口">▍第三步 - 创建新接口</h3>

<p>创建新接口，将DP的代码提升到接口参数层：</p>

<pre><code class="language-text">public User register(Name name, PhoneNumber phone, Address address) {
    SalesRep rep = salesRepRepo.findRep(phone.getAreaCode());
}
</code></pre>

<h3 id="第四步-修改外部调用">▍第四步 - 修改外部调用</h3>

<p>外部调用方需要修改调用链路，比如：</p>

<pre><code class="language-text">service.register(&quot;殷浩&quot;, &quot;0571-12345678&quot;, &quot;浙江省杭州市余杭区文三西路969号&quot;);
</code></pre>

<p>改为：</p>

<pre><code class="language-text">service.register(new Name(&quot;殷浩&quot;), new PhoneNumber(&quot;0571-12345678&quot;), new Address(&quot;浙江省杭州市余杭区文三西路969号&quot;));
</code></pre>

<p>通过以上 4 步，就能让你的代码变得更加简洁、优雅、健壮、安全。你还在等什么？今天就去尝试吧！</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://geek.zshipu.com/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E8%AE%B2-Domain-Primitive/">https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E8%AE%B2-Domain-Primitive/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/DDDzl/%E4%BA%A4%E6%98%93%E4%B8%AD%E5%BF%83%E5%AE%9E%E6%88%98-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%975/">交易中心实战-领域驱动设计系列5</a></li>
        
        <li><a href="/post/DDDzl/%E7%BB%93%E5%90%88%E7%94%B5%E5%95%86%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%974/">结合电商支付业务-领域驱动设计系列4</a></li>
        
        <li><a href="/post/DDDzl/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%973/">六边形架构-领域驱动设计系列3</a></li>
        
        <li><a href="/post/DDDzl/%E6%88%98%E6%9C%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%972/">战术领域驱动设计-领域驱动设计系列2</a></li>
        
        <li><a href="/post/DDDzl/%E6%88%98%E7%95%A5%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%971/">战略领域驱动设计-领域驱动设计系列1</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/DDD'>DDD</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-geek"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2021 <a href="https://geek.zshipu.com/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://geek.zshipu.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://geek.zshipu.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-Metabase%E4%B8%8ECBoard%E5%B7%AE%E5%BC%82%E5%8C%96%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E/" title="BI-可视化-Metabase与CBoard差异化分析说明">BI-可视化-Metabase与CBoard差异化分析说明</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-supersetmetabaseredash%E4%B8%89%E4%B8%AA%E5%BC%80%E6%BA%90BI%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%8F%8A%E5%88%86%E6%9E%90/" title="BI-可视化-superset、metabase、redash三个开源BI工具的个人使用心得及分析">BI-可视化-superset、metabase、redash三个开源BI工具的个人使用心得及分析</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-ETL-%E5%9C%A810%E5%88%86%E9%92%9F%E5%86%85%E6%8E%8C%E6%8F%A1Apache-Airflow/" title="BI-ETL-在10分钟内掌握Apache Airflow">BI-ETL-在10分钟内掌握Apache Airflow</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%AF%8F%E4%B8%AA%E4%B8%93%E4%B8%9A%E4%BA%BA%E5%91%98%E9%83%BD%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E7%9A%84-10-%E4%B8%AA%E6%83%B3%E6%B3%95/" title="BI-数据可视化-数据可视化，每个专业人员都应该避免的 10 个想法">BI-数据可视化-数据可视化，每个专业人员都应该避免的 10 个想法</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-ETL-%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B-101-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Apache-Airflow/" title="BI-ETL-开始使用Apache Airflow">BI-ETL-开始使用Apache Airflow</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-ETL-Apache-Airflow%E7%AE%80%E4%BB%8B5%E5%88%86%E9%92%9F%E5%86%85%E5%BC%80%E5%A7%8B/" title="BI-ETL-Apache Airflow简介：5分钟内开始">BI-ETL-Apache Airflow简介：5分钟内开始</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E6%95%B0%E6%8D%AE%E4%BB%93-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" title="BI-数据仓-初学者数据仓库教程：学习基本概念">BI-数据仓-初学者数据仓库教程：学习基本概念</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B9%96-%E5%AE%83%E6%98%AF%E5%BB%BA%E7%AD%91-%E6%95%B0%E6%8D%AE%E6%B9%96%E6%95%99%E7%A8%8B/" title="BI-数据湖-什么是数据湖 它是建筑-数据湖教程">BI-数据湖-什么是数据湖 它是建筑-数据湖教程</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%95%B0%E6%8D%AE%E6%B9%96%E6%A6%82%E5%BF%B5%E7%89%B9%E5%BE%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A1%88%E4%BE%8B/" title="BI-数据湖-一文看懂数据湖：概念、特征、架构与案例">BI-数据湖-一文看懂数据湖：概念、特征、架构与案例</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/bi/BI-MongoDB-%E4%B8%AD%E5%8F%B0MongoDB%E5%BA%94%E7%94%A8/" title="BI-MongoDB-中台MongoDB应用">BI-MongoDB-中台MongoDB应用</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【2019双12】ALL IN CLoud 低至1折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1_rYHo7P2gK0jSZPxXXacQpXa-690-388.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="助力产业智慧升级，云服务器首年88元起，更有千元代金券礼包免费领！" target="_blank" style="color:red">
                
                    <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-7c71532bd4935fbdd9a67c1a71e577b1767b805c.200%E7%89%88%E6%9C%ACB.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【渠道专享低折扣】11月特惠 限时2折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1hblJl7Y2gK0jSZFgXXc5OFXa-750-400.jpg">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://geek.zshipu.com/categories/flutter/">flutter (30)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/iOS/">iOS (7)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/unix/">unix (9)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/%E7%AE%97%E6%B3%95/">算法 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://geek.zshipu.com/tags/BI/">BI</a>
    
    <a href="https://geek.zshipu.com/tags/DDD/">DDD</a>
    
    <a href="https://geek.zshipu.com/tags/DevOps/">DevOps</a>
    
    <a href="https://geek.zshipu.com/tags/Java/">Java</a>
    
    <a href="https://geek.zshipu.com/tags/Monorepo/">Monorepo</a>
    
    <a href="https://geek.zshipu.com/tags/Typora/">Typora</a>
    
    <a href="https://geek.zshipu.com/tags/css/">css</a>
    
    <a href="https://geek.zshipu.com/tags/go/">go</a>
    
    <a href="https://geek.zshipu.com/tags/golang/">golang</a>
    
    <a href="">java</a>
    
    <a href="https://geek.zshipu.com/tags/js/">js</a>
    
    <a href="https://geek.zshipu.com/tags/mysql/">mysql</a>
    
    <a href="https://geek.zshipu.com/tags/npm/">npm</a>
    
    <a href="https://geek.zshipu.com/tags/python/">python</a>
    
    <a href="https://geek.zshipu.com/tags/reactjs/">reactjs</a>
    
    <a href="https://geek.zshipu.com/tags/sqllit/">sqllit</a>
    
    <a href="https://geek.zshipu.com/tags/vuejs/">vuejs</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%B9%A6%E7%B1%8D/">书籍</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%88%86%E8%AF%8D/">分词</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%96%87%E6%91%98/">文摘</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9E%B6%E6%9E%84/">架构</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://geek.zshipu.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>