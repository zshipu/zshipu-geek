<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>前端知识点大全 | 知识铺的博客</title>
    <meta property="og:title" content="前端知识点大全 - 知识铺的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2022-06-17T09:05:31&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2022-06-17T09:05:31&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="前端知识点大全">
        <meta name="author" content="知识铺">
        
    <meta property="og:url" content="https://geek.zshipu.com/post/css/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
    
    
    
    
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
    
</head>


<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://geek.zshipu.com/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://geek.zshipu.com/">首页</a>
                    
                    <a  href="https://geek.zshipu.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://geek.zshipu.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#一-简历">一、简历</a>
<ul>
<li><a href="#1-重点">1、重点</a></li>
<li><a href="#2-简历包含的内容">2、简历包含的内容</a>
<ul>
<li><a href="#2-1-基本信息">2.1 基本信息</a></li>
<li><a href="#2-2-专业技能">2.2 专业技能</a></li>
<li><a href="#2-3-工作经历">2.3 工作经历</a></li>
<li><a href="#2-4-项目经历">2.4 项目经历</a></li>
<li><a href="#2-5-社区贡献">2.5 社区贡献</a></li>
</ul></li>
<li><a href="#3-注意事项">3、注意事项</a></li>
<li><a href="#4-面试前准备">4、面试前准备</a></li>
</ul></li>
<li><a href="#二-html-css-面试题">二、HTML+CSS 面试题</a>
<ul>
<li><a href="#1-html-面试题">1、HTML 面试题</a>
<ul>
<li><a href="#1-1-如何理解-html-语义化">1.1 如何理解 HTML 语义化？</a></li>
<li><a href="#1-2-script-标签中-defer-和-async-的区别">1.2 script 标签中 defer 和 async 的区别？</a></li>
<li><a href="#1-3-从浏览器地址栏输入-url-到请求返回发生了什么">1.3 从浏览器地址栏输入 url 到请求返回发生了什么</a></li>
</ul></li>
<li><a href="#2-css-面试题">2、CSS 面试题</a>
<ul>
<li><a href="#2-1-盒模型介绍">2.1 盒模型介绍</a></li>
<li><a href="#2-2-css-选择器和优先级">2.2 css 选择器和优先级</a></li>
<li><a href="#2-3-重排-reflow-和重绘-repaint-的理解">2.3 重排（reflow）和重绘（repaint）的理解</a></li>
<li><a href="#2-4-对-bfc-的理解">2.4 对 BFC 的理解</a></li>
<li><a href="#2-5-实现两栏布局-左侧固定-右侧自适应布局">2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</a></li>
<li><a href="#2-6-实现圣杯布局和双飞翼布局-经典三分栏布局">2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</a></li>
<li><a href="#2-7-水平垂直居中多种实现方式">2.7 水平垂直居中多种实现方式</a></li>
<li><a href="#2-8-flex-布局">2.8 flex 布局</a></li>
<li><a href="#2-9-line-height-如何继承">2.9 line-height 如何继承？</a></li>
</ul></li>
</ul></li>
<li><a href="#三-js-基础">三、js 基础</a>
<ul>
<li><a href="#1-数据类型">1、数据类型</a>
<ul>
<li><a href="#1-1-基本的数据类型介绍-及值类型和引用类型的理解">1.1 基本的数据类型介绍，及值类型和引用类型的理解</a></li>
<li><a href="#1-2-数据类型的判断">1.2 数据类型的判断</a></li>
<li><a href="#1-3-手写深拷贝">1.3 手写深拷贝</a></li>
<li><a href="#1-4-根据-0-1-0-2-0-3-讲讲-ieee-754-如何让其相等">1.4 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？</a></li>
</ul></li>
<li><a href="#2-原型和原型链">2、 原型和原型链</a></li>
<li><a href="#3-作用域与作用域链">3、 作用域与作用域链</a></li>
<li><a href="#4-执行上下文">4、 执行上下文</a></li>
<li><a href="#5-闭包">5、 闭包</a></li>
<li><a href="#6-call-apply-bind-实现">6、 call、apply、bind 实现</a></li>
<li><a href="#7-new-实现">7、 new 实现</a></li>
<li><a href="#8-异步">8、 异步</a>
<ul>
<li><a href="#8-1-event-loop-宏任务和微任务">8.1 event loop、宏任务和微任务</a></li>
<li><a href="#8-2-promise">8.2 Promise</a></li>
<li><a href="#8-3-async-await-和-promise-的关系">8.3 async/await 和 Promise 的关系</a></li>
</ul></li>
<li><a href="#9-浏览器的垃圾回收机制">9、 浏览器的垃圾回收机制</a></li>
<li><a href="#10-实现一个-eventmitter-类">10、 实现一个 EventMitter 类</a></li>
</ul></li>
<li><a href="#四-web-存储">四、web 存储</a>
<ul>
<li><a href="#1-cookie">1、cookie</a></li>
<li><a href="#2-localstorage-和-sessionstorage">2、localStorage 和 sessionStorage</a></li>
</ul></li>
<li><a href="#五-http">五、Http</a>
<ul>
<li><a href="#1-http-状态码">1、http 状态码</a>
<ul>
<li><a href="#1-1-状态码分类">1.1 状态码分类</a></li>
<li><a href="#1-2-常见状态码">1.2 常见状态码</a></li>
<li><a href="#1-3-关于协议和规范">1.3 关于协议和规范</a></li>
</ul></li>
<li><a href="#2-http-缓存">2、http 缓存</a>
<ul>
<li><a href="#4-1-关于缓存">4.1 关于缓存</a></li>
<li><a href="#4-2-强制缓存">4.2 强制缓存</a></li>
<li><a href="#4-3-协商缓存-对比缓存">4.3 协商缓存（对比缓存）</a></li>
<li><a href="#4-4-综述">4.4 综述</a></li>
<li><a href="#4-4-三种刷新操作对-http-缓存的影响">4.4 三种刷新操作对 http 缓存的影响</a></li>
</ul></li>
<li><a href="#3-面试">3. 面试</a></li>
</ul></li>
<li><a href="#六-react">六、React</a>
<ul>
<li><a href="#1-react-事件机制-react-16-和-react-17-事件机制的不同">1、 React 事件机制，React 16 和 React 17 事件机制的不同</a></li>
<li><a href="#2-class-component">2、class component</a>
<ul>
<li><a href="#2-1-生命周期">2.1 生命周期</a></li>
<li><a href="#2-2-setstate-同步还是异步">2.2 setState 同步还是异步</a></li>
</ul></li>
<li><a href="#3-对函数式编程的理解">3、对函数式编程的理解</a></li>
<li><a href="#4-react-hooks">4、react hooks</a>
<ul>
<li><a href="#4-1-为什么不能在条件语句中写-hook">4.1 为什么不能在条件语句中写 hook</a></li>
<li><a href="#4-2-hoc-和-hook-的区别">4.2 HOC 和 hook 的区别</a></li>
<li><a href="#4-3-useeffect-和-uselayouteffect-区别">4.3 useEffect 和 useLayoutEffect 区别</a></li>
<li><a href="#4-4-useeffect-依赖为空数组与-componentdidmount-区别">4.4 useEffect 依赖为空数组与 componentDidMount 区别</a></li>
<li><a href="#4-5-react-memo-和-react-usememo-的区别">4.5 React.memo() 和 React.useMemo() 的区别</a></li>
<li><a href="#4-6-react-usecallback-和-react-usememo-的区别">4.6 React.useCallback() 和 React.useMemo() 的区别</a></li>
<li><a href="#4-7-react-forwardref-是什么及其作用">4.7 React.forwardRef 是什么及其作用</a></li>
</ul></li>
<li><a href="#6-react-hooks-与-class-组件对比">6、react hooks 与 class 组件对比</a></li>
<li><a href="#7-介绍-react-dom-diff-算法">7、介绍 React dom diff 算法</a></li>
<li><a href="#8-对-react-fiber-的理解">8、对 React Fiber 的理解</a></li>
<li><a href="#9-react-性能优化手段">9、React 性能优化手段</a></li>
<li><a href="#10-react-redux">10、React Redux</a></li>
</ul></li>
<li><a href="#七-webpack">七、webpack</a></li>
<li><a href="#八-模块化">八、模块化</a></li>
<li><a href="#九-性能优化">九、性能优化</a></li>
<li><a href="#十-常见手写">十、常见手写</a>
<ul>
<li><a href="#1-防抖">1、防抖</a></li>
<li><a href="#2-节流">2、节流</a></li>
<li><a href="#3-快速排序">3、快速排序</a></li>
<li><a href="#4-instanceof">4、instanceof</a></li>
<li><a href="#5-数组扁平化">5、数组扁平化</a></li>
<li><a href="#6-手写-reduce">6、手写 reduce</a></li>
<li><a href="#7-带并发的异步调度器-scheduler">7、带并发的异步调度器 Scheduler</a></li>
<li><a href="#8-去重">8、去重</a></li>
</ul></li>
<li><a href="#十一-其它">十一、其它</a></li>
<li><a href="#十二-算法">十二、算法</a></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">前端知识点大全</h1>
        </header>
        <date class="post-meta meta-date">
            2022年6月17日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="一-简历">一、简历</h2>

<p>简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。</p>

<h3 id="1-重点">1、重点</h3>

<ul>
<li>简历就像高考作文——阅卷时间非常短。</li>
<li>内容要简洁。</li>
<li>直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。</li>
</ul>

<h3 id="2-简历包含的内容">2、简历包含的内容</h3>

<ul>
<li>个人信息。</li>
<li>专业技能。</li>
<li>工作经历。</li>
<li>项目经历。</li>
<li>社区贡献。</li>
</ul>

<h4 id="2-1-基本信息">2.1 基本信息</h4>

<ul>
<li>必备：姓名 电话 邮箱。</li>
<li>年龄（最好写上，在这个行业年龄还是比较重要的），学历（写好是哪一届）。</li>
<li>头像无所谓（好看就放上呗）。</li>
<li>可以放 github 链接，前提是有内容。</li>
</ul>

<h4 id="2-2-专业技能">2.2 专业技能</h4>

<ul>
<li>表现出自己的核心竞争力（只要是符合招人单位要求的都是优势）。</li>
<li>内容不要太多，3、5 条即可。</li>
<li>太基础的不要写，例如会用 vscode、lodash。</li>
</ul>

<h4 id="2-3-工作经历">2.3 工作经历</h4>

<ul>
<li>如实写。</li>
<li>写明公司，职位，入职离职时间即可，多写无益。</li>
<li>如果有空窗期，如实写明即可。</li>
</ul>

<h4 id="2-4-项目经历">2.4 项目经历</h4>

<ul>
<li>写 2-4 个具有说服力的项目（不要什么项目都写，没用）。</li>
<li>项目名称，项目描述，技术栈，个人角色。</li>
</ul>

<h4 id="2-5-社区贡献">2.5 社区贡献</h4>

<ul>
<li>有博客或者开源作品，会让你更有竞争力。</li>
<li>切记：需要真的有内容，不可临时抱佛脚。</li>
</ul>

<h3 id="3-注意事项">3、注意事项</h3>

<ul>
<li>界面不能太花哨，简洁明了即可。</li>
<li>注意用词，“精通”“熟练”等慎用，可用“熟悉”。</li>
<li>不可造假，会被拉入黑名单。</li>
</ul>

<h3 id="4-面试前准备">4、面试前准备</h3>

<ul>
<li>看 JD，是否需要临时准备一下。</li>
<li>打印纸质简历，带着纸和笔（增加好印象）。</li>
<li>最好带着自己电脑，现场可能手写代码（带一个帆布包最适合，又优雅又方便）。</li>
<li>要有时间观念，如果迟到或者推迟，要提前说。</li>
<li>衣着适当，不用正装，也不要太随意。</li>
<li>为何离职？—— 不要吐槽前东家，说自己的原因（想找一个更好的发展平台等）。</li>
<li>能加班吗？—— 能！除非你特别自信，能找到其他机会。</li>
<li>不要挑战面试官，即便他错了（面试一定要保证愉快）。</li>
<li>遇到不会的问题，要表现出自己积极的一面（不好意思哈，确实是我的知识盲区，可以跟我说下 xxx 吗，我回去研究一下）。</li>
</ul>

<h2 id="二-html-css-面试题">二、HTML+CSS 面试题</h2>

<p>HTML 和 CSS 面试题答不出来基本可以回去了。</p>

<h3 id="1-html-面试题">1、HTML 面试题</h3>

<p>以下是针对 HTML 相关的面试题，一般来说这地方不会出太多题，面试官也不愿意花太多时间在这上面。</p>

<h4 id="1-1-如何理解-html-语义化">1.1 如何理解 HTML 语义化？</h4>

<ul>
<li>让人更容易读懂（增加代码可读性）。</li>
<li>让搜索引擎更容易读懂，有助于爬虫抓取更多的有效信息，爬虫依赖于标签来确定上下文和各个关键字的权重（SEO）。</li>
<li>在没有 CSS 样式下，页面也能呈现出很好地内容结构、代码结构。</li>
</ul>

<h4 id="1-2-script-标签中-defer-和-async-的区别">1.2 script 标签中 defer 和 async 的区别？</h4>

<ul>
<li><code>script</code> ：会阻碍 HTML 解析，只有下载好并执行完脚本才会继续解析 HTML。</li>
<li><code>async script</code> ：解析 HTML 过程中进行脚本的异步下载，下载成功立马执行，有可能会阻断 HTML 的解析。</li>
<li><code>defer script</code>：完全不会阻碍 HTML 的解析，解析完成之后再按照顺序执行脚本。</li>
</ul>

<p>下图清晰地展示了三种 <code>script</code> 的过程：</p>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/image-20220617101729289.png" alt="" /></p>

<blockquote>
<p>推荐文章：</p>

<ul>
<li><a href="https://juejin.cn/post/6894629999215640583">图解 script 标签中的 async 和 defer 属性</a></li>
</ul>
</blockquote>

<h4 id="1-3-从浏览器地址栏输入-url-到请求返回发生了什么">1.3 从浏览器地址栏输入 url 到请求返回发生了什么</h4>

<p>先阅读这篇科普性质的：<a href="https://juejin.cn/post/6844903784229896199">从 URL 输入到页面展现到底发生什么？</a> 先阅读篇文章：<a href="https://juejin.cn/post/6935232082482298911">从输入 URL 开始建立前端知识体系</a>。</p>

<ol>
<li>输入 URL 后解析出协议、主机、端口、路径等信息，并构造一个 HTTP 请求。</li>
</ol>

<ul>
<li>强缓存。</li>
<li>协商缓存。</li>
</ul>

<ol>
<li><p>DNS 域名解析。（<a href="https://juejin.cn/post/6990344840181940261">字节面试被虐后，是时候搞懂 DNS 了</a>）</p></li>

<li><p>TCP 连接。</p></li>
</ol>

<blockquote>
<p>总是要问：为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点<strong>可靠传输</strong>决定的。客户端和服务端要进行可靠传输，那么就需要<strong>确认双方的接收和发送能力</strong>。第一次握手可以确认客服端的<strong>发送能力</strong>，第二次握手，确认了服务端的<strong>发送能力和接收能力</strong>，所以第三次握手才可以确认客户端的<strong>接收能力</strong>。不然容易出现丢包的现象。</p>
</blockquote>

<ol>
<li><p>http 请求。</p></li>

<li><p>服务器处理请求并返回 HTTP 报文。</p></li>

<li><p>浏览器渲染页面。</p></li>
</ol>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/77972f24d69243bb93679f155f305095~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png" /></p>

<ol>
<li>断开 TCP 连接。</li>
</ol>

<h3 id="2-css-面试题">2、CSS 面试题</h3>

<p>以下是针对 CSS 相关的面试题，这些题答不出来会给人非常不好的技术印象。</p>

<h4 id="2-1-盒模型介绍">2.1 盒模型介绍</h4>

<p>CSS3 中的盒模型有以下两种：<strong>标准盒模型</strong>、<strong>IE（替代）盒模型</strong>。</p>

<p>两种盒子模型都是由 <code>content + padding + border + margin</code> 构成，其大小都是由 <code>content + padding + border</code> 决定的，但是盒子内容宽/高度（即 <code>width/height</code>）的计算范围根据盒模型的不同会有所不同：</p>

<ul>
<li>标准盒模型：只包含 <code>content</code> 。</li>
<li>IE（替代）盒模型：<code>content + padding + border</code> 。</li>
</ul>

<p>可以通过 <code>box-sizing</code> 来改变元素的盒模型：</p>

<ul>
<li><code>box-sizing: content-box</code> ：标准盒模型（默认值）。</li>
<li><code>box-sizing: border-box</code> ：IE（替代）盒模型。</li>
</ul>

<h4 id="2-2-css-选择器和优先级">2.2 css 选择器和优先级</h4>

<p>首先我们要知道有哪些选择器：<a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FLearn%2FCSS%2FBuilding_blocks%2FSelectors%23%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%82%E8%80%83%E8%A1%A8">选择器参考表</a>。</p>

<p>常规来说，大家都知道样式的优先级一般为 <code>!important &gt; style &gt; id &gt; class</code> ，但是涉及多类选择器作用于同一个元素时候怎么判断优先级呢？相信我，你在改一些第三方库（比如 antd 😂）样式时，理解这个会帮助很大！</p>

<p>这篇文章写的非常清晰易懂，强烈推荐，看完之后就没啥问题了：<a href="https://juejin.cn/post/6844903709772611592">深入理解 CSS 选择器优先级</a>。</p>

<blockquote>
<p>上述文章中核心内容： 优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下：</p>

<ul>
<li>如果存在内联样式，那么 <code>A = 1</code>，否则 <code>A = 0</code> ；</li>
<li>B 的值等于 <code>ID选择器（#id）</code> 出现的次数；</li>
<li>C 的值等于 <code>类选择器（.class）</code> 和 <code>属性选择器（a[href=&quot;https://example.org&quot;]）</code> 和 <code>伪类（:first-child）</code> 出现的总次数；</li>
<li>D 的值等于 <code>标签选择器（h1,a,div）</code> 和 <code>伪元素（::before,::after）</code> 出现的总次数。</li>
</ul>

<p>从左至右比较，如果是样式优先级相等，取后面出现的样式。</p>
</blockquote>

<h4 id="2-3-重排-reflow-和重绘-repaint-的理解">2.3 重排（reflow）和重绘（repaint）的理解</h4>

<p>简单地总结下两者的概念：</p>

<ul>
<li>重排：无论通过什么方式影响了元素的<strong>几何信息</strong>(元素在视口内的位置和尺寸大小)，浏览器需要<strong>重新计算</strong>元素在视口内的几何属性，这个过程叫做重排。</li>
<li>重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的<strong>实际像素</strong>，这个阶段就叫做重绘。</li>
</ul>

<p>如何减少重排和重绘？</p>

<ul>
<li><strong>最小化重绘和重排</strong>，比如样式集中改变，使用添加新样式类名 <code>.class</code> 或 <code>cssText</code> 。</li>
<li><strong>批量操作 DOM</strong>，比如读取某元素 <code>offsetWidth</code> 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 <code>document.createDocumentFragment()</code> 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。</li>
<li><strong>使用 *<em><code>\*\*absolute\*\*</code>*</em> 或 *<em><code>\*\*fixed\*\*</code>*</em> 使元素脱离文档流</strong>，这在制作复杂的动画时对性能的影响比较明显。</li>
<li><strong>开启 GPU 加速</strong>，利用 css 属性 <code>transform</code> 、<code>will-change</code> 等，比如改变元素位置，我们使用 <code>translate</code> 会比使用绝对定位改变其 <code>left</code> 、<code>top</code> 等来的高效，因为它不会触发重排或重绘，<code>transform</code> 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。</li>
</ul>

<p>这里推荐<strong>腾讯 IVWEB 团队</strong>的这篇文章：<a href="https://juejin.cn/post/6844903779700047885">你真的了解回流和重绘吗</a>，好好认真看完，面试应该没问题的。</p>

<h4 id="2-4-对-bfc-的理解">2.4 对 BFC 的理解</h4>

<p>BFC 即块级格式上下文，根据盒模型可知，每个元素都被定义为一个矩形盒子，然而盒子的布局会受到<strong>尺寸，定位，盒子的子元素或兄弟元素，视口的尺寸</strong>等因素决定，所以这里有一个浏览器计算的过程，计算的规则就是由一个叫做<strong>视觉格式化模型</strong>的东西所定义的，BFC 就是来自这个概念，它是 CSS 视觉渲染的一部分，<strong>用于决定块级盒的布局及浮动相互影响范围的一个区域</strong>。</p>

<p>BFC 具有一些特性：</p>

<ol>
<li>块级元素会在垂直方向一个接一个的排列，和文档流的排列方式一致。</li>
<li>在 BFC 中上下相邻的两个容器的 <code>margin</code> 会重叠，创建新的 BFC 可以避免外边距重叠。</li>
<li>计算 BFC 的高度时，需要计算浮动元素的高度。</li>
<li>BFC 区域不会与浮动的容器发生重叠。</li>
<li>BFC 是独立的容器，容器内部元素不会影响外部元素。</li>
<li>每个元素的左 <code>margin</code> 值和容器的左 <code>border</code> 相接触。</li>
</ol>

<p>利用这些特性，我们可以解决以下问题：</p>

<ul>
<li>利用 <code>4</code> 和 <code>6</code> ，我们可以实现三栏（或两栏）自适应布局。</li>
<li>利用 <code>2</code> ，我们可以避免 <code>margin</code> 重叠问题。</li>
<li>利用 <code>3</code> ，我们可以避免高度塌陷。</li>
</ul>

<p>创建 BFC 的方式：</p>

<ul>
<li>绝对定位元素（<code>position</code> 为 <code>absolute</code> 或 <code>fixed</code> ）。</li>
<li>行内块元素，即 <code>display</code> 为 <code>inline-block</code> 。</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 。</li>
</ul>

<p>推荐文章：<a href="https://juejin.cn/post/6960866014384881671">可能是最好的 BFC 解析了&hellip;</a></p>

<h4 id="2-5-实现两栏布局-左侧固定-右侧自适应布局">2.5 实现两栏布局（左侧固定 + 右侧自适应布局）</h4>

<p>现在有以下 DOM 结构：</p>

<pre><code class="language-html">&lt;div class=&quot;outer&quot;&gt;
  &lt;div class=&quot;left&quot;&gt;左侧&lt;/div&gt;
  &lt;div class=&quot;right&quot;&gt;右侧&lt;/div&gt;
&lt;/div&gt;

</code></pre>

<ol>
<li><p>利用浮动，左边元素宽度固定 ，设置向左浮动。将右边元素的 <code>margin-left</code> 设为固定宽度 。注意，因为右边元素的 <code>width</code> 默认为 <code>auto</code> ，所以会自动撑满父元素。</p>

<pre><code class="language-css">.outer {
height: 100px;
}
.left {
float: left;
width: 200px;
height: 100%;
background: lightcoral;
}
.right {
margin-left: 200px;
height: 100%;
background: lightseagreen;
}

</code></pre></li>

<li><p>同样利用浮动，左边元素宽度固定 ，设置向左浮动。右侧元素设置 <code>overflow: hidden;</code> 这样右边就触发了 <code>BFC</code> ，<code>BFC</code> 的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</p>

<pre><code class="language-css">.outer {
height: 100px;
}
.left {
float: left;
width: 200px;
height: 100%;
background: lightcoral;
}
.right {
overflow: auto;
height: 100%;
background: lightseagreen;
}

</code></pre></li>

<li><p>利用 <code>flex</code> 布局，左边元素固定宽度，右边的元素设置 <code>flex: 1</code> 。</p>

<pre><code class="language-css">.outer {
display: flex;
height: 100px;
}
.left {
width: 200px;
height: 100%;
background: lightcoral;
}
.right {
flex: 1;
height: 100%;
background: lightseagreen;
}

</code></pre></li>

<li><p>利用绝对定位，父级元素设为相对定位。左边元素 <code>absolute</code> 定位，宽度固定。右边元素的 <code>margin-left</code> 的值设为左边元素的宽度值。</p>

<pre><code class="language-css">.outer {
position: relative;
height: 100px;
}
.left {
position: absolute;
width: 200px;
height: 100%;
background: lightcoral;
}
.right {
margin-left: 200px;
height: 100%;
background: lightseagreen;
}

</code></pre></li>

<li><p>利用绝对定位，父级元素设为相对定位。左边元素宽度固定，右边元素 <code>absolute</code> 定位， <code>left</code> 为宽度大小，其余方向定位为 <code>0</code> 。</p>

<pre><code class="language-css">.outer {
position: relative;
height: 100px;
}
.left {
width: 200px;
height: 100%;
background: lightcoral;
}
.right {
position: absolute;
left: 200px;
top: 0;
right: 0;
bottom: 0;
height: 100%;
background: lightseagreen;
}

</code></pre></li>
</ol>

<h4 id="2-6-实现圣杯布局和双飞翼布局-经典三分栏布局">2.6 实现圣杯布局和双飞翼布局（经典三分栏布局）</h4>

<p>圣杯布局和双飞翼布局的目的：</p>

<ul>
<li>三栏布局，中间一栏最先加载和渲染（<strong>内容最重要，这就是为什么还需要了解这种布局的原因</strong>）。</li>
<li>两侧内容固定，中间内容随着宽度自适应。</li>
<li>一般用于 PC 网页。</li>
</ul>

<p>圣杯布局和双飞翼布局的技术总结：</p>

<ul>
<li>使用 <code>float</code> 布局。</li>
<li>两侧使用 <code>margin</code> 负值，以便和中间内容横向重叠。</li>
<li>防止中间内容被两侧覆盖，圣杯布局用 <code>padding</code> ，双飞翼布局用 <code>margin</code> 。</li>
</ul>

<p><strong>圣杯布局：</strong> HTML 结构：</p>

<pre><code class="language-html">&lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt;
  &lt;p class=&quot;center&quot;&gt;我是中间&lt;/p&gt;
  &lt;p class=&quot;left&quot;&gt;我是左边&lt;/p&gt;
  &lt;p class=&quot;right&quot;&gt;我是右边&lt;/p&gt;
&lt;/div&gt;

</code></pre>

<p>CSS 样式：</p>

<pre><code class="language-css">#container {
  padding-left: 200px;
  padding-right: 150px;
  overflow: auto;
}
#container p {
  float: left;
}
.center {
  width: 100%;
  background-color: lightcoral;
}
.left {
  width: 200px;
  position: relative;
  left: -200px;
  margin-left: -100%;
  background-color: lightcyan;
}
.right {
  width: 150px;
  margin-right: -150px;
  background-color: lightgreen;
}
.clearfix:after {
  content: &quot;&quot;;
  display: table;
  clear: both;
}

</code></pre>

<p><strong>双飞翼布局：</strong> HTML 结构：</p>

<pre><code class="language-html">&lt;div id=&quot;main&quot; class=&quot;float&quot;&gt;
  &lt;div id=&quot;main-wrap&quot;&gt;main&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&quot;left&quot; class=&quot;float&quot;&gt;left&lt;/div&gt;
&lt;div id=&quot;right&quot; class=&quot;float&quot;&gt;right&lt;/div&gt;

</code></pre>

<p>CSS 样式：</p>

<pre><code class="language-css">.float {
  float: left;
}
#main {
  width: 100%;
  height: 200px;
  background-color: lightpink;
}
#main-wrap {
  margin: 0 190px 0 190px;
}
#left {
  width: 190px;
  height: 200px;
  background-color: lightsalmon;
  margin-left: -100%;
}
#right {
  width: 190px;
  height: 200px;
  background-color: lightskyblue;
  margin-left: -190px;
}

</code></pre>

<p>tips：上述代码中 <code>margin-left: -100%</code> 相对的是父元素的 <code>content</code> 宽度，即不包含 <code>paddig</code> 、 <code>border</code> 的宽度。</p>

<p>其实以上问题需要掌握 <strong>margin 负值问题</strong> 即可很好理解。</p>

<h4 id="2-7-水平垂直居中多种实现方式">2.7 水平垂直居中多种实现方式</h4>

<ol>
<li><p>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>translate</code> 来调整子元素的中心点到父元素的中心。该方法可以<strong>不定宽高</strong>。</p>

<pre><code class="language-css">.father {
position: relative;
}
.son {
position: absolute;
left: 50%;
top: 50%;
transform: translate(-50%, -50%);
}

</code></pre></li>

<li><p>利用绝对定位，子元素所有方向都为 <code>0</code> ，将 <code>margin</code> 设置为 <code>auto</code> ，由于宽高固定，对应方向实现平分，该方法必须<strong>盒子有宽高</strong>。</p>

<pre><code class="language-css">.father {
position: relative;
}
.son {
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0px;
margin: auto;
height: 100px;
width: 100px;
}

</code></pre></li>

<li><p>利用绝对定位，设置 <code>left: 50%</code> 和 <code>top: 50%</code> 现将子元素左上角移到父元素中心位置，然后再通过 <code>margin-left</code> 和 <code>margin-top</code> 以子元素自己的一半宽高进行负值赋值。该方法<strong>必须定宽高</strong>。</p>

<pre><code class="language-css">.father {
position: relative;
}
.son {
position: absolute;
left: 50%;
top: 50%;
width: 200px;
height: 200px;
margin-left: -100px;
margin-top: -100px;
}

</code></pre></li>

<li><p>利用 <code>flex</code> ，最经典最方便的一种了，不用解释，定不定宽高无所谓的。</p>

<pre><code class="language-css">.father {
display: flex;
justify-content: center;
align-items: center;
}

</code></pre></li>
</ol>

<p>其实还有很多方法，比如 <code>display: grid</code> 或 <code>display: table-cell</code> 来做，有兴趣点击下面这篇文章可以了解下：
 <a href="https://juejin.cn/post/6844903982960214029">面试官：你能实现多少种水平垂直居中的布局（定宽高和不定宽高）</a>。</p>

<h4 id="2-8-flex-布局">2.8 flex 布局</h4>

<p>这一块内容看 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html">Flex 布局教程</a> 就够了。</p>

<p>这里有个小问题，很多时候我们会用到 <code>flex: 1</code> ，它具体包含了以下的意思：</p>

<ul>
<li><code>flex-grow: 1</code> ：该属性默认为 <code>0</code> ，如果存在剩余空间，元素也不放大。设置为 <code>1</code> 代表会放大。</li>
<li><code>flex-shrink: 1</code> ：该属性默认为 <code>1</code> ，如果空间不足，元素缩小。</li>
<li><code>flex-basis: 0%</code> ：该属性定义在分配多余空间之前，元素占据的主轴空间。浏览器就是根据这个属性来<strong>计算是否有多余空间</strong>的。默认值为 <code>auto</code> ，即项目本身大小。设置为 <code>0%</code> 之后，因为有 <code>flex-grow</code> 和 <code>flex-shrink</code> 的设置会自动放大或缩小。在做两栏布局时，如果右边的自适应元素 <code>flex-basis</code> 设为 <code>auto</code> 的话，其本身大小将会是 <code>0</code> 。</li>
</ul>

<h4 id="2-9-line-height-如何继承">2.9 line-height 如何继承？</h4>

<ul>
<li>父元素的 <code>line-height</code> 写了<strong>具体数值</strong>，比如 <code>30px</code>，则子元素 <code>line-height</code> 继承该值。</li>
<li>父元素的 <code>line-height</code> 写了<strong>比例</strong>，比如 <code>1.5 或 2</code>，则子元素 <code>line-height</code> 也是继承该比例。</li>
<li>父元素的 <code>line-height</code> 写了<strong>百分比</strong>，比如 <code>200%</code>，则子元素 <code>line-height</code> 继承的是父元素 <code>font-size * 200%</code> 计算出来的值。</li>
</ul>

<h2 id="三-js-基础">三、js 基础</h2>

<p>js 的考察其实来回就那些东西，不过就我自己而已学习的时候理解是真的理解了，但是忘也确实会忘（大家都说理解了一定不会忘，但是要答全的话还是需要理解+背）。</p>

<h3 id="1-数据类型">1、数据类型</h3>

<p>以下是比较重要的几个 js 变量要掌握的点。</p>

<h4 id="1-1-基本的数据类型介绍-及值类型和引用类型的理解">1.1 基本的数据类型介绍，及值类型和引用类型的理解</h4>

<p>在 JS 中共有 <code>8</code> 种基础的数据类型，分别为： <code>Undefined</code> 、 <code>Null</code> 、 <code>Boolean</code> 、 <code>Number</code> 、 <code>String</code> 、 <code>Object</code> 、 <code>Symbol</code> 、 <code>BigInt</code> 。</p>

<p>其中 <code>Symbol</code> 和 <code>BigInt</code> 是 ES6 新增的数据类型，可能会被单独问：</p>

<ul>
<li>Symbol 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li>
<li>BigInt 可以表示任意大小的整数。</li>
</ul>

<p><strong>值类型的赋值变动过程如下：</strong></p>

<pre><code class="language-javascript">let a = 100;
let b = a;
a = 200;
console.log(b); // 100

</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/55df6cb63d3346be9ec1f572a1514853~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 1.png" /> 值类型是直接存储在<strong>栈（stack）</strong>中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p>

<p><strong>引用类型的赋值变动过程如下：</strong></p>

<pre><code class="language-javascript">let a = { age: 20 };
let b = a;
b.age = 30;
console.log(a.age); // 30

</code></pre>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/56c5c43d1c584ed4b8e4cce8855bab52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 2.png" /> 引用类型存储在<strong>堆（heap）</strong>中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；</p>

<h4 id="1-2-数据类型的判断">1.2 数据类型的判断</h4>

<ul>
<li><p><strong>typeof</strong>：能判断所有<strong>值类型，函数</strong>。不可对 <strong>null、对象、数组</strong>进行精确判断，因为都返回 <code>object</code> 。</p>

<pre><code class="language-javascript">console.log(typeof undefined); // undefined
console.log(typeof 2); // number
console.log(typeof true); // boolean
console.log(typeof &quot;str&quot;); // string
console.log(typeof Symbol(&quot;foo&quot;)); // symbol
console.log(typeof 2172141653n); // bigint
console.log(typeof function () {}); // function
// 不能判别
console.log(typeof []); // object
console.log(typeof {}); // object
console.log(typeof null); // object

</code></pre></li>

<li><p><strong>instanceof</strong>：能判断<strong>对象</strong>类型，不能判断基本数据类型，<strong>其内部运行机制是判断在其原型链中能否找到该类型的原型</strong>。比如考虑以下代码：</p>

<pre><code class="language-javascript">class People {}
class Student extends People {}

const vortesnail = new Student();

console.log(vortesnail instanceof People); // true
console.log(vortesnail instanceof Student); // true

</code></pre></li>
</ul>

<p>其实现就是顺着<strong>原型链</strong>去找，如果能找到对应的 <code>Xxxxx.prototype</code> 即为 <code>true</code> 。比如这里的 <code>vortesnail</code> 作为实例，顺着原型链能找到 <code>Student.prototype</code> 及 <code>People.prototype</code> ，所以都为 <code>true</code> 。</p>

<ul>
<li><p><strong>Object.prototype.toString.call()</strong>：所有原始数据类型都是能判断的，还有 <strong>Error 对象，Date 对象</strong>等。</p>

<pre><code class="language-javascript">Object.prototype.toString.call(2); // &quot;[object Number]&quot;
Object.prototype.toString.call(&quot;&quot;); // &quot;[object String]&quot;
Object.prototype.toString.call(true); // &quot;[object Boolean]&quot;
Object.prototype.toString.call(undefined); // &quot;[object Undefined]&quot;
Object.prototype.toString.call(null); // &quot;[object Null]&quot;
Object.prototype.toString.call(Math); // &quot;[object Math]&quot;
Object.prototype.toString.call({}); // &quot;[object Object]&quot;
Object.prototype.toString.call([]); // &quot;[object Array]&quot;
Object.prototype.toString.call(function () {}); // &quot;[object Function]&quot;

</code></pre></li>
</ul>

<p>在面试中有一个经常被问的问题就是：如何判断变量是否为数组？</p>

<pre><code class="language-javascript">Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // &quot;[object Array]&quot;

</code></pre>

<h4 id="1-3-手写深拷贝">1.3 手写深拷贝</h4>

<p>这个题一定要会啊！笔者面试过程中疯狂被问到！</p>

<p>文章推荐：<a href="https://juejin.cn/post/6844903929705136141">如何写出一个惊艳面试官的深拷贝?</a></p>

<pre><code class="language-javascript">/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 * @param {Map} map 用于存储循环引用对象的地址
 */

function deepClone(obj = {}, map = new Map()) {
  if (typeof obj !== &quot;object&quot;) {
    return obj;
  }
  if (map.get(obj)) {
    return map.get(obj);
  }

  let result = {};
  // 初始化返回结果
  if (
    obj instanceof Array ||
    // 加 || 的原因是为了防止 Array 的 prototype 被重写，Array.isArray 也是如此
    Object.prototype.toString(obj) === &quot;[object Array]&quot;
  ) {
    result = [];
  }
  // 防止循环引用
  map.set(obj, result);
  for (const key in obj) {
    // 保证 key 不是原型属性
    if (obj.hasOwnProperty(key)) {
      // 递归调用
      result[key] = deepClone(obj[key], map);
    }
  }

  // 返回结果
  return result;
}

</code></pre>

<h4 id="1-4-根据-0-1-0-2-0-3-讲讲-ieee-754-如何让其相等">1.4 根据 0.1+0.2 ! == 0.3，讲讲 IEEE 754 ，如何让其相等？</h4>

<p>建议先阅读这篇文章了解 IEEE 754 ：<a href="https://juejin.cn/post/6940405970954616839">硬核基础二进制篇（一）0.1 + 0.2 != 0.3 和 IEEE-754 标准</a>。 再阅读这篇文章了解如何运算：<a href="https://juejin.cn/post/6844903680362151950">0.1 + 0.2 不等于 0.3？为什么 JavaScript 有这种“骚”操作？</a>。</p>

<p>原因总结：</p>

<ul>
<li><code>进制转换</code> ：js 在做数字计算的时候，0.1 和 0.2 都会被转成二进制后无限循环 ，但是 js 采用的 IEEE 754 二进制浮点运算，最大可以存储 53 位有效数字，于是大于 53 位后面的会全部截掉，将导致精度丢失。</li>
<li><code>对阶运算</code> ：由于指数位数不相同，运算时需要对阶运算，阶小的尾数要根据阶差来右移（<code>0舍1入</code>），尾数位移时可能会发生数丢失的情况，影响精度。</li>
</ul>

<p>解决办法：</p>

<ol>
<li><p>转为整数（大数）运算。</p>

<pre><code class="language-javascript">function add(a, b) {
const maxLen = Math.max(
a.toString().split(&quot;.&quot;)[1].length,
b.toString().split(&quot;.&quot;)[1].length
);
const base = 10 ** maxLen;
const bigA = BigInt(base * a);
const bigB = BigInt(base * b);
const bigRes = (bigA + bigB) / BigInt(base); // 如果是 (1n + 2n) / 10n 是等于 0n的。。。
return Number(bigRes);
}

</code></pre></li>
</ol>

<p>这里代码是有问题的，因为最后计算 <code>bigRes</code> 的大数相除（即 <code>/</code>）是会把小数部分截掉的，所以我很疑惑为什么网络上很多文章都说可以通过<strong>先转为整数运算再除回去，为了防止转为的整数超出 js 表示范围，还可以运用到 ES6 新增的大数类型，我真的很疑惑，希望有好心人能解答下。</strong></p>

<ol>
<li><p>使用 <code>Number.EPSILON</code> 误差范围。</p>

<pre><code class="language-javascript">function isEqual(a, b) {
return Math.abs(a - b) &lt; Number.EPSILON;
}

console.log(isEqual(0.1 + 0.2, 0.3)); // true

</code></pre></li>
</ol>

<p><code>Number.EPSILON</code> 的实质是一个可以接受的最小误差范围，一般来说为 <code>Math.pow(2, -52)</code> 。</p>

<ol>
<li><p>转成字符串，对字符串做加法运算。</p>

<pre><code class="language-javascript">// 字符串数字相加
var addStrings = function (num1, num2) {
let i = num1.length - 1;
let j = num2.length - 1;
const res = [];
let carry = 0;
while (i &gt;= 0 || j &gt;= 0) {
const n1 = i &gt;= 0 ? Number(num1[i]) : 0;
const n2 = j &gt;= 0 ? Number(num2[j]) : 0;
const sum = n1 + n2 + carry;
res.unshift(sum % 10);
carry = Math.floor(sum / 10);
i--;
j--;
}
if (carry) {
res.unshift(carry);
}
return res.join(&quot;&quot;);
};

function isEqual(a, b, sum) {
const [intStr1, deciStr1] = a.toString().split(&quot;.&quot;);
const [intStr2, deciStr2] = b.toString().split(&quot;.&quot;);
const inteSum = addStrings(intStr1, intStr2); // 获取整数相加部分
const deciSum = addStrings(deciStr1, deciStr2); // 获取小数相加部分
return inteSum + &quot;.&quot; + deciSum === String(sum);
}

console.log(isEqual(0.1, 0.2, 0.3)); // true

</code></pre></li>
</ol>

<p>这是 leetcode 上一道原题：<a href="https://link.juejin.cn?target=https%3A%2F%2Fleetcode-cn.com%2Fproblems%2Fadd-strings%2F">415. 字符串相加</a>。区别在于原题没有考虑小数，但是也是很简单的，我们分为两个部分计算就行。</p>

<h3 id="2-原型和原型链">2、 原型和原型链</h3>

<p>可以说这部分每家面试官都会问了。。首先理解的话，其实一张图即可，一段代码即可。</p>

<pre><code class="language-javascript">function Foo() {}

let f1 = new Foo();
let f2 = new Foo();

</code></pre>

<p>千万别畏惧下面这张图，特别有用，一定要搞懂，熟到提笔就能默画出来。 <img src="https://cdn.jsdelivr.net/gh/zshipu/images/4a61ca07672a45d3aecf382100cc9719~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png" /></p>

<p>总结：</p>

<ul>
<li>原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&rdquo;继承&rdquo;属性，其实就是 <code>prototype</code> 对象。</li>
<li>原型链：由相互关联的原型组成的<strong>链状结构</strong>就是原型链。</li>
</ul>

<p>先说出总结的话，再举例子说明如何顺着原型链找到某个属性。</p>

<p>推荐的阅读：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2Fblog%2Fissues%2F2">JavaScript 深入之从原型到原型链</a> 掌握基本概念，再阅读这篇文章<a href="https://juejin.cn/post/6844903989088092174">轻松理解 JS 原型原型链</a>加深上图的印象。</p>

<h3 id="3-作用域与作用域链">3、 作用域与作用域链</h3>

<ul>
<li>作用域：规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。换句话说，作用域决定了代码区块中变量和其他资源的可见性。（全局作用域、函数作用域、块级作用域）</li>
<li>作用域链：从当前作用域开始一层层往上找某个变量，如果找到全局作用域还没找到，就放弃寻找 。这种层级关系就是作用域链。（由多个执行上下文的<strong>变量对象</strong>构成的链表就叫做作用域链，学习下面的内容之后再考虑这句话）</li>
</ul>

<p><strong>需要注意的是，js 采用的是静态作用域，所以函数的作用域在函数定义时就确定了。</strong></p>

<p>推荐阅读：先阅读<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F3">JavaScript 深入之词法作用域和动态作用域</a>，再阅读<a href="https://juejin.cn/post/6844903797135769614">深入理解 JavaScript 作用域和作用域链</a>。</p>

<h3 id="4-执行上下文">4、 执行上下文</h3>

<p>这部分一定要按顺序连续读这几篇文章，必须多读几遍：</p>

<ul>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F4">JavaScript 深入之执行上下文栈</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F5">JavaScript 深入之变量对象</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F6">JavaScript 深入之作用域链</a>；</li>
<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F8">JavaScript 深入之执行上下文</a>。</li>
</ul>

<p>总结：当 JavaScript 代码执行一段可执行代码时，会创建对应的执行上下文。对于每个执行上下文，都有三个重要属性：</p>

<ul>
<li>变量对象（Variable object，VO）；</li>
<li>作用域链（Scope chain）；</li>
<li>this。（关于 this 指向问题，在上面推荐的深入系列也有讲从 ES 规范讲的，但是实在是难懂，对于应付面试来说以下这篇阮一峰的文章应该就可以了：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2018%2F06%2Fjavascript-this.html">JavaScript 的 this 原理</a>）</li>
</ul>

<h3 id="5-闭包">5、 闭包</h3>

<p>根据 MDN 中文的定义，闭包的定义如下：</p>

<blockquote>
<p>在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来。可以在一个内层函数中访问到其外层函数的作用域。</p>
</blockquote>

<p>也可以这样说：</p>

<blockquote>
<p>闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是<strong>函数参数</strong>也不是<strong>函数的局部变量</strong>的<strong>变量</strong>。 闭包 = 函数 + 函数能够访问的自由变量。</p>
</blockquote>

<p>在经过上一小节“执行上下文”的学习，再来阅读这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F9">JavaScript 深入之闭包</a>，你会对闭包的实质有一定的了解。在回答时，我们这样答：</p>

<p>在某个内部函数的执行上下文创建时，会将父级函数的<strong>活动对象</strong>加到内部函数的 <code>[[scope]]</code> 中，形成作用域链，所以即使父级函数的执行上下文销毁（即执行上下文栈弹出父级函数的执行上下文），但是因为其<strong>活动对象</strong>还是实际存储在内存中可被内部函数访问到的，从而实现了闭包。</p>

<p>闭包应用： 函数作为参数被传递：</p>

<pre><code class="language-javascript">function print(fn) {
  const a = 200;
  fn();
}

const a = 100;
function fn() {
  console.log(a);
}

print(fn); // 100

</code></pre>

<p>函数作为返回值被返回：</p>

<pre><code class="language-javascript">function create() {
  const a = 100;

  return function () {
    console.log(a);
  };
}

const fn = create();
const a = 200;
fn(); // 100

</code></pre>

<p><strong>闭包：自由变量的查找，是在函数定义的地方，向上级作用域查找。不是在执行的地方。</strong> ****</p>

<p>应用实例：比如缓存工具，隐藏数据，只提供 API 。</p>

<pre><code class="language-javascript">function createCache() {
  const data = {}; // 闭包中被隐藏的数据，不被外界访问
  return {
    set: function (key, val) {
      data[key] = val;
    },
    get: function (key) {
      return data[key];
    },
  };
}

const c = createCache();
c.set(&quot;a&quot;, 100);
console.log(c.get(&quot;a&quot;)); // 100

</code></pre>

<h3 id="6-call-apply-bind-实现">6、 call、apply、bind 实现</h3>

<p>这部分实现还是要知道的，就算工作中不会自己手写，但是说不准面试官就是要问，知道点原理也好，可以扩宽我们写代码的思路。</p>

<p><strong>call</strong></p>

<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>

<p>举个例子：</p>

<pre><code class="language-javascript">var obj = {
  value: &quot;vortesnail&quot;,
};

function fn() {
  console.log(this.value);
}

fn.call(obj); // vortesnail

</code></pre>

<p>通过 <code>call</code> 方法我们做到了以下两点：</p>

<ul>
<li><code>call</code> 改变了 this 的指向，指向到 <code>obj</code> 。</li>
<li><code>fn</code> 函数执行了。</li>
</ul>

<p>那么如果我们自己写 <code>call</code> 方法的话，可以怎么做呢？我们先考虑改造 <code>obj</code> 。</p>

<pre><code class="language-javascript">var obj = {
  value: &quot;vortesnail&quot;,
  fn: function () {
    console.log(this.value);
  },
};

obj.fn(); // vortesnail

</code></pre>

<p>这时候 this 就指向了 <code>obj</code> ，但是这样做我们手动给 <code>obj</code> 增加了一个 <code>fn</code> 属性，这显然是不行的，不用担心，我们执行完再使用对象属性的删除方法（delete）不就行了？</p>

<pre><code class="language-javascript">obj.fn = fn;
obj.fn();
delete obj.fn;

</code></pre>

<p>根据这个思路，我们就可以写出来了：</p>

<pre><code class="language-javascript">Function.prototype.myCall = function (context) {
  // 判断调用对象
  if (typeof this !== &quot;function&quot;) {
    throw new Error(&quot;Type error&quot;);
  }
  // 首先获取参数
  let args = [...arguments].slice(1);
  let result = null;
  // 判断 context 是否传入，如果没有传就设置为 window
  context = context || window;
  // 将被调用的方法设置为 context 的属性
  // this 即为我们要调用的方法
  context.fn = this;
  // 执行要被调用的方法
  result = context.fn(...args);
  // 删除手动增加的属性方法
  delete context.fn;
  // 将执行结果返回
  return result;
};

</code></pre>

<p><strong>apply</strong></p>

<p>我们会了 <code>call</code> 的实现之后，<code>apply</code> 就变得很简单了，他们没有任何区别，除了传参方式。</p>

<pre><code class="language-javascript">Function.prototype.myApply = function (context) {
  if (typeof this !== &quot;function&quot;) {
    throw new Error(&quot;Type error&quot;);
  }
  let result = null;
  context = context || window;
  // 与上面代码相比，我们使用 Symbol 来保证属性唯一
  // 也就是保证不会重写用户自己原来定义在 context 中的同名属性
  const fnSymbol = Symbol();
  context[fnSymbol] = this;
  // 执行要被调用的方法
  if (arguments[1]) {
    result = context[fnSymbol](...arguments[1]);
  } else {
    result = context[fnSymbol]();
  }
  delete context[fnSymbol];
  return result;
};

</code></pre>

<p><strong>bind</strong></p>

<p><code>bind</code> 返回的是一个函数，这个地方可以详细阅读这篇文章，讲的非常清楚：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsisterAn%2FJavaScript-Algorithms%2Fissues%2F81">解析 bind 原理，并手写 bind 实现</a>。</p>

<pre><code class="language-javascript">Function.prototype.myBind = function (context) {
  // 判断调用对象是否为函数
  if (typeof this !== &quot;function&quot;) {
    throw new Error(&quot;Type error&quot;);
  }
  // 获取参数
  const args = [...arguments].slice(1),
  const fn = this;
  return function Fn() {
    return fn.apply(
      this instanceof Fn ? this : context,
      // 当前的这个 arguments 是指 Fn 的参数
      args.concat(...arguments)
    );
  };
};

</code></pre>

<h3 id="7-new-实现">7、 new 实现</h3>

<ol>
<li>首先创一个新的空对象。</li>
<li>根据原型链，设置空对象的 <code>__proto__</code> 为构造函数的 <code>prototype</code> 。</li>
<li>构造函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）。</li>

<li><p>判断函数的返回值类型，如果是引用类型，就返回这个引用类型的对象。</p>

<pre><code class="language-javascript">function myNew(context) {
const obj = new Object();
obj.__proto__ = context.prototype;
const res = context.apply(obj, [...arguments].slice(1));
return typeof res === &quot;object&quot; ? res : obj;
}

</code></pre></li>
</ol>

<h3 id="8-异步">8、 异步</h3>

<p>这部分着重要理解 Promise、async awiat、event loop 等。</p>

<h4 id="8-1-event-loop-宏任务和微任务">8.1 event loop、宏任务和微任务</h4>

<p>首先推荐一个可以在线看代码流程的网站：<a href="https://link.juejin.cn?target=http%3A%2F%2Flatentflip.com%2Floupe%2F%3Fcode%3DJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D">loupe</a>。 然后看下这个视频学习下：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1oV411k7XY%2F%3Fspm_id_from%3D333.788.recommend_more_video.-1">到底什么是 Event Loop 呢？</a></p>

<p>简单的例子：</p>

<pre><code class="language-javascript">console.log(&quot;Hi&quot;);

setTimeout(function cb() {
  console.log(&quot;cb&quot;); // cb 即 callback
}, 5000);

console.log(&quot;Bye&quot;);

</code></pre>

<p>它的执行过程是这样的： <img src="https://cdn.jsdelivr.net/gh/zshipu/images/1e15fc609aa84eac973c5b8ff163c11c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="屏幕录制 2021-07-19 15.01.09.gif" /> Web APIs 会创建对应的线程，比如 <code>setTimeout</code> 会创建定时器线程，<code>ajax</code> 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。</p>

<p>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到<strong>宏任务</strong>和<strong>微任务</strong>，我们还得拜读一下这篇文章：<a href="https://juejin.cn/post/6844903512845860872">这一次，彻底弄懂 JavaScript 执行机制</a>。如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://juejin.cn/post/6969028296893792286#comment">做一些动图，学习一下 EventLoop</a>。想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://juejin.cn/post/6844904165462769678">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a>。</p>

<p><strong>注意：1.Call Stack 调用栈空闲 -&gt; 2.尝试 DOM 渲染 -&gt; 触发 Event loop</strong>。</p>

<ul>
<li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li>
<li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li>
<li>然后再去触发下一次 Event loop。</li>
</ul>

<p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async/await。</p>

<p>两者区别：</p>

<ul>
<li>宏任务：DOM 渲染后触发，如 <code>setTimeout</code> 、<code>setInterval</code> 、<code>DOM 事件</code> 、<code>script</code> 。</li>
<li>微任务：DOM 渲染前触发，如 <code>Promise.then</code> 、<code>MutationObserver</code> 、Node 环境下的 <code>process.nextTick</code> 。</li>
</ul>

<p><strong>从 event loop 解释，为何微任务执行更早？</strong></p>

<ul>
<li>微任务是 ES6 语法规定的（被压入 micro task queue）。</li>
<li>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</li>
<li>宏任务执行时间一般比较长。</li>
<li>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</li>
</ul>

<h4 id="8-2-promise">8.2 Promise</h4>

<p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。</p>

<blockquote>
<p>关于 Promise 的所有使用方式，可参照这篇文章：<a href="https://link.juejin.cn?target=https%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise">ECMAScript 6 入门 - Promise 对象</a>。 手写 Promise 源码的解析文章，可阅读此篇文章：<a href="https://juejin.cn/post/6945319439772434469#heading-0">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节</a>。 关于 Promise 的面试题，可参考这篇文章：<a href="https://juejin.cn/post/6844904077537574919">要就来 45 道 Promise 面试题一次爽到底</a>。</p>
</blockquote>

<p>实现一个 Promise.all：</p>

<pre><code class="language-javascript">Promise.all = function (promises) {
  return new Promise((resolve, reject) =&gt; {
    // 参数可以不是数组，但必须具有 Iterator 接口
    if (typeof promises[Symbol.iterator] !== &quot;function&quot;) {
      reject(&quot;Type error&quot;);
    }
    if (promises.length === 0) {
      resolve([]);
    } else {
      const res = [];
      let count = 0;
      const len = promises.length;
      for (let i = 0; i &lt; len; i++) {
        //考虑到 promises[i] 可能是 thenable 对象也可能是普通值
        Promise.resolve(promises[i])
          .then((data) =&gt; {
            res[i] = data;
            if (++count === len) {
              resolve(res);
            }
          })
          .catch((err) =&gt; {
            reject(err);
          });
      }
    }
  });
};

</code></pre>

<h4 id="8-3-async-await-和-promise-的关系">8.3 async/await 和 Promise 的关系</h4>

<ul>
<li>async/await 是消灭异步回调的终极武器。</li>
<li>但和 Promise 并不互斥，反而，两者相辅相成。</li>
<li>执行 async 函数，返回的一定是 Promise 对象。</li>
<li>await 相当于 Promise 的 then。</li>
<li>tru&hellip;catch 可捕获异常，代替了 Promise 的 catch。</li>
</ul>

<h3 id="9-浏览器的垃圾回收机制">9、 浏览器的垃圾回收机制</h3>

<p>这里看这篇文章即可：<a href="https://juejin.cn/post/6981588276356317214">「硬核 JS」你真的了解垃圾回收机制吗</a>。</p>

<p>总结一下：</p>

<p>有两种垃圾回收策略：</p>

<ul>
<li><strong>标记清除</strong>：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</li>
<li><strong>引用计数</strong>：它把<strong>对象是否不再需要</strong>简化定义为<strong>对象有没有其他对象引用到它</strong>。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。</li>
</ul>

<p>标记清除的缺点：</p>

<ul>
<li><strong>内存碎片化</strong>，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。</li>
<li><strong>分配速度慢</strong>，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。</li>
</ul>

<p>解决以上的缺点可以使用 **标记整理（Mark-Compact）算法 **，标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图） <img src="https://cdn.jsdelivr.net/gh/zshipu/images/eb543f2fdc634e29add495b8f2ff048f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image.png" /></p>

<p>引用计数的缺点：</p>

<ul>
<li>需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。</li>
<li>解决不了循环引用导致的无法回收问题。</li>
</ul>

<p>V8 的垃圾回收机制也是基于标记清除算法，不过对其做了一些优化。</p>

<ul>
<li>针对新生区采用并行回收。</li>
<li>针对老生区采用增量标记与惰性回收。</li>
</ul>

<h3 id="10-实现一个-eventmitter-类">10、 实现一个 EventMitter 类</h3>

<p>EventMitter 就是发布订阅模式的典型应用：</p>

<pre><code class="language-typescript">export class EventEmitter {
  private _events: Record&lt;string, Array&lt;Function&gt;&gt;;

  constructor() {
    this._events = Object.create(null);
  }

  emit(evt: string, ...args: any[]) {
    if (!this._events[evt]) return false;

    const fns = [...this._events[evt]];
    fns.forEach((fn) =&gt; {
      fn.apply(this, args);
    });

    return true;
  }

  on(evt: string, fn: Function) {
    if (typeof fn !== &quot;function&quot;) {
      throw new TypeError(&quot;The evet-triggered callback must be a function&quot;);
    }
    if (!this._events[evt]) {
      this._events[evt] = [fn];
    } else {
      this._events[evt].push(fn);
    }
  }

  once(evt: string, fn: Function) {
    const execFn = () =&gt; {
      fn.apply(this);
      this.off(evt, execFn);
    };
    this.on(evt, execFn);
  }

  off(evt: string, fn?: Function) {
    if (!this._events[evt]) return;
    if (!fn) {
      this._events[evt] &amp;&amp; (this._events[evt].length = 0);
    }

    let cb;
    const cbLen = this._events[evt].length;
    for (let i = 0; i &lt; cbLen; i++) {
      cb = this._events[evt][i];
      if (cb === fn) {
        this._events[evt].splice(i, 1);
        break;
      }
    }
  }

  removeAllListeners(evt?: string) {
    if (evt) {
      this._events[evt] &amp;&amp; (this._events[evt].length = 0);
    } else {
      this._events = Object.create(null);
    }
  }
}

</code></pre>

<h2 id="四-web-存储">四、web 存储</h2>

<p>要掌握 cookie，localStorage 和 sessionStorage。</p>

<h3 id="1-cookie">1、cookie</h3>

<ul>
<li>本身用于浏览器和 server 通讯。</li>
<li>被“借用”到本地存储来的。</li>
<li>可用 document.cookie = &lsquo;&hellip;&rsquo; 来修改。</li>
</ul>

<p>其缺点：</p>

<ul>
<li>存储大小限制为 4KB。</li>
<li>http 请求时需要发送到服务端，增加请求数量。</li>
<li>只能用 document.cookie = &lsquo;&hellip;&rsquo; 来修改，太过简陋。</li>
</ul>

<h3 id="2-localstorage-和-sessionstorage">2、localStorage 和 sessionStorage</h3>

<ul>
<li>HTML5 专门为存储来设计的，最大可存 5M。</li>
<li>API 简单易用， setItem getItem。</li>
<li>不会随着 http 请求被发送到服务端。</li>
</ul>

<p>它们的区别：</p>

<ul>
<li>localStorage 数据会永久存储，除非代码删除或手动删除。</li>
<li>sessionStorage 数据只存在于当前会话，浏览器关闭则清空。</li>
<li>一般用 localStorage 会多一些。</li>
</ul>

<h2 id="五-http">五、Http</h2>

<p>前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。</p>

<h3 id="1-http-状态码">1、http 状态码</h3>

<h4 id="1-1-状态码分类">1.1 状态码分类</h4>

<ul>
<li>1xx - 服务器收到请求。</li>
<li>2xx - 请求成功，如 200。</li>
<li>3xx - 重定向，如 302。</li>
<li>4xx - 客户端错误，如 404。</li>
<li>5xx - 服务端错误，如 500。</li>
</ul>

<h4 id="1-2-常见状态码">1.2 常见状态码</h4>

<ul>
<li>200 - 成功。</li>
<li>301 - 永久重定向（配合 location，浏览器自动处理）。</li>
<li>302 - 临时重定向（配合 location，浏览器自动处理）。</li>
<li>304 - 资源未被修改。</li>
<li>403 - 没权限。</li>
<li>404 - 资源未找到。</li>
<li>500 - 服务器错误。</li>
<li>504 - 网关超时。</li>
</ul>

<h4 id="1-3-关于协议和规范">1.3 关于协议和规范</h4>

<ul>
<li>状态码都是约定出来的。</li>
<li>要求大家都跟着执行。</li>
<li>不要违反规范，例如 IE 浏览器。</li>
</ul>

<h3 id="2-http-缓存">2、http 缓存</h3>

<ul>
<li>关于缓存的介绍。</li>
<li>http 缓存策略（强制缓存 + 协商缓存）。</li>
<li>刷新操作方式，对缓存的影响。</li>
</ul>

<h4 id="4-1-关于缓存">4.1 关于缓存</h4>

<p>什么是缓存？ 把一些不需要重新获取的内容再重新获取一次</p>

<p>为什么需要缓存？ 网络请求相比于 CPU 的计算和页面渲染是非常非常慢的。</p>

<p>哪些资源可以被缓存？ 静态资源，比如 js css img。</p>

<h4 id="4-2-强制缓存">4.2 强制缓存</h4>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/0ff1ec224244427ba9f15abecbd668fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 1.png" /></p>

<p>Cache-Control：</p>

<ul>
<li>在 Response Headers 中。</li>
<li>控制强制缓存的逻辑。</li>
<li>例如 Cache-Control: max-age=3153600（单位是秒）</li>
</ul>

<p>Cache-Control 有哪些值：</p>

<ul>
<li>max-age：缓存最大过期时间。</li>
<li>no-cache：可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。</li>
<li>no-store：永远都不要在客户端存储资源，永远都去原始服务器去获取资源。</li>
</ul>

<h4 id="4-3-协商缓存-对比缓存">4.3 协商缓存（对比缓存）</h4>

<ul>
<li>服务端缓存策略。</li>
<li>服务端判断客户端资源，是否和服务端资源一样。</li>
<li>一致则返回 304，否则返回 200 和最新的资源。</li>
</ul>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/56e265f46c80430fbf4673878a27bfc9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 2.png" /> 资源标识：</p>

<ul>
<li>在 Response Headers 中，有两种。</li>
<li>Last-Modified：资源的最后修改时间。</li>
<li>Etag：资源的唯一标识（一个字符串，类似于人类的指纹）。</li>
</ul>

<p><strong>Last-Modified：</strong> <img src="https://cdn.jsdelivr.net/gh/zshipu/images/4c4f44afeb73464295e9878d2c47b024~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 3.png" /> 服务端拿到 if-Modified-Since 之后拿这个时间去和服务端资源最后修改时间做比较，如果一致则返回 304 ，不一致（也就是资源已经更新了）就返回 200 和新的资源及新的 Last-Modified。</p>

<p><strong>Etag：</strong> <img src="https://cdn.jsdelivr.net/gh/zshipu/images/e35285a8d23a4a4380676aeb681e815d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 4.png" /> 其实 Etag 和 Last-Modified 一样的，只不过 Etag 是服务端对资源按照一定方式（比如 contenthash）计算出来的唯一标识，就像人类指纹一样，传给客户端之后，客户端再传过来时候，服务端会将其与现在的资源计算出来的唯一标识做比较，一致则返回 304，不一致就返回 200 和新的资源及新的 Etag。</p>

<p><strong>两者比较：</strong></p>

<ul>
<li>优先使用 Etag。</li>
<li>Last-Modified 只能精确到秒级。</li>
<li>如果资源被重复生成，而内容不变，则 Etag 更精确。</li>
</ul>

<h4 id="4-4-综述">4.4 综述</h4>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/b74c746d1459403382fd0bbc1d96aeca~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="图片 5.png" /></p>

<h4 id="4-4-三种刷新操作对-http-缓存的影响">4.4 三种刷新操作对 http 缓存的影响</h4>

<ul>
<li>正常操作：地址栏输入 url，跳转链接，前进后退等。</li>
<li>手动刷新：f5，点击刷新按钮，右键菜单刷新。</li>
<li>强制刷新：ctrl + f5，shift+command+r。</li>
</ul>

<p><strong>正常操作：强制缓存有效，协商缓存有效。</strong> <strong>手动刷新：强制缓存失效，协商缓存有效。</strong> <strong>强制刷新：强制缓存失效，协商缓存失效。</strong> ****</p>

<h3 id="3-面试">3. 面试</h3>

<p><strong>对于更多面试中可能出现的问题，我还是建议精读这篇三元的文章：</strong><a href="https://juejin.cn/post/6844904100035821575">HTTP 灵魂之问，巩固你的 HTTP 知识体系</a>。</p>

<p>比如会被经常问到的： GET 和 POST 的区别。</p>

<ul>
<li>从<strong>缓存</strong>的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从<strong>编码</strong>的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。</li>
<li>从<strong>参数</strong>的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。</li>
<li>从<strong>幂等性</strong>的角度，GET 是幂等的，而 POST 不是。(幂等表示执行相同的操作，结果也是相同的)</li>
<li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包)</li>
</ul>

<p>HTTP/2 有哪些改进？（很大可能问原理）</p>

<ul>
<li>头部压缩。</li>
<li>多路复用。</li>
<li>服务器推送。</li>
</ul>

<p>关于 HTTPS 的一些原理，可以阅读这篇文章：<a href="https://juejin.cn/post/6844904038509576199">这一次，彻底理解 https 原理</a>。接着你可以观看这个视频进行更进一步的学习：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1XL411b7KZ%3Fp%3D1">HTTPS 底层原理，面试官直接下跪，唱征服！</a></p>

<p>关于<strong>跨域</strong>问题，大部分文章都是理论性比较强，还不如读这篇文章，<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F149734572%3Ffrom_voters_page%3Dtrue">聊聊跨域的原理与解决方法</a>，讲的非常清晰，我个人觉得对付面试就是先知道使用流程，把这个流程能自己说出来，然后再讲下原理即可。</p>

<h2 id="六-react">六、React</h2>

<h3 id="1-react-事件机制-react-16-和-react-17-事件机制的不同">1、 React 事件机制，React 16 和 React 17 事件机制的不同</h3>

<p>阅读这篇文章即可：<a href="https://juejin.cn/post/6955636911214067720">一文吃透 react 事件系统原理</a>。</p>

<p>为什么要自定义事件机制？</p>

<ul>
<li>抹平浏览器差异，实现更好的跨平台。</li>
<li>避免垃圾回收，React 引入事件池，在事件池中获取或释放事件对象，避免频繁地去创建和销毁。</li>
<li>方便事件统一管理和事务机制。</li>
</ul>

<h3 id="2-class-component">2、class component</h3>

<p>不排除现在还会有面试官问关于 class component 的问题。</p>

<h4 id="2-1-生命周期">2.1 生命周期</h4>

<ul>
<li>初始化阶段。</li>
</ul>

<p>发生在 <code>constructor</code> 中的内容，在 <code>constructor</code> 中进行 <code>state</code> 、<code>props</code> 的初始化，在这个阶段修改 <code>state</code>，不会执行更新阶段的生命周期，可以直接对 <code>state</code> 赋值。</p>

<ul>
<li><p>挂载阶段。</p>

<pre><code class="language-javascript">1. componentWillMount
发生在 render 函数之前，还没有挂载 Dom
2. render
3. componentDidMount
发生在 render 函数之后，已经挂载 Dom

</code></pre></li>

<li><p>更新阶段。</p></li>
</ul>

<p>更新阶段分为由 <code>state</code> 更新引起和 <code>props</code> 更新引起。</p>

<pre><code class="language-javascript">props 更新时：
1. componentWillReceiveProps(nextProps,nextState)
   这个生命周期主要为我们提供对 props 发生改变的监听，如果你需要在 props 发生改变后，相应改变组件的一些 state。在这个方法中改变 state 不会二次渲染，而是直接合并 state。
2. shouldComponentUpdate(nextProps,nextState)
   这个生命周期需要返回一个 Boolean 类型的值，判断是否需要更新渲染组件，优化 react 应用的主要手段之一，当返回 false 就不会再向下执行生命周期了，在这个阶段不可以 setState()，会导致循环调用。
3. componentWillUpdate(nextProps,nextState)
   这个生命周期主要是给我们一个时机能够处理一些在 Dom 发生更新之前的事情，如获得 Dom 更新前某些元素的坐标、大小等，在这个阶段不可以 setState()，会导致循环调用。
    **一直到这里 this.props 和 this.state 都还未发生更新**
4. render
5. componentDidUpdate(prevProps, prevState)
   在此时已经完成渲染，Dom 已经发生变化，state 已经发生更新，prevProps、prevState 均为上一个状态的值。

state 更新时（具体同上）
1. shouldComponentUpdate
2. componentWillUpdate
3. render
4. componentDidUpdate

</code></pre>

<ul>
<li><p>卸载阶段。</p>

<pre><code class="language-javascript">1. componentWillUnmount
在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount  中创建的订阅等。componentWillUnmount 中不应调用 setState，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。


</code></pre></li>
</ul>

<p>在 React 16 中官方已经建议删除以下三个方法，非要使用必须加前缀：<code>UNSAVE_</code> 。</p>

<pre><code class="language-javascript">componentWillMount;
componentWillReceiveProps;
componentWillUpdate;

</code></pre>

<p>取代这两三个生命周期的以下两个新的。</p>

<pre><code class="language-javascript">1. static getDerivedStateFromProps(nextProps,nextState)
   在组件实例化、接收到新的 props 、组件状态更新时会被调用
2. getSnapshotBeforeUpdate（prevProps,prevState）
   在这个阶段我们可以拿到上一个状态 Dom 元素的坐标、大小的等相关信息。用于替代旧的生命周期中的 componentWillUpdate。
   该函数的返回值将会作为 componentDidUpdate 的第三个参数出现。

</code></pre>

<p>需要注意的是，一般都会问为什么要废弃三个生命周期，原因是什么。</p>

<h4 id="2-2-setstate-同步还是异步">2.2 setState 同步还是异步</h4>

<p><code>setState</code> 本身代码的执行肯定是同步的，这里的异步是指是多个 state 会合成到一起进行批量更新。 同步还是异步取决于它被调用的环境。</p>

<ul>
<li>如果 <code>setState</code> 在 React 能够控制的范围被调用，它就是<strong>异步</strong>的。比如<strong>合成事件处理函数</strong>，<strong>生命周期函数</strong>， 此时会进行批量更新，也就是将状态合并后再进行 DOM 更新。</li>
<li>如果 <code>setState</code> 在原生 JavaScript 控制的范围被调用，它就是<strong>同步</strong>的。比如原生事件处理函数，定时器回调函数，Ajax 回调函数中，此时 <code>setState</code> 被调用后会立即更新 DOM 。</li>
</ul>

<h3 id="3-对函数式编程的理解">3、对函数式编程的理解</h3>

<p>这篇文章写的真的太好了，一定要读：<a href="https://juejin.cn/post/6844903936378273799">简明 JavaScript 函数式编程——入门篇</a>。</p>

<p>总结一下： 函数式编程有两个核心概念。</p>

<ul>
<li><strong>数据不可变（无副作用）：</strong> 它要求你所有的数据都是不可变的，这意味着如果你想修改一个对象，那你应该创建一个新的对象用来修改，而不是修改已有的对象。</li>
<li><strong>无状态：</strong> 主要是强调对于一个函数，不管你何时运行，它都应该像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。</li>
</ul>

<p>纯函数带来的意义。</p>

<ul>
<li><strong>便于测试和优化</strong>：这个意义在实际项目开发中意义非常大，由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。</li>
<li><strong>可缓存性</strong>：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果。</li>
<li><strong>更少的 Bug</strong>：使用纯函数意味着你的函数中<strong>不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改</strong>，这些共享状态往往是绝大多数 bug 的源头。</li>
</ul>

<h3 id="4-react-hooks">4、react hooks</h3>

<p>现在应该大多数面试官会问 hooks 相关的啦。这里我强烈推荐三篇文章，即使没看过源码，也能比较好地理解一些原理：
 <a href="https://juejin.cn/post/6844904127110053895">用动画和实战打开 React Hooks（一）：useState 和 useEffect</a>
 <a href="https://juejin.cn/post/6844904132164190221">用动画和实战打开 React Hooks（二）：自定义 Hook 和 useCallback</a>
 <a href="https://juejin.cn/post/6844904149746728973">用动画和实战打开 React Hooks（三）：useReducer 和 useContext</a></p>

<h4 id="4-1-为什么不能在条件语句中写-hook">4.1 为什么不能在条件语句中写 hook</h4>

<p>推荐这篇文章：<a href="https://juejin.cn/post/6939766434159394830">我打破了 React Hook 必须按顺序、不能在条件语句中调用的枷锁</a>。</p>

<p>hook 在每次渲染时的查找是根据一个“全局”的下标对链表进行查找的，如果放在条件语句中使用，有一定几率会造成拿到的状态出现错乱。</p>

<h4 id="4-2-hoc-和-hook-的区别">4.2 HOC 和 hook 的区别</h4>

<p>hoc 能复用<strong>逻辑和视图</strong>，hook 只能复用<strong>逻辑</strong>。</p>

<h4 id="4-3-useeffect-和-uselayouteffect-区别">4.3 useEffect 和 useLayoutEffect 区别</h4>

<p>对于 React 的函数组件来说，其更新过程大致分为以下步骤：</p>

<ol>
<li>因为某个事件 <code>state</code> 发生变化。</li>
<li>React 内部更新 <code>state</code> 变量。</li>
<li>React 处理更新组件中 return 出来的 DOM 节点（进行一系列 dom diff 、调度等流程）。</li>
<li>将更新过后的 DOM 数据绘制到浏览器中。</li>
<li>用户看到新的页面。</li>
</ol>

<p><code>useEffect</code> 在第 4 步之后执行，且是异步的，保证了不会阻塞浏览器进程。 <code>useLayoutEffect</code> 在第 3 步至第 4 步之间执行，且是同步代码，所以会阻塞后面代码的执行。</p>

<h4 id="4-4-useeffect-依赖为空数组与-componentdidmount-区别">4.4 useEffect 依赖为空数组与 componentDidMount 区别</h4>

<p>在 <code>render</code> 执行之后，<code>componentDidMount</code> 会执行，如果在这个生命周期中再一次 <code>setState</code> ，会导致再次 <code>render</code> ，返回了新的值，浏览器只会渲染第二次 <code>render</code> 返回的值，这样可以避免闪屏。</p>

<p>但是 <code>useEffect</code> 是在真实的 DOM 渲染之后才会去执行，这会造成两次 <code>render</code> ，有可能会闪屏。</p>

<p>实际上 <code>useLayoutEffect</code> 会更接近 <code>componentDidMount</code> 的表现，它们都同步执行且会阻碍真实的 DOM 渲染的。</p>

<h4 id="4-5-react-memo-和-react-usememo-的区别">4.5 React.memo() 和 React.useMemo() 的区别</h4>

<ul>
<li><code>memo</code> 是一个高阶组件，默认情况下会对 <code>props</code> 进行浅比较，如果相等不会重新渲染。多数情况下我们比较的都是引用类型，浅比较就会失效，所以我们可以传入第二个参数手动控制。</li>
<li><code>useMemo</code> 返回的是一个缓存值，只有依赖发生变化时才会去重新执行作为第一个参数的函数，需要记住的是，<code>useMemo</code> 是在 <code>render</code> 阶段执行的，所以不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴。</li>
</ul>

<h4 id="4-6-react-usecallback-和-react-usememo-的区别">4.6 React.useCallback() 和 React.useMemo() 的区别</h4>

<ul>
<li><code>useCallback</code> 可缓存函数，其实就是避免每次重新渲染后都去重新执行一个新的函数。</li>
<li><code>useMemo</code> 可缓存值。</li>
</ul>

<p>有很多时候，我们在 <code>useEffect</code> 中使用某个定义的外部函数，是要添加到 <code>deps</code> 数组中的，如果不用 <code>useCallback</code> 缓存，这个函数在每次重新渲染时都是一个完全新的函数，也就是引用地址发生了变化，这就会导致 <code>useEffect</code> 总会无意义的执行。</p>

<h4 id="4-7-react-forwardref-是什么及其作用">4.7 React.forwardRef 是什么及其作用</h4>

<p>这里还是阅读官方文档来的清晰：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzh-hans.reactjs.org%2Fdocs%2Freact-api.html%23reactforwardref">React.forwardRef</a>。 一般在父组件要拿到子组件的某个实际的 DOM 元素时会用到。</p>

<h3 id="6-react-hooks-与-class-组件对比">6、react hooks 与 class 组件对比</h3>

<p><a href="https://juejin.cn/post/6844904179136200712">react hooks 与 class 组件对比</a> <a href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fhow-are-function-components-different-from-classes%2F">函数式组件与类组件有何不同</a></p>

<h3 id="7-介绍-react-dom-diff-算法">7、介绍 React dom diff 算法</h3>

<p><a href="https://juejin.cn/post/6844903806132568072">让虚拟 DOM 和 DOM-diff 不再成为你的绊脚石</a>。</p>

<h3 id="8-对-react-fiber-的理解">8、对 React Fiber 的理解</h3>

<p>关于这块儿我觉得可以好好阅读下这篇无敌的博客了：<a href="https://link.juejin.cn?target=https%3A%2F%2Fpomb.us%2Fbuild-your-own-react%2F">Build your own React</a>。 它可以教你一步步实现一个简单的基于 React Fiber 的 React，可以学到很多 React 的设计思想，毕竟为了面试我们可能大多数人是没有时间或能力去阅读源码的了。</p>

<p>然后我们再阅读下其它作者对于 React Fiber 的理解，再转化为我们自己的思考总结，以下是推荐文章： <a href="https://juejin.cn/post/6844903975112671239">这可能是最通俗的 React Fiber(时间分片) 打开方式</a></p>

<h3 id="9-react-性能优化手段">9、React 性能优化手段</h3>

<p>推荐文章：<a href="https://juejin.cn/post/6844903924302888973">React 性能优化的 8 种方式了解一下？</a></p>

<ul>
<li>使用 <code>React.memo</code> 来缓存组件。</li>
<li>使用 <code>React.useMemo</code> 缓存大量的计算。</li>
<li>避免使用匿名函数。</li>
<li>利用 <code>React.lazy</code> 和 <code>React.Suspense</code> 延迟加载不是立即需要的组件。</li>
<li>尽量使用 CSS 而不是强制加载和卸载组件。</li>
<li>使用 <code>React.Fragment</code> 避免添加额外的 DOM。</li>
</ul>

<h3 id="10-react-redux">10、React Redux</h3>

<p><a href="https://juejin.cn/post/6844904021187117069">Redux 包教包会（一）：介绍 Redux 三大核心概念</a></p>

<h2 id="七-webpack">七、webpack</h2>

<p>原理初探：<a href="https://juejin.cn/post/6943468761575849992">当面试官问 Webpack 的时候他想知道什么</a>
 简易实现：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FCosen95%2Fblog%2Fissues%2F48">面试官：webpack 原理都不会</a>，<a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000039231950">手写一个 webpack，看看 AST 怎么用</a>
 加料：<a href="https://juejin.cn/post/6844903520378814471">简单易懂的 webpack 打包后 JS 的运行过程</a>，<a href="https://juejin.cn/post/6888936770692448270">Webpack 手写 loader 和 plugin</a>
 热更新原理：<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F30669007">Webpack HMR 原理解析</a>
 面试题：<a href="https://juejin.cn/post/6844904094281236487">「吐血整理」再来一打 Webpack 面试题</a></p>

<p><strong>这里要注意，应该还会考 webpack5 和 4 有哪些区别。</strong></p>

<h2 id="八-模块化">八、模块化</h2>

<p><a href="https://juejin.cn/post/6844903744518389768">前端模块化详解(完整版)</a> （这里面没有讲 umd）
 <a href="https://juejin.cn/post/6844903927104667662">可能是最详细的 UMD 模块入门指南</a></p>

<h2 id="九-性能优化">九、性能优化</h2>

<p>代码层面：</p>

<ul>
<li>防抖和节流（resize，scroll，input）。</li>
<li>减少回流（重排）和重绘。</li>
<li>事件委托。</li>
<li>css 放 ，js 脚本放  最底部。</li>
<li>减少 DOM 操作。</li>
<li>按需加载，比如 React 中使用 <code>React.lazy</code> 和 <code>React.Suspense</code> ，通常需要与 webpack 中的 <code>splitChunks</code> 配合。</li>
</ul>

<p>构建方面：</p>

<ul>
<li><strong>压缩代码文件</strong>，在 webpack 中使用 <code>terser-webpack-plugin</code> 压缩 Javascript 代码；使用 <code>css-minimizer-webpack-plugin</code> 压缩 CSS 代码；使用 <code>html-webpack-plugin</code> 压缩 html 代码。</li>
<li><strong>开启 gzip 压缩</strong>，webpack 中使用 <code>compression-webpack-plugin</code> ，node 作为服务器也要开启，使用 <code>compression</code>。</li>
<li><strong>常用的第三方库使用 CDN 服务</strong>，在 webpack 中我们要配置 externals，将比如 React， Vue 这种包不打倒最终生成的文件中。而是采用 CDN 服务。</li>
</ul>

<p>其它：</p>

<ul>
<li>使用 http2。因为解析速度快，头部压缩，多路复用，服务器推送静态资源。</li>
<li>使用服务端渲染。</li>
<li>图片压缩。</li>
<li>使用 http 缓存，比如服务端的响应中添加 <code>Cache-Control / Expires</code> 。</li>
</ul>

<h2 id="十-常见手写">十、常见手写</h2>

<p>以下的内容是上面没有提到的手写，比如 <code>new</code> 、<code>Promise.all</code> 这种上面内容中已经提到了如何写。</p>

<h3 id="1-防抖">1、防抖</h3>

<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F22">JavaScript 专题之跟着 underscore 学防抖 </a></p>

<pre><code class="language-javascript">function debounce(func, wait, immediate) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;

    if (timeout) clearTimeout(timeout);
    if (immediate) {
      let callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait);
      if (callNow) func.apply(context, args);
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args);
      }, wait);
    }
  };
}

</code></pre>

<h3 id="2-节流">2、节流</h3>

<p><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F26">JavaScript 专题之跟着 underscore 学节流</a></p>

<pre><code class="language-javascript">// 使用时间戳
function throttle(func, wait) {
  let preTime = 0;

  return function () {
    let nowTime = +new Date();
    let context = this;
    let args = arguments;

    if (nowTime - preTime &gt; wait) {
      func.apply(context, args);
      preTime = nowTime;
    }
  };
}

// 定时器实现
function throttle(func, wait) {
  let timeout;

  return function () {
    let context = this;
    let args = arguments;

    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}

</code></pre>

<h3 id="3-快速排序">3、快速排序</h3>

<p>这里对快排思想不太明白的同学可以看下这个讲解的很清晰的视频：<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1at411T75o%3Ffrom%3Dsearch%26seid%3D10065750342799523965%26spm_id_from%3D333.337.0.0">快速排序算法</a>。</p>

<pre><code class="language-javascript">function sortArray(nums) {
  quickSort(0, nums.length - 1, nums);
  return nums;
}

function quickSort(start, end, arr) {
  if (start &lt; end) {
    const mid = sort(start, end, arr);
    quickSort(start, mid - 1, arr);
    quickSort(mid + 1, end, arr);
  }
}

function sort(start, end, arr) {
  const base = arr[start];
  let left = start;
  let right = end;
  while (left !== right) {
    while (arr[right] &gt;= base &amp;&amp; right &gt; left) {
      right--;
    }
    arr[left] = arr[right];
    while (arr[left] &lt;= base &amp;&amp; right &gt; left) {
      left++;
    }
    arr[right] = arr[left];
  }
  arr[left] = base;
  return left;
}

</code></pre>

<h3 id="4-instanceof">4、instanceof</h3>

<p>这个手写一定要懂原型及原型链。</p>

<pre><code class="language-javascript">function myInstanceof(target, origin) {
  if (typeof target !== &quot;object&quot; || target === null) return false;
  if (typeof origin !== &quot;function&quot;)
    throw new TypeError(&quot;origin must be function&quot;);
  let proto = Object.getPrototypeOf(target); // 相当于 proto = target.__proto__;
  while (proto) {
    if (proto === origin.prototype) return true;
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

</code></pre>

<h3 id="5-数组扁平化">5、数组扁平化</h3>

<p>重点，不要觉得用不到就不管，这道题就是考察你对 js 语法的熟练程度以及手写代码的基本能力。</p>

<pre><code class="language-javascript">function flat(arr, depth = 1) {
  if (depth &gt; 0) {
    // 以下代码还可以简化，不过为了可读性，还是....
    return arr.reduce((pre, cur) =&gt; {
      return pre.concat(Array.isArray(cur) ? flat(cur, depth - 1) : cur);
    }, []);
  }
  return arr.slice();
}

</code></pre>

<h3 id="6-手写-reduce">6、手写 reduce</h3>

<p>先不考虑第二个参数初始值：</p>

<pre><code class="language-javascript">Array.prototype.reduce = function (cb) {
  const arr = this; //this就是调用reduce方法的数组
  let total = arr[0]; // 默认为数组的第一项
  for (let i = 1; i &lt; arr.length; i++) {
    total = cb(total, arr[i], i, arr);
  }
  return total;
};

</code></pre>

<p>考虑上初始值：</p>

<pre><code class="language-javascript">Array.prototype.reduce = function (cb, initialValue) {
  const arr = this;
  let total = initialValue || arr[0];
  // 有初始值的话从0遍历，否则从1遍历
  for (let i = initialValue ? 0 : 1; i &lt; arr.length; i++) {
    total = cb(total, arr[i], i, arr);
  }
  return total;
};

</code></pre>

<h3 id="7-带并发的异步调度器-scheduler">7、带并发的异步调度器 Scheduler</h3>

<p>JS 实现一个带并发限制的异度调度器 Scheduler，保证同时运行的任务最多有两个。完善下面代码中的 Scheduler 类，使得以下程序能正确输出。</p>

<pre><code class="language-javascript">class Scheduler {
  add(promiseMaker) {}
}

const timeout = (time) =&gt;
  new Promise((resolve) =&gt; {
    setTimeout(resolve, time);
  });

const scheduler = new Scheduler();
const addTask = (time, order) =&gt; {
  scheduler.add(() =&gt; timeout(time).then(() =&gt; console.log(order)));
};

addTask(1000, &quot;1&quot;);
addTask(500, &quot;2&quot;);
addTask(300, &quot;3&quot;);
addTask(400, &quot;4&quot;);
// output：2 3 1 4
// 一开始，1，2两个任务进入队列。
// 500ms 时，2完成，输出2，任务3入队。
// 800ms 时，3完成，输出3，任务4入队。
// 1000ms 时，1完成，输出1。

</code></pre>

<p>根据题目，我们只需要操作 <code>Scheduler</code> 类就行：</p>

<pre><code class="language-javascript">class Scheduler {
  constructor() {
    this.waitTasks = []; // 待执行的任务队列
    this.excutingTasks = []; // 正在执行的任务队列
    this.maxExcutingNum = 2; // 允许同时运行的任务数量
  }

  add(promiseMaker) {
    if (this.excutingTasks.length &lt; this.maxExcutingNum) {
      this.run(promiseMaker);
    } else {
      this.waitTasks.push(promiseMaker);
    }
  }

  run(promiseMaker) {
    const len = this.excutingTasks.push(promiseMaker);
    const index = len - 1;
    promiseMaker().then(() =&gt; {
      this.excutingTasks.splice(index, 1);
      if (this.waitTasks.length &gt; 0) {
        this.run(this.waitTasks.shift());
      }
    });
  }
}

</code></pre>

<h3 id="8-去重">8、去重</h3>

<ul>
<li><p>利用 ES6 <code>set</code> 关键字：</p>

<pre><code class="language-javascript">function unique(arr) {
return [...new Set(arr)];
}

</code></pre></li>

<li><p>利用 ES5 <code>filter</code> 方法：</p>

<pre><code class="language-javascript">function unique(arr) {
return arr.filter((item, index, array) =&gt; {
return array.indexOf(item) === index;
});
}

</code></pre></li>
</ul>

<h2 id="十一-其它">十一、其它</h2>

<ol>
<li>requestAnimationFrame（<a href="https://juejin.cn/post/6991297852462858277">一个神奇的前端动画 API requestAnimationFrame</a>）</li>
<li>如何排查内存泄漏问题，面试官可能会问为什么页面越来越卡顿，直至卡死，怎么定位到产生这种现象的源代码（开发环境）？（<a href="https://juejin.cn/post/6947841638118998029">一文带你了解如何排查内存泄漏导致的页面卡顿现象</a>）</li>
<li>vite 大火，我复习的时候是去年 9 月份，还没那么火，可能现在的你需要学一学了～</li>
<li>vue3 也一样，如果你是 React 技术栈（就像我之前一样）当我没说。</li>
</ol>

<h2 id="十二-算法">十二、算法</h2>

<p>这部分大家可以点击以下这个仓库，按照仓库中的题目顺序进行刷题，都是我亲自刷过的，排了最适合的顺序：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fvortesnail%2Fleetcode">vortesnail/leetcode</a>。
 然后如果大家想看下大厂的算法高频题可以看这个仓库：<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fafatcoder%2FLeetcodeTop">afatcoder/LeetcodeTop</a>。</p>

<p>作者：vortesnail
链接：<a href="https://juejin.cn/post/7061588533214969892">https://juejin.cn/post/7061588533214969892</a>
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://geek.zshipu.com/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://geek.zshipu.com/post/css/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/">https://geek.zshipu.com/post/css/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/nexp/css-level-01/css-level-001-%E5%AD%A6%E4%B9%A0-TailwindCSS%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E5%8D%A1/">css-level-001 学习 TailwindCSS：制作个人资料卡</a></li>
        
        <li><a href="/post/css/CSS-%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/">CSS 特性的完整指南</a></li>
        
        <li><a href="/post/css/%E4%BD%BF%E7%94%A8-HTML-&#43;CSS-%E7%9A%84%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B9%95%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/">使用 HTML &#43;CSS 的骨架屏幕加载动画</a></li>
        
        <li><a href="/post/web3.0/%E5%85%A8%E6%A0%88-Web3-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/">web3.0 全栈 Web3 开发完整指南</a></li>
        
        <li><a href="/post/web3.0/%E5%85%A8%E6%A0%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/">web3.0 全栈以太坊开发完整指南</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/css'>css</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-geek"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2023 <a href="https://geek.zshipu.com/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://geek.zshipu.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://geek.zshipu.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.2-%E6%9F%9032%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8B-C&#43;&#43;%E7%A8%8B%E5%BA%8F%E8%AF%B7%E8%AE%A1%E7%AE%97sizeof-%E7%9A%84%E5%80%BC/" title="华为篇-2.2.2 某32位系统下, C&#43;&#43;程序，请计算sizeof 的值">华为篇-2.2.2 某32位系统下, C&#43;&#43;程序，请计算sizeof 的值</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.1-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5MN%E5%80%BC%E4%BB%8E1%E8%87%B3N%E5%BC%80%E5%A7%8B%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%95%B0%E6%AF%8F%E6%95%B0%E5%88%B0M%E8%BE%93%E5%87%BA%E8%AF%A5%E6%95%B0%E5%80%BC%E7%9B%B4%E8%87%B3%E5%85%A8%E9%83%A8%E8%BE%93%E5%87%BA%E5%86%99%E5%87%BAC%E7%A8%8B%E5%BA%8F/" title="华为篇-2.2.1 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序">华为篇-2.2.1 用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.0-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%88%86%E4%B8%BA%E5%93%AA%E4%BF%A9%E9%83%A8%E5%88%86/" title="华为篇-2.2.0 IP地址的编码分为哪俩部分？">华为篇-2.2.0 IP地址的编码分为哪俩部分？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.9.-Internet%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/" title="华为篇-2.1.9. Internet采用哪种网络协议？该协议的主要层次结构？">华为篇-2.1.9. Internet采用哪种网络协议？该协议的主要层次结构？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.8-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88/" title="华为篇-2.1.8 冒泡排序算法的时间复杂度是什么？">华为篇-2.1.8 冒泡排序算法的时间复杂度是什么？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.7-%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/" title="华为篇-2.1.7 什么函数不能声明为虚函数？">华为篇-2.1.7 什么函数不能声明为虚函数？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.6-%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%80%E8%88%AC%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84/" title="华为篇-2.1.6 堆栈溢出一般是由什么原因导致的？">华为篇-2.1.6 堆栈溢出一般是由什么原因导致的？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" title="华为篇-2.1.5 什么是平衡二叉树？">华为篇-2.1.5 什么是平衡二叉树？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.4-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%BA%E5%88%AB%E5%A6%82%E6%9E%9C%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/" title="华为篇-2.1.4 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？">华为篇-2.1.4 全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.3-%E6%8F%8F%E8%BF%B0%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/" title="华为篇-2.1.3 描述实时系统的基本特性">华为篇-2.1.3 描述实时系统的基本特性</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【2019双12】ALL IN CLoud 低至1折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1_rYHo7P2gK0jSZPxXXacQpXa-690-388.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="助力产业智慧升级，云服务器首年88元起，更有千元代金券礼包免费领！" target="_blank" style="color:red">
                
                    <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-7c71532bd4935fbdd9a67c1a71e577b1767b805c.200%E7%89%88%E6%9C%ACB.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【渠道专享低折扣】11月特惠 限时2折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1hblJl7Y2gK0jSZFgXXc5OFXa-750-400.jpg">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://geek.zshipu.com/categories/flutter/">flutter (30)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/iOS/">iOS (7)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/unix/">unix (9)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/%E7%AE%97%E6%B3%95/">算法 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://geek.zshipu.com/tags/BI/">BI</a>
    
    <a href="https://geek.zshipu.com/tags/DDD/">DDD</a>
    
    <a href="https://geek.zshipu.com/tags/DDD%E5%AE%9E%E6%88%98/">DDD实战</a>
    
    <a href="https://geek.zshipu.com/tags/DevOps/">DevOps</a>
    
    <a href="https://geek.zshipu.com/tags/Doris/">Doris</a>
    
    <a href="https://geek.zshipu.com/tags/IM/">IM</a>
    
    <a href="https://geek.zshipu.com/tags/JS/">JS</a>
    
    <a href="https://geek.zshipu.com/tags/Java/">Java</a>
    
    <a href="https://geek.zshipu.com/tags/JavaScript/">JavaScript</a>
    
    <a href="https://geek.zshipu.com/tags/Monorepo/">Monorepo</a>
    
    <a href="https://geek.zshipu.com/tags/Netty/">Netty</a>
    
    <a href="https://geek.zshipu.com/tags/NextJS/">NextJS</a>
    
    <a href="">Nextjs</a>
    
    <a href="https://geek.zshipu.com/tags/ReactJS/">ReactJS</a>
    
    <a href="https://geek.zshipu.com/tags/Typora/">Typora</a>
    
    <a href="https://geek.zshipu.com/tags/WebRTC/">WebRTC</a>
    
    <a href="https://geek.zshipu.com/tags/android/">android</a>
    
    <a href="https://geek.zshipu.com/tags/apollo/">apollo</a>
    
    <a href="https://geek.zshipu.com/tags/css/">css</a>
    
    <a href="https://geek.zshipu.com/tags/flutter/">flutter</a>
    
    <a href="https://geek.zshipu.com/tags/game/">game</a>
    
    <a href="https://geek.zshipu.com/tags/github/">github</a>
    
    <a href="https://geek.zshipu.com/tags/gitlab/">gitlab</a>
    
    <a href="https://geek.zshipu.com/tags/go/">go</a>
    
    <a href="https://geek.zshipu.com/tags/golang/">golang</a>
    
    <a href="https://geek.zshipu.com/tags/graphql/">graphql</a>
    
    <a href="">java</a>
    
    <a href="https://geek.zshipu.com/tags/jdbc/">jdbc</a>
    
    <a href="">js</a>
    
    <a href="https://geek.zshipu.com/tags/mybatis/">mybatis</a>
    
    <a href="https://geek.zshipu.com/tags/mysql/">mysql</a>
    
    <a href="https://geek.zshipu.com/tags/nexp/">nexp</a>
    
    <a href="">nextjs</a>
    
    <a href="https://geek.zshipu.com/tags/nifi/">nifi</a>
    
    <a href="https://geek.zshipu.com/tags/nodejs/">nodejs</a>
    
    <a href="https://geek.zshipu.com/tags/npm/">npm</a>
    
    <a href="https://geek.zshipu.com/tags/python/">python</a>
    
    <a href="https://geek.zshipu.com/tags/react/">react</a>
    
    <a href="">reactjs</a>
    
    <a href="https://geek.zshipu.com/tags/sharding/">sharding</a>
    
    <a href="https://geek.zshipu.com/tags/sqllit/">sqllit</a>
    
    <a href="https://geek.zshipu.com/tags/storybook/">storybook</a>
    
    <a href="https://geek.zshipu.com/tags/tailwind/">tailwind</a>
    
    <a href="https://geek.zshipu.com/tags/vuejs/">vuejs</a>
    
    <a href="https://geek.zshipu.com/tags/web/">web</a>
    
    <a href="https://geek.zshipu.com/tags/web3/">web3</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%B9%A6%E7%B1%8D/">书籍</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%88%86%E8%AF%8D/">分词</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%96%87%E6%91%98/">文摘</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9E%B6%E6%9E%84/">架构</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/">用户画像</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
    <a href="https://geek.zshipu.com/tags/%E8%B5%B7%E6%AD%A5/">起步</a>
    
    <a href="https://geek.zshipu.com/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://geek.zshipu.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>