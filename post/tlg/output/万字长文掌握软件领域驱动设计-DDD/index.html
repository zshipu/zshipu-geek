<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title> | 知识铺的博客</title>
    <meta property="og:title" content=" - 知识铺的博客">
    <meta property="og:type" content="article">
        
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="">
        
    <meta name="author" content="知识铺">
    <meta property="og:url" content="https://geek.zshipu.com/post/tlg/output/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%8E%8C%E6%8F%A1%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
    
    
    
    
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
    
</head>


<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://geek.zshipu.com/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://geek.zshipu.com/">首页</a>
                    
                    <a  href="https://geek.zshipu.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://geek.zshipu.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#1-背景"><strong>1. 背景</strong></a></li>
<li><a href="#2-ddd-概要与实践感悟"><strong>2.DDD 概要与实践感悟</strong></a></li>
<li><a href="#2-1-复杂性"><strong>2.1 复杂性</strong></a></li>
<li><a href="#2-2-领域驱动"><strong>2.2 领域驱动</strong></a></li>
<li><a href="#2-3-怎么才算-ddd"><strong>2.3 怎么才算 DDD？</strong></a></li>
<li><a href="#3-问题空间-解空间"><strong>3. 问题空间 &amp; 解空间</strong></a></li>
<li><a href="#3-1-问题空间-解空间"><strong>3.1 问题空间 &amp; 解空间</strong></a></li>
<li><a href="#3-2-示例-学生管理系统的问题空间"><strong>3.2 示例 - 学生管理系统的问题空间</strong></a></li>
<li><a href="#4-领域驱动设计统一过程-dddrup"><strong>4. 领域驱动设计统一过程（DDDRUP）</strong></a></li>
<li><a href="#5-全局分析阶段"><strong>5. 全局分析阶段</strong></a></li>
<li><a href="#5-1-形成统一语言"><strong>5.1 形成统一语言</strong></a></li>
<li><a href="#5-2-价值需求分析"><strong>5.2 价值需求分析</strong></a></li>
<li><a href="#5-3-业务需求分析"><strong>5.3 业务需求分析</strong></a></li>
<li><a href="#5-3-1-业务流程-业务场景-业务服务和业务规则"><strong>5.3.1 业务流程、业务场景、业务服务和业务规则</strong></a></li>
<li><a href="#5-3-2-子领域"><strong>5.3.2 子领域</strong></a></li>
<li><a href="#6-架构映射阶段"><strong>6. 架构映射阶段</strong></a></li>
<li><a href="#6-1-限界上下文的定义和特征"><strong>6.1 限界上下文的定义和特征</strong></a></li>
<li><a href="#6-1-1-限界上下文的定义"><strong>6.1.1 限界上下文的定义</strong></a></li>
<li><a href="#6-1-2-限界上下文的特征"><strong>6.1.2 限界上下文的特征</strong></a></li>
<li><a href="#6-2-限界上下文的识别"><strong>6.2 限界上下文的识别</strong></a></li>
<li><a href="#6-2-1-按业务维度识别"><strong>6.2.1 按业务维度识别</strong></a></li>
<li><a href="#6-2-2-验证"><strong>6.2.2 验证</strong></a></li>
<li><a href="#6-3-上下文映射"><strong>6.3 上下文映射</strong></a></li>
<li><a href="#6-3-1-防腐层"><strong>6.3.1 防腐层</strong></a></li>
<li><a href="#6-3-2-开放主机服务"><strong>6.3.2 开放主机服务</strong></a></li>
<li><a href="#6-3-3-发布语言"><strong>6.3.3 发布语言</strong></a></li>
<li><a href="#6-3-4-共享内核"><strong>6.3.4 共享内核</strong></a></li>
<li><a href="#6-3-5-合作者"><strong>6.3.5 合作者</strong></a></li>
<li><a href="#6-3-6-客户方-供应方"><strong>6.3.6 客户方 / 供应方</strong></a></li>
<li><a href="#6-3-7-分离方式"><strong>6.3.7 分离方式</strong></a></li>
<li><a href="#6-3-8-遵奉者"><strong>6.3.8 遵奉者</strong></a></li>
<li><a href="#6-3-9-大泥球"><strong>6.3.9 大泥球</strong></a></li>
<li><a href="#6-4-示例-sms-的限界上下文及其映射"><strong>6.4 示例 - SMS 的限界上下文及其映射</strong></a></li>
<li><a href="#7-领域建模阶段"><strong>7. 领域建模阶段</strong></a></li>
<li><a href="#7-1-模型驱动设计"><strong>7.1 模型驱动设计</strong></a></li>
<li><a href="#7-1-1-领域模型驱动设计"><strong>7.1.1 领域模型驱动设计</strong></a></li>
<li><a href="#7-2-领域分析建模"><strong>7.2 领域分析建模</strong></a></li>
<li><a href="#7-2-1-名词建模"><strong>7.2.1 名词建模</strong></a></li>
<li><a href="#7-2-2-动词建模"><strong>7.2.2 动词建模</strong></a></li>
<li><a href="#7-2-3-提取隐式概念"><strong>7.2.3 提取隐式概念</strong></a></li>
<li><a href="#7-2-4-归纳抽象"><strong>7.2.4 归纳抽象</strong></a></li>
<li><a href="#7-2-5-确认关系"><strong>7.2.5 确认关系</strong></a></li>
<li><a href="#7-2-6-示例-sms-的领域分析模型"><strong>7.2.6 示例 - SMS 的领域分析模型</strong></a></li>
<li><a href="#7-3-领域设计建模"><strong>7.3 领域设计建模</strong></a></li>
<li><a href="#7-3-1-设计要素"><strong>7.3.1 设计要素</strong></a></li>
<li><a href="#7-3-1-1-实体"><strong>7.3.1.1 实体</strong></a></li>
<li><a href="#7-3-2-设计聚合"><strong>7.3.2 设计聚合</strong></a></li>
<li><a href="#7-3-3-设计服务"><strong>7.3.3 设计服务</strong></a></li>
<li><a href="#7-3-3-1-分解任务"><strong>7.3.3.1 分解任务</strong></a></li>
<li><a href="#7-3-3-2-分配职责"><strong>7.3.3.2 分配职责</strong></a></li>
<li><a href="#7-3-4-示例-sms-的领域设计模型"><strong>7.3.4 示例 - SMS 的领域设计模型</strong></a></li>
<li><a href="#7-4-领域实现建模"><strong>7.4 领域实现建模</strong></a></li>
<li><a href="#7-4-1-领域模型与测试金字塔"><strong>7.4.1 领域模型与测试金字塔</strong></a></li>
<li><a href="#7-4-2-测试驱动开发"><strong>7.4.2 测试驱动开发</strong></a></li>
<li><a href="#8-分层架构与代码骨架"><strong>8. 分层架构与代码骨架</strong></a></li>
<li><a href="#8-1-分层架构"><strong>8.1 分层架构</strong></a></li>
<li><a href="#8-2-代码骨架"><strong>8.2 代码骨架</strong></a></li>
<li><a href="#8-2-1-用户接口层"><strong>8.2.1 用户接口层</strong></a></li>
<li><a href="#8-2-2-应用层"><strong>8.2.2 应用层</strong></a></li>
<li><a href="#8-2-3-领域层"><strong>8.2.3 领域层</strong></a></li>
<li><a href="#8-2-4-基础设施实现层"><strong>8.2.4 基础设施实现层</strong></a></li>
<li><a href="#9-杂谈"><strong>9. 杂谈</strong></a></li>
<li><a href="#9-1-ddd-与微服务"><strong>9.1 DDD 与微服务</strong></a></li>
<li><a href="#9-2-事务"><strong>9.2 事务</strong></a></li>
<li><a href="#9-2-1-本地事务"><strong>9.2.1 本地事务</strong></a></li>
<li><a href="#9-2-2-saga-事务"><strong>9.2.2 Saga 事务</strong></a></li>
<li><a href="#10-参考"><strong>10. 参考</strong></a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title"></h1>
        </header>
        <date class="post-meta meta-date">
            1年1月1日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://zhuanlan.zhihu.com/p/489070825">zhuanlan.zhihu.com</a></p>

<p>作者：faryrong，腾讯 CSIG 后台开发工程师 最近看了一本书《解构-领域驱动设计》，书中提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书…</p>
</blockquote>

<p>作者：faryrong，腾讯 CSIG 后台开发工程师</p>

<blockquote>
<p>最近看了一本书《解构 - 领域驱动设计》，书中提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。</p>
</blockquote>

<h3 id="1-背景"><strong>1. 背景</strong></h3>

<p>领域驱动设计（DDD）由 Eric Evans 提出，并一经《领域驱动设计：软件核心复杂性应对之道》的发布，在软件行业中引起了不少的轰动。DDD 提供的一种新颖的，甚至有点 “另类” 的思维方式，它在告诉软件开发者“我们要用业务方案来解决业务问题，而不是技术方案解决业务问题”，有点魔法打败魔法的意思。DDD 虽然让人眼前一亮，但是所提倡的理念有点“违背直觉”（对开发人员而言），因此，在当时并没有流行开来。</p>

<p>后来，微服务架构的兴起，大伙惊奇地发现 DDD 是作为划分 “微服务边界” 的一把利器，并且 DDD 提及的很多设计理念与微服务架构十分契合，因此 DDD 逐渐被开发者们接受并流行起来。毫不夸张地说，了解和学习 DDD 可以算得上是如今软件行业从业者的一门必修课了。</p>

<p>但是！DDD 的学习曲线较为陡峭。作为一个小白，翻阅过很多相关的书籍、KM 文章和分享，但始终觉得未得要领、一知半解。原因有二：a) DDD 涉及的概念繁多，且不同概念的抽象层次不一样，如果我们直白地去理解，往往会感到疑惑，比如：子域和限界上下文都是用于将问题进行归类和收敛，他们的区别是什么？b) 缺少过程指导，难以将概念有序的串联起来。作为方法论，DDD 给出了设计思想，核心原则以及常用工具，但是却缺少细致有序的方法步骤，导致难以上手实践。</p>

<p>幸运的是，最近看了一本书《解构 - 领域驱动设计》。这本书提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，<strong>我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章</strong>。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。</p>

<h3 id="2-ddd-概要与实践感悟"><strong>2.DDD 概要与实践感悟</strong></h3>

<p>经典必读书籍《领域驱动设计：软件核心复杂性应对之道》的书名包含了两个关键词：<strong>领域驱动</strong>和<strong>复杂性，</strong>分别代表了 DDD 的核心原则以及解决的问题。</p>

<h3 id="2-1-复杂性"><strong>2.1 复杂性</strong></h3>

<p>系统的复杂性往往并不在技术上，而是来自领域本身、用户的活动或业务服务。当这种领域复杂性在设计中没有得到解决时，基础技术的构思再好也是无济于事。而系统的复杂度体现在三个方面：<strong>规模</strong>、<strong>结构</strong>和<strong>变化</strong>。</p>

<p><strong>规模</strong>：指的是系统所支持的功能点，以及功能点与功能点之间的的关系。DDD 通过子领域，限界上下文，聚合等模式对问题进行拆分和归类，不断收窄问题域，保证聚合边界内所解决的问题集合足够收敛和可控。</p>

<p><strong>结构</strong>：指的是系统架构。系统架构是否分层；若分层，每层划分的职责边界是否清晰；架构的基本管理单元是什么，它决定了架构演进时的复杂度。DDD 通过分层架构，独立出领域层，且架构中的每层都有清晰的职责。整体架构的基本管理单元是聚合，它是一个完整的、自治的管理单元，当需要进行服务拆分时，可以直接以聚合作为基本单元进行拆分。</p>

<p><strong>变化</strong>：指的是系统响应需求变化的能力。快速响应变化的有效手段是分离不易变逻辑和易变逻辑，&rdquo;以不变应万变&rdquo;。而通过分层架构独立的领域层正是不易变的逻辑。领域层是对领域知识的封装，其提供的领域服务具有经验性和前瞻性，是对领域内稳定的领域规则的表达。而领域层以外的应用层和基础设施层则是易变逻辑的封装。保证核心的独立和稳定，通过在调整应用层和基础设施层来实现快速响应需求变化。</p>

<h3 id="2-2-领域驱动"><strong>2.2 领域驱动</strong></h3>

<p>领域驱动指的是以领域作为解决问题切入点，面对业务需求，先提炼出领域概念，并构建领域模型来表达业务问题，而构建过程中我们应该尽可能避免牵扯技术方案或技术细节。而编码实现更像是对领域模型的代码翻译，代码（变量名、方法名、类名等）中要求能够表达领域概念，让人见码明义。</p>

<p>结合实践经验，以下是本人对 “领域驱动” 的一些见解：</p>

<p><strong>思维模式转变</strong></p>

<p>实践 DDD 以前，我最常使用的是<strong>数据驱动设计</strong>。它的核心思路针对业务需求进行<strong>数据建模</strong>：根据业务需求提炼出类，然后通过 ORM 把类映射为表结构，并根据读写性能要求使用范式优化表与表之间的关联关系。数据驱动是从技术的维度解决业务问题，得出的数据模型是对业务需求的直接翻译，并没有蕴含<strong>稳定的</strong>领域知识 / 规则。一旦需求发生变化，数据模型就得发生变化，对应的库表的设计也需要进行调整。这种设计思维导致变化从需求穿透到了数据层，中间并没有稳定的，不易变的层级进行阻隔，最终导致系统响应变化的能力很差。</p>

<p><strong>协同方式转变</strong></p>

<p>过去由产品同学提出业务需求，研发同学根据业务需求的 tapd 进行技术方案设计，并编程实现。</p>

<p>这种协同方式的弊端在于：<strong>无法形成能够消除认知差异的模型</strong>。产品同学从业务角度提出用户需求，这些需求可能是易变的、定制化的，而研发同学在缺少行业经验的情况下，往往会选择直译，即根据需求直接转换为数据模型。而研发同学从技术实现角度设计技术方案，其中涉及很多的技术细节，产品同学无法从中判断是否与自己提出的业务诉求和产品规划相一致，最终形成认知差异。且认知差异会随着迭代不断被放大，最后系统变成一个大泥球。</p>

<p><img src="https://pic2.zhimg.com/v2-028e6cc5db309428401b7bc71f263225_r.jpg" alt="" /></p>

<p>DDD 通过解锁新角色<strong>” 领域专家 &ldquo; 以及模型驱动设计</strong>，有效地降低产品和研发的认知差异。 领域专家是具有丰富行业经验和领域知识储备的人，他们能够在易变的、定制化的需求中提炼出清晰的边界，稳定的、可复用的领域概念和业务规则，并携手产品和研发共同构建出领域模型。领域模型是对业务需求的知识表达形式，它不涉及具体的技术细节（但能够指导研发同学进行编程实现），因此消除了产品和研发在需求认知上的鸿沟。而模型驱动设计则要求领域模型能够关联业务需求和编码实现，模型的变更意味着需求变更和代码变更，协作围绕模型为中心。</p>

<p><img src="https://pic2.zhimg.com/v2-24acfe02401a10e9c4be988d1eb11f8d_r.jpg" alt="" /></p>

<p><strong>精炼循环</strong></p>

<p>精炼循环指的是在统一语言，提炼领域概念，明确边界，构建模型，绑定实现过程中，这些环节相互影响和反馈，在不断的迭代试错 - 调整以最终沉淀出稳定的、深层次的模型的过程。比如，我们在提炼领域概念的时候会觉得统一语言定义不合理 / 有歧义，此时我们就会调整统一语言的定义，并重新进行提炼领域概念。通过精炼循环，我们逐步形成稳定的领域模型。在 DDD 中，让领域专家来主导概念提炼、边界划分等宏观设计，原因就在于领域专家的经验和行业洞见来源于过去已经迭代的无数个精炼循环，因此由这些宏观设计推导出来的领域模型，往往都是非常稳定的。</p>

<p>精炼循环的核心是循环，它避免知识只朝单一方向流动，最终因各环节上的认知差异，最终导致模型无法在产品、领域专家和研发中达成一致、模型与实现割裂。</p>

<h3 id="2-3-怎么才算-ddd"><strong>2.3 怎么才算 DDD？</strong></h3>

<p>我早期实践 DDD 的时候，认为代码分层遵循四层架构就是 DDD，抑或分离接口和实现，实现下沉至基础设施层就是 DDD，实则不然。结合上述内容，目前个人认为只要满足以下条件即为实践 DDD：</p>

<ul>
<li>构建出产品、领域专家和研发同学认知一致且便于交流的模型，并且模型与实现紧密绑定；</li>
<li>模型逐步演进，反复消化和精炼；</li>
<li>模型蕴含领域知识，足够稳定。</li>
</ul>

<h3 id="3-问题空间-解空间"><strong>3. 问题空间 &amp; 解空间</strong></h3>

<h3 id="3-1-问题空间-解空间"><strong>3.1 问题空间 &amp; 解空间</strong></h3>

<p>问题空间和解空间并非 DDD 特有的概念，而是人们为了区分真实世界和理念世界而提出的概念。问题空间表示的是真实世界，是具体的问题、用户的诉求，而解空间则是针对问题空间求解后构建的理念世界，其中包括了解决方案、模型等。</p>

<p>DDD 提出的战略设计覆盖了问题空间和解空间，而战术设计则聚焦在解空间上。明确 DDD 中的概念是作用于问题空间还是解空间，更有助于我们理解它们。</p>

<h3 id="3-2-示例-学生管理系统的问题空间"><strong>3.2 示例 - 学生管理系统的问题空间</strong></h3>

<p>学生管理系统（Student Management System，下文简称 SMS）作为 DDDRUP 的讲解示例，以下为其问题空间的描述。</p>

<pre><code>学校需要构建一个学生管理系统（Student Management System, SMS）。

通过这个管理系统，学生可以进行选课，查询成绩，查询绩点。

而老师则可以通过这个系统录入授课课程的成绩。录入的分数会由系统自动换算为绩点，规则如下：若分数&gt;= 90，绩点为4.0；90&gt;= 分数&gt; 80，绩点为3.0；80 &gt;= 分数 &gt; 70，绩点为2.0；70 &gt;= 分数 &gt;= 60，绩点为1.0；成绩&lt; 60，则没有绩点，并邮件通知教务员，由教务员联系学生商榷重修事宜。

成绩录入后的一周内，若出现录入成绩错误的情况，老师可提交修改申请，由教务员审核后即可完成修改。审核完成后系统会通过邮件告知老师审核结果。一周后成绩将锁定，不予修改。成绩锁定后，次日系统会自动计算各年级、各班的学生的总绩点（总绩点由各门课程的学分与其绩点进行加权平均后所得）。

而教务员则可以通过该系统发布可以选修的课程。同时，教务员能够查看到各年级，各班的学生的总绩点排名。

</code></pre>

<h3 id="4-领域驱动设计统一过程-dddrup"><strong>4. 领域驱动设计统一过程（DDDRUP）</strong></h3>

<p>虽然领域驱动设计划分了<strong>战略设计</strong>和<strong>战术设计</strong>，也提供了诸多模式和工具，但却没有一个统一过程去规范这两个阶段需要执行的活动、交付的工件以及阶段里程碑，甚至没有清晰定义这两个阶段如何衔接、它们之间执行的工作流到底是怎么样的。</p>

<p>而《解构 - 领域驱动设计》提出的 DDDRUP 给出了更细致的步骤、步骤与步骤之间的衔接，以及明确的阶段里程碑，最重要的是 DDDRUP 可以串联 DDD 的所有概念和模式，非常便于初学者做知识梳理和上手实践。<strong>下文我会依照 DDDRUP 的步骤流程进行讲述，而非战略设计 + 战术设计的思路</strong>。（DDDRUP 各步骤与战略 &amp; 战术设计的关系见下表）。</p>

<p><img src="https://pic2.zhimg.com/v2-0eff4c514c15742e1068983a71c99411_r.jpg" alt="" /></p>

<h3 id="5-全局分析阶段"><strong>5. 全局分析阶段</strong></h3>

<p>全局分析阶段对<strong>问题空间</strong>进行的梳理和分析，<strong>形成统一语言</strong>（ubiquitous language）, 获取问题空间的<strong>价值需求</strong>以及<strong>业务需求</strong>。</p>

<h3 id="5-1-形成统一语言"><strong>5.1 形成统一语言</strong></h3>

<p><strong>统一语言</strong>：蕴含领域知识的、团队内统一的领域术语。产品、领域专家以及开发人员掌握的领域知识存在差异，往往导致对同一个事物使用不同的术语。比如，商品的价格（Price）和商品的金额（Amount），它们本质是同一个东西，但是却有不同的术语表示。</p>

<p>统一语言会参与 DDDRUP 的全流程，且会在精炼循环过程中不断进行调整，以反映出更合适、更深层次的领域知识。</p>

<p>根据业务需求形成统一语言，有助于团队对事物的认知达成一致。统一语言可以通过词汇表的形式展示，其中词汇表最好还要包含术语对应的英文描述，便于研发同学在代码层面表达统一语言。示例 - SMS 的统一语言词汇表如下。</p>

<p><img src="https://pic3.zhimg.com/v2-bdeafb10c9bf5442c32bb7a52a06dcc6_r.jpg" alt="" /></p>

<h3 id="5-2-价值需求分析"><strong>5.2 价值需求分析</strong></h3>

<p>价值需求分析主要做的三个工作是：</p>

<ol>
<li>识别利益相关者。利益相关者指的是与目标系统存在利益关系的人、团队或组织, 可以简单理解为目标系统的用户，或与目标系统有直接交互的人、团队或组织。</li>
<li>明确系统愿景。阐明目标系统要做什么，以及为何要做。</li>
<li>确定系统范围。确定系统问题空间的边界，明确系统什么该做，什么不该做。结合目标系统<strong>当前状态</strong>和<strong>未来状态</strong>进行判断。当前状态指的是系统的可用资源，包括业务资源、人力资源，资金资源等；而未来的状态则由业务目标、组织的战略规划和产品规划共同构成。</li>
</ol>

<p>并非任何系统都 DDD，DDD 的核心是解决领域复杂性，若系统逻辑简单，功能不多，引入 DDD 则会得不偿失。而在进行价值需求分析后，我们便能判断是否需要通过 DDD 驱动系统的设计。</p>

<h3 id="5-3-业务需求分析"><strong>5.3 业务需求分析</strong></h3>

<h3 id="5-3-1-业务流程-业务场景-业务服务和业务规则"><strong>5.3.1 业务流程、业务场景、业务服务和业务规则</strong></h3>

<p>使用<strong>业务流程、业务场景、业务服务</strong>和<strong>业务规则</strong>来表示业务需求。</p>

<p><strong>业务流程</strong>：表示的是一个完整的、端对端的服务过程。</p>

<p><strong>业务场景</strong>：按阶段性的业务目标划分业务流程，就可以获得业务场景。在示例 - SMS 中，老师修改成绩就分为了老师 “提交申请单”，以及教务员“同意申请单” 两个场景。</p>

<p><strong>业务服务</strong>：角色主动向目标系统发起服务请求完成一次<strong>完整</strong>的功能交互，以实现业务目标。角色可以用户、策略（定时任务）或者其他系统，完整则强调的是业务服务的执行序列的所有步骤都应该是<strong>连续且不可中断</strong>的。业务服务是业务需求分析最核心，也是最基础的单元，而<strong>业务流程和业务场景是为了更好地分析出业务服务</strong>。在示例 - SMS 中的 “同意申请单” 场景中包含了两个业务服务：教务员 “同意申请单” 和系统 “邮件通知” 教务员。</p>

<p><strong>业务规则</strong>：指对业务服务约束的描述，用于控制业务服务的对外行为。业务规则是业务服务正确性的基础。常见的业务规则有：a) 意如 “若… , 就….” 的需求描述，比如示例 - SMS 中可提炼出 “若成绩录入时间间隔超过一周，不予修改”；b) 具有事务性的操作。</p>

<p><img src="https://pic1.zhimg.com/v2-e78b70fb87d218285804ebc1dac26d94_r.jpg" alt="" /></p>

<h3 id="5-3-2-子领域"><strong>5.3.2 子领域</strong></h3>

<p>通过业务流程、业务场景和业务服务的梳理，基本可以分析出业务需求所需要的业务服务。然而，业务服务粒度太细，而问题空间又太大，我们需要找一个更粗粒度的业务单元，来帮助我们对业务服务进行聚类，一方面可以降低管理过多细粒度业务服务导致的额外复杂度，另一方面可以帮助领域专家和开发团队分析问题和设计方案时不至于陷入到业务细节中。而这个更粗粒度的业务单元就是<strong>子领域</strong>。</p>

<p><strong>子领域的作用</strong>：</p>

<ul>
<li>划分问题空间，作为业务服务分类的边界；</li>
<li>用于分辨问题空间的核心问题和次要问题。</li>
</ul>

<p><strong>子领域的分类：</strong></p>

<ul>
<li><strong>核心子领域</strong>：能够体现系统愿景，具有产品差异化和核心竞争力的业务服务；</li>
<li><strong>通用子领域</strong>：包含的内容缺乏领域个性，具有较强的通用性，例如权限管理和邮件管理；</li>
<li><strong>支撑子领域</strong>：包含的内容多为 “定制开发”，其为核心子领域的功能提供了支撑。</li>
</ul>

<p><strong>子领域的功能分类策略：</strong>问题空间应该分为哪些子领域，需要团队对目标系统整体进行探索，并根据<strong>功能分类策略</strong>进行分解。</p>

<ul>
<li><strong>业务职能：</strong>当目标系统运用于企业的生产和管理时，与目标系统业务有关的职能部门往往会影响目标系统的子领域划分，并形成一种简单的映射关系。这是康威定律的一种运用。</li>
<li><strong>业务产品：</strong>当目标系统为客户提供诸多具有业务价值的产品时，可以按照产品的内容与方向进行子领域划分。</li>
<li><strong>业务环节</strong>对贯穿目标系统的核心业务流程进行阶段划分，然后按照划分出来的每个环节确定子领域。（这也是我们最常用的策略）</li>
<li><strong>业务概念：</strong>捕捉目标系统中一目了然的业务概念，将其作为子领域。</li>
</ul>

<p>划分子领域的过程存在很多经验因素，一个对该行业领域知识了如指掌的领域专家，可以在完成价值需求分析后，结合自身的领域经验，能够选择合适的聚类策略并给出稳定的子领域列表。但，没有领域经验也没有关系！因为根据知识消化循环思路，再经历多个迭代后收敛出来的子领域划分也会逐渐合理，逼急领域专家凭经验得出的子领域划分，只是可能需要的时间要长一些。</p>

<h3 id="6-架构映射阶段"><strong>6. 架构映射阶段</strong></h3>

<p>在架构映射阶段，我们需要识别限界上下文，并通过上下文映射表示限界上下文之间的协作关系。</p>

<h3 id="6-1-限界上下文的定义和特征"><strong>6.1 限界上下文的定义和特征</strong></h3>

<h3 id="6-1-1-限界上下文的定义"><strong>6.1.1 限界上下文的定义</strong></h3>

<p><strong>限界上下文是语义和语境的边界</strong>。在问题空间，统一语言形成了团队对领域概念的统一表达，子领域形成了领域概念之间的边界。而在解空间，限界上下文可以看做是统一语言 + 子领域的融合体，统一语言需要在限界上下文内才具有明确的业务含义。</p>

<p>以电商购物场景为例。在进行商品下单后，系统会生成一个订单；在用户付款完成后，系统也会生成一个订单；到了物流派送流程，系统还会生成一个订单。虽然这三个步骤中的领域概念都叫订单，但是他们的关注点 / 职责却不同：商品订单关注的是商品详情，支付订单关注的是支付金额和分润情况，物流订单关注的是收货地址。也就是说，商品、支付和物流分别为三个限界上下文，而订单作为统一语言需要在特定的限界上下文内，我们才能够明确其关注点 / 负责的职责。</p>

<h3 id="6-1-2-限界上下文的特征"><strong>6.1.2 限界上下文的特征</strong></h3>

<p><strong>最小完备：</strong>限界上下文在履行属于自己的业务能力时，拥有的领域知识是完整的，无须针对自己的信息去求助别的限界上下文。</p>

<p><strong>自我履行：</strong>限界上下文能够根据自己拥有的知识来完成业务能力。自我履行体现了限界上下文<strong>纵向切分业务能力</strong>的特征。</p>

<p>这里需要强调一下<strong>业务模块（横向切分）</strong>和<strong>限界上下文（纵向切分）</strong>的区别。业务模块不具备完整、独立的业务能力，它没有按照同一个业务变化的方向进行。而限界上下文是对目标系统架构的纵向切分，切分的依据是从业务进行考虑的领域维度。为了提供完整的业务能力，在根据领域维度进行划分时，还需要考虑支撑业务能力的基础设施实现，如与该业务相关的数据访问逻辑，以及将领域知识持久化的数据库模型，形成纵向的逻辑边界，即限界上下文边界。</p>

<p><img src="https://pic1.zhimg.com/v2-a8867068929ce0b93cb3f02428be0890_r.jpg" alt="" /></p>

<p><strong>稳定空间：</strong>限界上下文必须防止和减少外部变化带来的影响。</p>

<p><strong>独立进化：</strong>指减少限界上下文内部变化对外界产生的影响。</p>

<p>上述的四个特征可以帮助我们验证识别出来的限界上下文。限界上下文划分是否合理、职责分配是否合理（最小完备 &amp; 自我履行），是否合理运用上下文映射的手段隔离外部变化的影响（稳定空间）、是否有合理的封装，对外提供的接口是否稳定（独立进化）？</p>

<h3 id="6-2-限界上下文的识别"><strong>6.2 限界上下文的识别</strong></h3>

<h3 id="6-2-1-按业务维度识别"><strong>6.2.1 按业务维度识别</strong></h3>

<p><strong>1. 归类</strong></p>

<p>按照业务相关性对业务服务进行归类，业务相关性体现为：</p>

<ul>
<li><strong>语义相关性</strong>：存在相同或相似的领域概念，对应于业务服务描述的名词，如果不同的业务服务操作了相同或相似的对象，即可认为它们存在语义相关性。</li>
<li><strong>功能相关性</strong>：体现领域行为的相关性，业务服务是否服务于同一个业务目标。</li>
</ul>

<p><strong>2. 归纳</strong></p>

<p>归纳是对归类后的限界上下文进行命名。给限界上下文命名的过程，实际上也是对归类是否合理的再一次复查。限界上下文的命名同样需要遵循单一职责原则，它只能代表唯一的最能体现其特征的领域概念。倘若归类不合理，命名就会变得困难，这时候我们就需要反思（遵循知识消化循环）归类是否合理，并重新设计归类。</p>

<p><strong>3. 边界梳理</strong></p>

<p>归类和归纳之后，限界上下文的边界基本已经确定，边界梳理则是根据<strong>限界上下文特征（最小完备、自我履行、稳定空间和独立进化）</strong>以及<strong>子领域</strong>进行微调（当然也不排除大调）。</p>

<pre><code>为什么需要根据子领域进行限界上下文边界的调整？限界上下文和子领域的关系是什么？

理想的限界上下文与子领域的关系是一一对应的。上文提到，子领域是领域专家根据领域经验选择合适的功能分类策略进行划分，这个过程不会牵扯对业务服务的分析，体现的是领域专家对行业的洞见和深刻认识，可见获取子领域是一个自顶向下的过程。而限界上下文则是对业务服务进行归类、归纳、梳理和调整，最终形成一个个的边界，这是一个自下而上的过程。理想情况下，两者应该是双向奔赴的，自顶向下得到的子领域和自下而上得到的限界上下文能够完美契合！但是，现实哪有这么理想呢！所以一般情况下都需要我们进行调整，力求这两者能够一一对应。

这里就再cue一下知识消化循环。优秀的领域专家划分出来的子领域，往往能够实现与限界上下文的一一对应。这就是经验的力量！那经验是怎么来的呢？我认为是领域专家经历了无数个知识消化循环之后沉淀下来的。领域专家一开始也是小白，划分出来的子领域在映射为限界上下文之后发现不同限界之间可能存在语义重叠，角色在不同限界上下文之中履行的职责可能很相似，于是他们通过知识消化循环，不断调整限界上下文的边界，然后又通过限界上下文调整子领域。慢慢地，稳定、可复用的子领域就被沉淀下来了。因此，识别限界上下文不是一个单向的过程，而是一个根据子领域调整限界上下文，然后又根据限界上下文调整子领域的循环的过程。

</code></pre>

<h3 id="6-2-2-验证"><strong>6.2.2 验证</strong></h3>

<p><strong>正交原则</strong></p>

<p>正交性：如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。要破坏变化的传递性，就要保证每个限界上下文对外提供的业务服务不能出现雷同。</p>

<p><strong>奥卡姆剃刀原理</strong></p>

<p>“如无必要，勿增实体”。这是避免过度设计的良方，同样也是我们识别限界上下文的原则。如果对识别出来的限界上下文的准确性依然心存疑虑，比较务实的做法是<strong>保证限界上下文具备一定的粗粒度</strong>。遵循该原则，意味着当我们没有寻找到必须切分限界上下文的必要证据时，就不要增加新的限界上下文。</p>

<h3 id="6-3-上下文映射"><strong>6.3 上下文映射</strong></h3>

<p>限界上下文封装了分离的业务能力，上下文映射则建立了限界上下文之间的关系。上下文映射提供了各种模式（防腐层、开放主机服务、发布语言、共享内核、合作者、客户方 / 供应方、分离方式、遵奉者、大泥球），<strong>本质是在控制变化在限界上下文之间传递所产生的影响</strong>。</p>

<p>下文将提供服务的限界上下文称为 “上游” 上下文（U 表示），消费服务的限界上下文称为 “下游” 上下文（D 表示）。</p>

<h3 id="6-3-1-防腐层"><strong>6.3.1 防腐层</strong></h3>

<p>引入防腐层的目的是为了<strong>隔离耦合</strong>。防腐层往往位于下游，通过它隔离上游上下文发生的变化。</p>

<p><img src="https://pic1.zhimg.com/v2-f7e1f533c019f1d3d31dc2bd5e04ffa8_b.jpg" alt="" /></p>

<h3 id="6-3-2-开放主机服务"><strong>6.3.2 开放主机服务</strong></h3>

<p>开放主机服务定义公开服务的协议（亦称为 “服务契约”），包括通信方式、传递消息的格式（协议），让限界上下文可以被当做一组服务访问。开放主机服务也可以视为一种承诺，保证开放的服务不会轻易做出变化。</p>

<p>对于进程内的开放主机服务，称为<strong>本地服务</strong>（对应 DDD 中的应用服务）。</p>

<p>对于进程间的开放主机服务，成为<strong>远程服务</strong>。根据选择的分布式通信技术的不同，又可以定义出类型不同的远程服务：</p>

<ul>
<li>面向服务行为，比如基于 RPC，称为提供者（Provider）；</li>
<li>面向服务资源，比如基于 REST，称为资源（Resource）；</li>
<li>面向事件，比如基于消息中间件，称为订阅者（Subscriber）；</li>
<li>面向视图模型，比如基于 MVC，称为控制器（Controller）；</li>
</ul>

<p><img src="https://pic1.zhimg.com/v2-83be68c662a88749579ba9947844a688_b.jpg" alt="" /></p>

<h3 id="6-3-3-发布语言"><strong>6.3.3 发布语言</strong></h3>

<p>发布语言是一种公共语言，用于两个限界上下文之间的模型转换。防腐层和开放主机服务都是访问领域模型时建立的一层包装，前者针对发起调用的下游（通过基础设施层体现），后者针对响应请求的上游（通过应用层 + 远程服务），以避免上下游之间的通信集成将各自的领域模型引入进来，造成彼此之间的强耦合。因此，<strong>防腐层和开放主机服务操作的对象都不应该是各自的领域模型</strong>，这正是引入发布语言的原因。（对于熟悉云 API 的小伙伴就会发现，其实云 API 根据我们定义的接口生成对应的 Request 对象和 Response 对象，并集成在云 API 的 SDK 中，这些对象就是发布语言）。</p>

<p>一般情况下，发布语言根据开放主机服务的服务契约进行定义。</p>

<p>说到这里，我们惊讶地发现<strong>防腐层</strong>，<strong>开放主机服务</strong>和<strong>发布语言</strong>可以完美联动！</p>

<p><img src="https://pic4.zhimg.com/v2-85be1c5adbe42bdc747b633fefc8549f_b.jpg" alt="" /></p>

<h3 id="6-3-4-共享内核"><strong>6.3.4 共享内核</strong></h3>

<p>共享内核指将限界上下文中的领域模型直接暴露给其他限界上下文使用。注意，这会削弱了限界上下文边界的控制力。上面我们讲述的防腐层、开放主机服务以及发布语言无不传达一种思想，限界上下文不能直接暴露自己的领域模型或直接访问其他限界上下文的领域模型，一定要有隔离层！</p>

<p>但是，在特定的场景下，共享内核不见得不是一种合理的方式。<strong>任何软件设计决策都要考量成本与收益，只有收益高于成本，决策才是合理的。</strong>一般对于一些领域通用的值对象是相对稳定的，这些类型通常属于通用子领域，会被系统中几乎所有的限界上下文复用，那么这些领域模型就适合使用共享内核的方式。共享内核的收益不言而喻，而面临的风险则是共享的领域模型可能产生的变化。</p>

<p><img src="https://pic3.zhimg.com/v2-28b2491289750a20637072b66e912d0a_b.jpg" alt="" /></p>

<h3 id="6-3-5-合作者"><strong>6.3.5 合作者</strong></h3>

<p>合作关系指的是协作的限界上下文由不同的团队负责，且这些团队之间具有要么一起成功，要么一起失败的强耦合关系。合作者模式要求参与的团队一起做计划、一起提交代码、一起开发和部署，采用持续集成的方式保证两个限界上下文的集成度与一致性，避免因为其中一个团队的修改影响集成点的失败。</p>

<h3 id="6-3-6-客户方-供应方"><strong>6.3.6 客户方 / 供应方</strong></h3>

<p>当一个限界上下文单向地为另一个限界上下文提供服务时，它们对应的团队就形成了客户方 / 供应方模式。这是最为常见的团队协作模式，客户方作为下游团队，供应方作为上游团队，二者协作的主要内容包括：</p>

<ul>
<li>下游团队对上游团队提出的服务</li>
<li>上游团队提供的服务采用什么样的协议与调用方式</li>
<li>下游团队针对上游服务的测试策略</li>
<li>上游团队给下游团队承诺的交付日期</li>
<li>当上游服务的协议或调用方式发生变更时，如何控制变更</li>
</ul>

<h3 id="6-3-7-分离方式"><strong>6.3.7 分离方式</strong></h3>

<p>分离方式的团队协作模式是指两个限界上下文之间没有一丁点关系。如果此时双方使用到了相似 / 相同的领域模型，则可以通过拷贝的方式解决，保证限界上下文之间的物理隔离！</p>

<h3 id="6-3-8-遵奉者"><strong>6.3.8 遵奉者</strong></h3>

<p>当上游的限界上下文处于强势地位，且上游团队响应不积极时，我们可以采用遵奉者模式。即下游严格遵从上游团队的模型，以消除复杂的转换逻辑。</p>

<p>当下游团队选择 “遵奉” 于上游团队设计的模型时，意味着：</p>

<ul>
<li>可以直接复用上游上下文的模型（好的）；</li>
<li>减少了两个限界上下文之间模型的转换成本（好的）；</li>
<li>使得下游限界上下文对上游产生了模型上的强依赖（坏的）。</li>
</ul>

<h3 id="6-3-9-大泥球"><strong>6.3.9 大泥球</strong></h3>

<p>一定要避免制造大泥球！大泥球的特点：</p>

<ul>
<li>越来越多的聚合因为不合理的关联和依赖导致交叉污染；</li>
<li>对大泥球的维护牵一发而动全身；</li>
<li>强调 “个人英雄主义”，只有个别“超人” 能够理清逻辑。</li>
</ul>

<h3 id="6-4-示例-sms-的限界上下文及其映射"><strong>6.4 示例 - SMS 的限界上下文及其映射</strong></h3>

<p>示例 - SMS 的限界上下文可划分为：</p>

<ul>
<li>成绩上下文</li>
<li>课程上下文</li>
<li>审批上下文</li>
<li>权限上下文</li>
<li>邮件上下文</li>
</ul>

<p>上下文映射图如下所示。</p>

<p><img src="https://pic2.zhimg.com/v2-64437de4ace4e77e4751068c3bdcc66d_r.jpg" alt="" /></p>

<h3 id="7-领域建模阶段"><strong>7. 领域建模阶段</strong></h3>

<p>领域建模阶段由领域分析建模，领域设计建模和领域实现建模组成。在正式讲解建模活动前，先了解一下什么是模型驱动设计。</p>

<h3 id="7-1-模型驱动设计"><strong>7.1 模型驱动设计</strong></h3>

<p>模型是一种知识形式，它对知识进行了选择性的简化和有意的结构化，从而解决信息超载的问题。模型便于人们理解信息的意义，并专注核心问题。</p>

<p>建模过程一般由<strong>分析活动</strong>、<strong>设计活动</strong>和<strong>实现活动</strong>组成。每一次建模活动都是一次对知识的提炼和转换，并产生相应的模型，即<strong>分析模型</strong>、<strong>设计模型</strong>和<strong>实现模型</strong>。</p>

<p>建模过程并非是分析、设计和实现单向的前后串行过程，而是相互影响，不断切换和递进的关系。模型驱动设计的建模过程是：分析中蕴含了设计，设计中夹带了实现，甚至实现后还要回溯到设计和分析的一种<strong>迭代的</strong>、<strong>螺旋上升的</strong>演进过程。</p>

<p>根据分解问题的视角不同，我们日常建立的模型可以大致分为以下三类：</p>

<ul>
<li><strong>数据模型</strong>：将问题空间抽取出来的概念视为数据信息，在求解过程中关注数据实体的样式和它们之间的关系，由此建立的模型就是数据模型。</li>
<li><strong>服务模型</strong>：将每个问题视为目标系统为客户端提供的服务，在求解过程就会关注客户端发起的请求以及服务返回的响应，由此建立的模型就是服务模型。</li>
<li><strong>领域模型</strong>：围绕问题空间的业务需求，在求解过程中力求提炼出表达领域知识的逻辑概念，由此建立的模型就是领域模型。</li>
</ul>

<h3 id="7-1-1-领域模型驱动设计"><strong>7.1.1 领域模型驱动设计</strong></h3>

<p>一个优秀的领域模型应该具备以下的特征（我们也可以说具备这些特征的模型就是领域模型）：</p>

<ul>
<li>运用统一语言来表达领域中的概念；</li>
<li>蕴含业务活动和规则等领域知识；</li>
<li>对领域知识进行适度的提炼和抽象；</li>
<li>由一个迭代的演进过程建立；</li>
<li>有助于产品、领域专家和开发同学进行交流。</li>
</ul>

<p>领域建模阶段目的便是建立领域模型。领域模型由<strong>领域分析模型</strong>、<strong>领域设计模型</strong>以及<strong>领域实现模型</strong>共同组成，它们也分别是领域分析建模、领域设计建模和领域实现建模三个建模活动的产物。</p>

<p>值得注意的是，领域模型并非由开发团队单方面输出的产物，而是由产品、领域专家和开发团队共同协作的结果。领域专家通过领域模型能够判断系统所支持的领域能力，以及由此编排出来的上层业务能力；开发团队通过领域模型能够形成基本的代码框架（包括架构分层，每层需要定义的接口，接口的命名等）。同理，领域模型的调整，也意味着领域知识或业务规则的变化，也预示着系统所支持的业务能力和代码实现同样需要作出改变。</p>

<h3 id="7-2-领域分析建模"><strong>7.2 领域分析建模</strong></h3>

<p><strong>领域分析建模</strong>：在限界上下文内，以 “领域” 为中心，提炼业务服务中的领域概念，确定领域概念之间的关系，最终形成领域分析模型。领域分析模型描述了各个限界上下文中的领域概念，以及领域概念之间的关系。</p>

<p>下面讲述如何通过 “快速建模法” 来构建领域分析模型。</p>

<h3 id="7-2-1-名词建模"><strong>7.2.1 名词建模</strong></h3>

<p>找到业务服务中的名词，在统一语言指导下将其映射为领域概念。</p>

<h3 id="7-2-2-动词建模"><strong>7.2.2 动词建模</strong></h3>

<p>识别动词并不是为领域模型对象分配职责、定义方法，而是将识别出来的动词当做一个领域行为，然后看它是否产生了影响管理、法律或财务的<strong>过程数据</strong>。若存在，则将这些过程数据作为领域概念放到领域分析模型中。注意，这里的过程数据是要求会对企业运营和管理产生影响的数据，比如示例 - SMS 系统中老师提交修改申请，就会产生<strong>申请单</strong>这个过程数据，而请求流水记录、任务执行记录都不属于过程数据。动词建模通过分析领域行为是否产生过程数据来找到隐藏的领域概念，弥补了名词建模的不足。</p>

<p>特别地，对于会产生领域事件的动词，一般可以抽象出一个已完成该动作的状态。</p>

<h3 id="7-2-3-提取隐式概念"><strong>7.2.3 提取隐式概念</strong></h3>

<p>除了 “名词” 和“动词”，概念中其他重要的类别也可以在模型中显式地表现出来，主要包括：<strong>约束</strong>和<strong>规格</strong>。</p>

<p><strong>约束</strong></p>

<p>约束一般是对领域概念的限制，我们可以将约束条件提取到自己的方法中，并通过方法名显式地表达约束的含义。比如示例 - SMS 中关于 GPA 运算的约束。</p>

<p><img src="https://pic1.zhimg.com/v2-63c4eca0dcd4e2879dfeee90831d714c_b.jpg" alt="" /></p>

<p>有些时候，约束条件无法用单独一个方法来轻松表达，抑或约束条件中会使用到与对象职责无关的信息，那么我们就可以将其提取到一个显式的对象中。</p>

<p><strong>规格（SPECIFICATION）</strong></p>

<p>很多时候业务规则并不适合作为实体或值对象的职责，而且规则的变化和组合也会掩盖领域对象的含义。但是，将规则移出领域层则导致领域代码无法表达模型。此时，我们可以定义<strong>规格</strong>（<strong>谓词形式</strong>的显式<strong>值对象</strong>），它用于确定对象是否满足指定的标准。规格将规则保留在领域层，由于规格是一个完备的对象，所以这种设计也能更加清晰地反映模型。</p>

<p>规格一般有如下三种用法：</p>

<ul>
<li>（验证）验证对象，检查它是否能满足某些标准，比如示例 - SMS 中成绩实体在修改分数时就需要通过规约判断当前是否满足修改的标准；</li>
<li>（选择）从集合中选择一个符合要求的对象，<strong>可以搭配资源库使用</strong>；</li>
<li>（根据要求来创建）指定在创建新对象时必须满足某种要求。</li>
</ul>

<p><img src="https://pic2.zhimg.com/v2-0d4d9f30b5abe4924f2e4e43c4ef3d1d_r.jpg" alt="" /></p>

<p>规格由 “谓词” 概念演变而来，因此我们可以使用 “AND”，“OR” 和“NOT”等运算对规格进行组合和修改。比如在 SMS 中，教务员需要查询流程完结的申请单，我们就可以通过 “AND” 组合不同的规格进行实现。</p>

<p><img src="https://pic1.zhimg.com/v2-f9be0d0ce06e881bf17c84f54eab3a5c_r.jpg" alt="" /></p>

<h3 id="7-2-4-归纳抽象"><strong>7.2.4 归纳抽象</strong></h3>

<p>对于有定语修饰的名词，要注意分辨它们是<strong>类型的差异</strong>，还是<strong>值的差异</strong>。如配送地址和家庭地址，订单状态和商品状态。如果是值的差异，类型相同，应归并为一个领域概念（如，配送地址和家庭地址）；而类型不同，则不能合并（如，订单状态和商品状态）。</p>

<p>特别地，当定语修饰的名词中，定语表示的是不同的限界上下文，且名词相同时（即名称相同、含义不同的领域概念），我们应该尽可能调整命名，确保含义不同的领域概念的名称不同，以避免不必要的歧义和沟通上的误解。比如：商品的订单和库存的订单在特定限界上下文内都可以命名为 order，但是如果把库存的订单改为库存的配送单 delivery 效果会更好。</p>

<h3 id="7-2-5-确认关系"><strong>7.2.5 确认关系</strong></h3>

<p>根据业务需求和领域知识，判断领域概念之间是否存在关联。且对于 1:N, N:1, M:N 的关联关系，我们需要判断是否可以为这些关联关系定义一个新的类型，比如作品与读者存在 1:N 的关系，我们可以定义 “订阅” 这个概念来描述这种关系。</p>

<p>注意，我们需要尽量避免对象中的双向关系，即对象 A 关联对象 B，而对象 B 关联对象 A。当两个对象存在双向关系时，会为管理他们的生命周期带来额外的复杂度。我们应该规定一个遍历方向，来表明<strong>一个方向的关联比另一个方向的关联更有意义且更重要</strong>，比如示例 SMS 中，成绩会关联课程（成绩实例中包含课程 ID），而课程不会关联成绩。当然，当双向关系是领域的一个概念时，我们还是应该保留它。</p>

<h3 id="7-2-6-示例-sms-的领域分析模型"><strong>7.2.6 示例 - SMS 的领域分析模型</strong></h3>

<p>通过名词建模，动词建模和归纳抽象后，可提炼出以下领域对象：成绩（Result）、绩点（gpa）、总成绩（total result）、总绩点（total gpa）、学年（school year）、学期（semester）、课程（course）、学分（credit）、申请单（application receipt），邮件（mail），排名（rank），申请单状态（application receipt status）</p>

<p>这些领域对象之间的关系如下图所示。</p>

<p><img src="https://pic3.zhimg.com/v2-b33d8707854f78c57a165dd72fb1974e_r.jpg" alt="" /></p>

<h3 id="7-3-领域设计建模"><strong>7.3 领域设计建模</strong></h3>

<p>领域设计建模的核心工作就是<strong>设计聚合</strong>和<strong>设计服务</strong>，在这之前我们需要先了解一下设计要素（实体、值对象、聚合、工厂、资源库、领域服务、领域事件）。</p>

<h3 id="7-3-1-设计要素"><strong>7.3.1 设计要素</strong></h3>

<p>领域驱动设计强调以 “领域” 为核心驱动力。设计领域模型时应该尽量避免陷入到技术实现的细节约束中。但很多时候我们又不得不去思考一些非领域相关的问题：</p>

<ul>
<li>领域模型对象在身份上是否存在明确的差别？</li>
<li>领域模型对象的加载以及对象间的关系如何处理？</li>
<li>领域模型对象如何实现数据的持久化？</li>
<li>领域模型对象彼此之间如何做到弱依赖地完成状态的变更通知？</li>
</ul>

<p>为了解答上述的四个问题，<strong>DDD 提供了很多的设计要素，它们能够帮助我们在不陷入到具体技术细节的情况下进行领域模型的设计</strong>。</p>

<h3 id="7-3-1-1-实体"><strong>7.3.1.1 实体</strong></h3>

<p>实体的核心三要素：<strong>身份标识</strong>、<strong>属性</strong>和<strong>领域行为</strong>。</p>

<p><strong>身份标识</strong>：身份标识的主要目的是管理实体的生命周期。身份标识可分为：通用类型和领域类型。通用类型 ID 没有业务含义；而领域类型 ID 则组装了业务逻辑，建议使用值对象作为领域类型 ID。</p>

<p><strong>属性</strong>：实体的属性用来说明主体的静态特征，并持有数据与状态。属性分为：原子属性和组合属性。组合属性可以是实体，也可以是值对象，取决于该属性是否需要身份标识。我们应该尽可能将实体的属性定义为组合属性，以便于在实体内部形成各自的抽象层次。</p>

<p><strong>领域行为</strong>：体现了实体的动态特征。实体具有的领域行为一般可以分为：</p>

<ul>
<li><strong>变更状态的领域行为</strong>：变更状态的领域行为体现的是实体 / 值对象内部的状态转移，对应的方法入参为期望变更的状态。（有入参，无出参）；</li>
<li><strong>自给自足的领域行为</strong>：自给自足意味着实体对象只操作了自己的属性，不外求于别的对象。（无入参）；</li>
<li><strong>互为协作的领域行为</strong>：需要调用者提供必要的信息。（有入参，有出参）；</li>
<li><strong>创建行为</strong>：代表了对象在内存的从无到有。创建行为由构造函数履行，但对于创建行为较为复杂或需要表达领域语义时，我们可以在实体中定义简单工厂方法，或使用专门的工厂类进行创建。（有出参，且出参为特定实体实例）。</li>
</ul>

<p><strong>7.3.1.2 值对象</strong></p>

<p>一个领域概念到底该用值对象还是实体类型，判断依据：</p>

<ul>
<li>业务的参与者对它的相等判断是依据值还是依据身份标识；</li>
<li>确定对象的属性值是否会发生变化，如果变化了，究竟是产生一个完全不同的对象，还是维持相同的身份标识；</li>
<li>生命周期的管理。值对象无需进行生命周期管理。</li>
</ul>

<p><strong>值对象具有不变性</strong>。值对象完成创建后，其属性和状态就不应该再进行变更了，如果需要更新值对象，则通过创建新的值对象进行替换。</p>

<p>由于值对象的属性是在其创建的时候就完成传入的，那么值对象所具有的领域行为大部分情况下都是 “自给自足的领域行为”，即入参为空。这些领域行为一般提供以下的能力。</p>

<ul>
<li><strong>自我验证</strong>：验证传入值对象的外部数据是否正确，一般在创建该值对象时进行验证。</li>
<li><strong>自我组合</strong>：当值对象涉及到数值运算时，可以定义相同类型值对象的方法，使值对象具有自我组合能力。比如示例 - SMS 中，在统计成绩时会涉及学分相加的运算，因此我们可以将相加运算定义为可组合的方法，便于调用者使用。</li>
</ul>

<p><img src="https://pic1.zhimg.com/v2-b0b2c31fe913bcc46cdd6c84b1207f88_r.jpg" alt="" /><img src="https://pic4.zhimg.com/v2-2ec5deeb201feaa393e6aaa4459eca2f_r.jpg" alt="" /></p>

<ul>
<li><strong>自我运算</strong>：根据业务规则对属性值进行运算的行为。</li>
</ul>

<p>在进行领域设计建模时，要善于运用值对象而非内建类型去表达细粒度的领域概念。相比于内建类型，值对象的优势有：</p>

<ul>
<li>值对象在类型层面就可以表达领域概念，而不仅仅依赖命名；</li>
<li>值对象可以封装领域行为，进行自我验证，自我组合，自我运算。</li>
</ul>

<p><strong>7.3.1.3 聚合</strong></p>

<p>聚合的基本特征：</p>

<ul>
<li>聚合是包含了实体和值对象的一个边界。</li>
<li>聚合内包含的实体和值对象形成一棵树，只有实体才能作为这棵树的根。</li>
<li>外部对象只允许持有聚合根的引用，以起到边界控制作用。</li>
<li>聚合作为一个完整的领域概念整体，其内部会维护这个领域概念的完整性。</li>
<li>由聚合根统一对外提供履行该领域概念职责的行为方法，实现内部各个对象之间的行为协作。</li>
</ul>

<p><strong>7.3.1.4 工厂</strong></p>

<p>聚合中的工厂：一个类或方法只要封装了聚合对象的创建逻辑，都可以认为是工厂。表现形式如下：</p>

<ul>
<li>引入专门的聚合工厂（尤其适合需要通过访问外部资源来完成创建的复杂创建逻辑）</li>
<li>聚合自身担任工厂（简单工厂模式）</li>
<li>服务契约对象或装配器（assembler）担任工厂（负责将外部请求对象 DTO 转换为实体）</li>
<li>使用构建者组装聚合</li>
</ul>

<p>注意！这里工厂创建的基本单元是聚合，而非实体，注意与实体中的创建行为区分。</p>

<p><strong>7.3.1.5 资源库</strong></p>

<p>资源库是对数据访问的一种业务抽象，用于解耦领域层与外部环境，使领域层变得更为纯粹。资源库可以代表任何可以获取资源的仓库，例如网络或其他硬件环境，而不局限于数据库。</p>

<p><strong>一个聚合对应一个资源库</strong>。领域驱动设计引入资源库，主要目的是管理聚合的生命周期。资源库负责聚合记录的查询与状态变更，即 “增删改查” 操作。资源库分离了聚合的领域行为和持久化行为，保证了领域模型对象的业务纯粹性。</p>

<p>值得注意的是，资源库的操作单元是聚合。当我们定义资源库的接口时，接口的入参应该为聚合的根实体。如果要访问聚合内的非根实体，也只能通过资源库获得整个聚合后，将根实体作为入口，在内存中访问封装在聚合边界内的非根实体对象。</p>

<pre><code>资源库与数据访问对象（DAO）的区别：

根本区别在于，数据访问对象在访问数据时，并无聚合的概念，也就是没有定义聚合的边界约束领域模型对象，使得数据访问对象的操作粒度可以针对领域层的任何模型对象。数据访问对象（DAO）可以自由地操作实体和值对象。没有聚合边界控制的数据访问，会在不经意间破坏领域概念的完整性，突破聚合不变量的约束，也无法保证聚合对象的独立访问与内部数据的一致性。

其次，资源库是基于领域模型对存储系统进行的抽象，因此资源库中的方法命名可以表达领域概念；而数据访问对象（DAO）是存储系统对外暴露的抽象，其方法命名更贴合数据库本身的操作。

</code></pre>

<p>**7.3.1.6 领域服务 **</p>

<p>聚合通过聚合根的领域行为对外提供服务，而<strong>领域服务则是对聚合根的领域行为的补充</strong>。因此，我们应该尽量<strong>优先通过聚合根的领域行为来满足业务服务</strong>。</p>

<p>那什么场景下我们会需要用到领域服务呢？有如下两个：</p>

<ul>
<li><strong>生命周期管理</strong>。为了避免领域知识的泄露，应用服务不会直接引用聚合生命周期相关的服务（工厂、资源库接口），而聚合根实体一般不会依赖资源库接口，此时就需要领域服务进行组合对外暴露。</li>
<li><strong>依赖外部资源</strong>。<strong>为了保证聚合的稳定性，聚合根实体不会依赖防腐层接口</strong>。因此，当聚合对外暴露的服务需要设计外部资源访问时，就需要通过领域服务来完成。</li>
</ul>

<p><strong>7.3.1.7 领域事件</strong></p>

<p>领域事件属于领域层的领域模型对象，由限界上下文中的聚合发布，感兴趣的聚合（同一限界上下文 / 不同限界上下文）可以进行消费。而当一个事件由应用层发布，则该事件为应用事件。</p>

<p>引入领域事件首要目的是更好地跟踪实体状态的变更，并在状态变更时，通过事件消息的通知完成领域模型对象之间的协作。</p>

<p><strong>领域事件的特征</strong>：</p>

<ul>
<li>领域事件代表了领域的概念；</li>
<li>领域事件是已经发生的事实（表示事件的名称应该是过去时，比如 Committed）；</li>
<li>领域事件是不可变的领域对象；</li>
<li>领域事件会基于某个条件而触发。</li>
</ul>

<p><strong>领域事件的用途</strong>：</p>

<ul>
<li>发布状态变更；</li>
<li>发布业务流程中的阶段性成果；</li>
<li>异步通信。</li>
</ul>

<p>领域事件应该包含：</p>

<ul>
<li>身份标识，即事件 ID，为通用类型的身份标识；</li>
<li>事件发生的时间戳，便于记录和跟踪；</li>
<li>属性需要针对订阅者的需求，在<strong>增强事件</strong>和<strong>反向查询</strong>之间进行权衡。增强事件指属性中包含订阅者所需的所有数据；反向查询则是属性包含事件 ID，当订阅者需要数据时通过事件 ID 进行反向查询。</li>
</ul>

<h3 id="7-3-2-设计聚合"><strong>7.3.2 设计聚合</strong></h3>

<p>在领域设计模型中，聚合是最小的设计单元。</p>

<p><strong>7.3.2.1 设计的经验法则</strong></p>

<p>这里有四条经验法则：</p>

<ol>
<li>在聚合边界内保护业务规则不变性。</li>
<li>聚合要设计得小巧。</li>
<li>通过身份标识符关联关系其他聚合。</li>
<li>使用最终一致性更新其他聚合。</li>
</ol>

<p>下面展开讲述法则 1 和法则 3。</p>

<p><strong>法则 1</strong> <strong>在聚合边界内保护业务规则不变性</strong>。</p>

<p>法则 1 包含了两个关键点：a) 参与维护业务规则不变性的领域概念应该置于同一个聚合内；b) 在任何情况下都要保护业务规则不变性。比如，在 sms 系统中分数和绩点具有转换关系，这是业务规则的不变性，因此这两个概念被放在了同一个聚合边界内；当出现老师修改分数的场景时，需要保证绩点的换算同时被执行。由于这里绩点对象是值对象，不需要关心其生命周期管理的问题。当业务规则涉及到多个实体时，就需要通过<strong>本地事务</strong>来保证规则不变性（即实体间基于业务规则的数据一致性）。</p>

<p><strong>法则 3 通过身份标识符关联其他聚合。</strong></p>

<p>注意这里强调了<strong>关联关系</strong>，关联关系会涉及聚合 A 对聚合 B 的生命周期管理的问题，对于这种聚合间的关联关系，我们通过<strong>身份标识</strong>建立关联。而当聚合 A 引用聚合 B，但不需要对聚合 B 进行生命周期管理时，我们认为这是一种<strong>依赖关系</strong>（比如方法中的入参，而非类中的属性），对于聚合间的依赖关系，我们可以通过<strong>对象引用</strong>（聚合根实体的引用）的方式建立依赖。（PS：假设设计之初难以判断聚合之间到底是关联关系，还是依赖关系，我们就统一使用身份标识符作为关系引用即可）</p>

<p><img src="https://pic4.zhimg.com/v2-6b3e424bffb690419bda1b524da564df_r.jpg" alt="" /></p>

<p>聚合间的依赖关系通常分为两种方式</p>

<ul>
<li>职责的委派：一个聚合作为另一个聚合的方法参数， 就会形成职责的委派。</li>
<li>聚合的创建：一个聚合创建另外一个聚合，就会形成实例化的依赖关系。</li>
</ul>

<p><strong>7.3.2.2 设计步骤</strong></p>

<p><strong>1. 理顺对象图</strong></p>

<p>分析对象是实体还是值对象。</p>

<p><strong>2. 分解关系薄弱处</strong></p>

<p>聚合本质是一个高内聚的边界，因此我们可以根据领域对象之间关系的强弱来定义出聚合的边界。对象间的关系由强到弱可以分为：泛化关系，关联关系和依赖关系。其中关联关系和依赖关系在 7.3.2.1 小节已讲述，而泛化关系可以理解为是继承关系（即父子关系）。</p>

<p><strong>泛化关系</strong></p>

<p>虽然泛化关系是强耦合关系，但是根据对业务理解的视角不同，会产生不同的设计：</p>

<ul>
<li>整体视角：调用者并不关心特化的子类之间的差异，而是将整个继承体系视为一个整体。此时应以泛化的父类作为聚合根。</li>
<li>独立视角：调用这只关注具体的特化子类，体现了概念的独立性，此时应以特化的子类作为独立的聚合根。</li>
</ul>

<p><strong>关联关系</strong></p>

<p>上述提到过，聚合间的关联关系会涉及聚合 A 对聚合 B 的生命周期管理，这其实是一个比较宽松的约束。那聚合内实体的关联关系应该是怎么样的呢？<strong>生命周期一致的、共存亡的，当主实体被销毁时，从实体也随之会被销毁。</strong>比如商品实体和商品明细实体。而在示例 - SMS 中，成绩和总成绩会被定义为两个聚合，原因是总成绩在成绩锁定后被统计，随后将不再发生改变，可见两者不存在上述的共存亡的关联关系。</p>

<p>PS: 实际上<strong>根据关联关系来区分边界的方法同样适用于限界上下文的边界划分</strong>。比如示例 - SMS 中的课程和成绩生命周期不同，先有课程，后有成绩；而且成绩锁定后，课程被撤销也不会对成绩有影响，因此就可以定义出课程上下文和成绩上下问。</p>

<p><strong>依赖关系</strong></p>

<p>依赖关系主要体现的是实体间的职责委派和创建行为，可以分到不同的聚合边界。</p>

<p><strong>3. 调整聚合边界</strong></p>

<p>根据<strong>业务规则</strong>调整聚合边界。为了维护业务规则的不变性，相关的实体应该至于同一个聚合边界内。</p>

<h3 id="7-3-3-设计服务"><strong>7.3.3 设计服务</strong></h3>

<p>这里的服务是对<strong>应用服务</strong>、<strong>领域服务</strong>、<strong>领域行为</strong>（实体提供的方法）和<strong>端口</strong>（资源库接口、防腐层接口）的统称。</p>

<h3 id="7-3-3-1-分解任务"><strong>7.3.3.1 分解任务</strong></h3>

<p><strong>业务服务</strong>包含若干个<strong>组合服务</strong>，组合服务包含若干个<strong>原子服务</strong>。<strong>领域行为</strong>和<strong>端口</strong>都可以认为是原子服务。</p>

<h3 id="7-3-3-2-分配职责"><strong>7.3.3.2 分配职责</strong></h3>

<p><strong>应用服务：</strong>匹配业务服务，提供满足业务需求的服务接口。应用服务自身并不包含任何领域逻辑，仅负责协调领域模型对象，通过它们的领域能力组合完整一个完整的应用目标。</p>

<p><strong>领域服务：</strong>匹配组合服务，执行业务功能，若原子任务为无状态行为或独立变化的行为，也可以匹配领域服务。控制多个聚合与端口之间的协作，由它来承担组合任务的执行。</p>

<p><strong>领域行为：</strong>匹配原子服务，提供业务功能的业务实现。强调无状态和独立变化，由实体提供。</p>

<p><strong>端口：</strong>匹配原子服务，抽象对外资源的访问，主要的端口包括资源库接口和防腐层接口。</p>

<pre><code>虽然上述给出了应用服务、领域服务、领域行为和端口与业务服务、组合服务和原子服务的匹配关系，但是对于应用服务、领域服务、领域行为和端口之间的关联关系却还不清晰，这里结合书中内容和个人实践给出一个参考。

应用服务：核心职责是编排聚合间的领域服务。
- 领域服务
- 防腐层接口：当多聚合间领域服务进行协作后需要访问外部资源，此时相关的防腐层逻辑应该至于应用层。（防腐层是上下文映射的方式，并非领域模型特有）
- 工厂：特指服务契约对象或装配器担任工厂，即将DTO转换为实体的工厂。
- 领域行为：在上述工厂创建实体后，若只需要调用实体的领域行为，而不需要涉及生命周期管理，可直接在应用服务中进行调用。

领域服务：细粒度的领域对象可能会把领域层的知识泄露到应用层中。这产生的结果是应用层不得不处理复杂的、细致的交互，从而使得领域知识蔓延到应用层或用户界面代码当中，而领域层会丢失这些知识。明智地引入领域层服务有助于在应用层和领域层之间保持一条明确的界限，因此应用层多数情况下也不会直接引用聚合的领域行为。
- 工厂
- 领域行为
- 防腐层接口：聚合内需要依赖外部资源，则将防腐逻辑收拢在领域服务中。
- 资源库接口

领域行为：不要关联资源库和防腐层接口。

</code></pre>

<h3 id="7-3-4-示例-sms-的领域设计模型"><strong>7.3.4 示例 - SMS 的领域设计模型</strong></h3>

<p><strong>聚合设计</strong>：</p>

<p><img src="https://pic1.zhimg.com/v2-dceac85346af62a55818409c7df68414_r.jpg" alt="" /></p>

<p><strong>服务设计</strong>：</p>

<p>下面只罗列非查询类的服务设计。</p>

<p><img src="https://pic3.zhimg.com/v2-733e768f44640f5c0328b91d6a5eba66_r.jpg" alt="" /><img src="https://pic4.zhimg.com/v2-fbaef94002201836d2c9669bb74b2d73_r.jpg" alt="" /><img src="https://pic3.zhimg.com/v2-979777fa8d63d49c7722bb7b5e06594e_r.jpg" alt="" /></p>

<h3 id="7-4-领域实现建模"><strong>7.4 领域实现建模</strong></h3>

<p>领域实现建模关注的并非是如何进行代码实现，而是<strong>如何验证代码实现的正确性，保证实现的高质量</strong>。</p>

<h3 id="7-4-1-领域模型与测试金字塔"><strong>7.4.1 领域模型与测试金字塔</strong></h3>

<p>领域模型中的服务包括了<strong>应用服务</strong>、<strong>领域服务</strong>、<strong>领域行为</strong>和<strong>端口</strong>。其中通过 Provider（面向服务行为）、Resource（面向服务资源）、Subscriber（面向事件）、Controller（面向视图模型）对外进行暴露的，我们称为<strong>远程服务</strong>。</p>

<p>领域模型中的服务与测试金字塔的关系如下图所示。</p>

<p><img src="https://pic4.zhimg.com/v2-7c7f5967cade14866a7261dbfb0902c7_r.jpg" alt="" /></p>

<h3 id="7-4-2-测试驱动开发"><strong>7.4.2 测试驱动开发</strong></h3>

<p>领域实现建模提倡的是<strong>测试驱动开发</strong>的编程思想，即要求开发者在进行逻辑实现前，优先进行测试用例的编写，<strong>站在调用者角度而非实现者角度</strong>去思考接口。</p>

<p>在上述测试金字塔中，开发者需要关注的是单元测试（不依赖任何外部资源的测试就是单元测试）。在领域设计建模阶段，我们对业务服务 / 应用服务进行分解，定义出了领域行为和领域服务。对于领域行为，由于其不依赖外部资源，因此我们可以直接编写单元测试；而对于领域服务，其可能会通过端口访问外部资源，此时我们需要对端口进行 mock，以隔离外部资源对领域逻辑验证的干扰。特别地，<strong>单元测试一定要覆盖所有对业务规则的验证</strong>，这是保证领域行为和领域服务正确性的基础。</p>

<p>单元测试编码规范：</p>

<ul>
<li>测试类的命名应与被测试类保持一致，为 “被测类名称 + Test 后缀”。</li>
<li>测试方法表达业务或业务规则为目的。</li>
<li>测试方法体遵循 Given-When-Then 模式。<strong>Given</strong>: 为要测试的方法提供准备，包括创建被测试对象，为调用方法准备输入参数实参等；<strong>When</strong>: 调用被测试的方法，遵循单一职责原则，在一个测试方法的 When 部分，应该只有一条语句对被测方法进行调用；<strong>Then</strong>: 对被测方法调用后的结果进行预期验证。</li>
</ul>

<h3 id="8-分层架构与代码骨架"><strong>8. 分层架构与代码骨架</strong></h3>

<h3 id="8-1-分层架构"><strong>8.1 分层架构</strong></h3>

<p><img src="https://pic2.zhimg.com/v2-75d58a64d71ea1349ca4765d7c566d29_r.jpg" alt="" /></p>

<p>代码架构分层是经典 DDD 四层：<strong>用户接口层</strong>，<strong>应用层</strong>，<strong>领域层</strong>和<strong>基础设施层</strong>。</p>

<p>需要注意的的地方是：</p>

<ul>
<li>用户接口层根据通信方式的不同，区分开了 Provider（面向服务行为）、Subscriber（面向事件）、Controller（面向视图模型 &amp; 资源） 、Task（面向策略 / 定时任务）。</li>
<li>基础设施层单独划分了 infranstructure-impl 模块。为了保证领域层的纯洁性，DDD 通过依赖倒置把访问外部系统（数据库，第三方系统）的服务的实现都下放到了基础设施层，而 infranstructure-impl 模块 则是对这些实现进行了归集。这样做的好处有两个：第一，依赖关系明确，（infransturcture-impl —&gt; domain，application）, （interface、application、domain —&gt; infranstructure）；第二，拆分服务更便捷。当我们需要部分领域独立拆分出来的时候，在实现层面就只需要关注 infransturcture-impl 模块 即可。</li>
<li>Infranstructure-impl 模块依赖应用层的原因是应用层可能会抽象出防腐层接口，需要 infranstruct-impl 为其提供实现。</li>
</ul>

<h3 id="8-2-代码骨架"><strong>8.2 代码骨架</strong></h3>

<h3 id="8-2-1-用户接口层"><strong>8.2.1 用户接口层</strong></h3>

<p>用户接口层的核心职能：协议转换和适配、鉴权、参数校验和异常处理。</p>

<pre><code>├── controller                             //面向视图模型&amp;资源
│   ├── ResultController.java
│   ├── assembler                         // 装配器，将VO转换为DTO
│   │   └── ResultAssembler.java
│   └── vo                                // VO(View Object)对象
│       ├── EnterResultRequest.java
│       └── ResponseVO.java
├── provider                               // 面向服务行为
├── subscriber                             // 面向事件
└── task                                   // 面向策略
    └── TotalResultTask.java

</code></pre>

<h3 id="8-2-2-应用层"><strong>8.2.2 应用层</strong></h3>

<p>应用层的核心职能：编排领域服务、事务管理、发布应用事件。</p>

<pre><code>├── assembler                              // 装配器，将DTO转换为DO
│   ├── ResultAssembler.java
│   └── TotalResultAssembler.java
├── dto                                    // DTO(Data Transfer Object)对象
│   ├── cmd                                // 命令相关的DTO对象
│   │   ├── ComputeTotalResultCmd.java
│   │   ├── EnterResultCmd.java
│   │   └── ModifyResultCmd.java
│   ├── event                             // 应用事件相关的DTO对象, subscriber负责接收
│   └── qry                               // 查询相关的DTO对象
└── service                                // 应用服务
    ├── ResultApplicationService.java
    ├── event                              // 应用事件，用于发布
    └── adapter                            // 防腐层适配器接口

</code></pre>

<h3 id="8-2-3-领域层"><strong>8.2.3 领域层</strong></h3>

<p>代码组织以聚合为基本单元。</p>

<pre><code>├── result                                 // 成绩聚合
│   ├── entity                            // 成绩聚合内的实体
│   │   └── Result.java
│   ├── service                           // 领域服务
│   │   ├── ResultDomainService.java
│   │   ├── event                         // 领域事件
│   │   ├── adapter                       // 防腐层适配器接口
│   │   ├── factory                       // 工厂
│   │   └── repository                    // 资源库
│   │       └── ResultRepository.java
│   └── valueobject                        // 成绩聚合的值对象
│       ├── GPA.java
│       ├── ResultUK.java
│       ├── SchoolYear.java
│       └── Semester.java
└── totalresult                             // 总成绩聚合
    ├── ... 这段有点长，其代码结构与成绩聚合一致，因此省略 ...

</code></pre>

<h3 id="8-2-4-基础设施实现层"><strong>8.2.4 基础设施实现层</strong></h3>

<p>该层主要提供领域层接口（资源库、防腐层接口）和应用层接口（防腐层接口）的实现。</p>

<p>代码组织基本以聚合为基本单元。对于应用层的防腐层接口，则直接以 application 作为包名组织。</p>

<pre><code>├── application                                  // 应用层相关实现
│   └── adapter                                 // 防腐层适配器接口实现
│       ├── facade                              // 外观接口
│       └── translator                          // 转换器，DO -&gt; DTO
├── result                                       // 成绩聚合相关实现
│   ├── adapter
│   │   ├── facade
│   │   └── translator
│   └── repository                              // 成绩聚合资源库接口实现
│       └── ResultRepositoryImpl.java
└── totalresult                                  // 总成绩聚合相关实现
    ├── adapter
    │   ├── CourseAdapterImpl.java
    │   ├── facade
    │   └── translator
    └── repository
        └── TotalResultRepositoryImpl.java

</code></pre>

<h3 id="9-杂谈"><strong>9. 杂谈</strong></h3>

<h3 id="9-1-ddd-与微服务"><strong>9.1 DDD 与微服务</strong></h3>

<p><strong>微服务拆解</strong>指的是把一个单体服务拆分为粒度 “足够小” 的多个服务，而这里的 “足够小” 是一个主观的，没有任何标准的定义。尽管如此，我们对“<strong>微</strong>” 这个词还是有一些基本要求的：足够内聚，足够独立，足够完备，这才使得拆分出来的微服务收益大于投入，试想如果一个微服务提供的业务功能会牵扯到与其他众多微服务的协作，那岂不是芭比 Q 了。</p>

<p>而上述我们对微服务的基本要求，实际上与限界上下文的特征（最小完备，自我履行，稳定空间，独立进化）不谋而合，因此，我们可以把<strong>限界上下文映射为微服务</strong>。我在日常实践中，都是将限界上下文和微服务的关系进行一一对应的，但这不是绝对的！限界上下文是站在领域角度给出的逻辑边界，而微服务的设计往往还要考虑物理边界，以及实际的质量需求（性能，可用性，安全性等），比如当我们采用的是 CQRS 架构，领域模型会被分为命令模型和查询模型，虽然它们同属一个限界上下文，但是它们往往是物理隔离的。因此，限界上下文只能作为微服务拆分的指导，而拆分过程中需要考虑质量需求，架构设计等技术因素。</p>

<p><img src="https://pic1.zhimg.com/v2-8f613d8d15a3e081808c9fb3e2575a1c_r.jpg" alt="" /></p>

<h3 id="9-2-事务"><strong>9.2 事务</strong></h3>

<h3 id="9-2-1-本地事务"><strong>9.2.1 本地事务</strong></h3>

<p>上文在提及限界上下文识别和聚合设计的时候其实都提到需要考虑事务属性，即需要通过本地事务来保证业务规则的不变性 / 一致性。这里我们会疑惑的是：<strong>谁来承担管理事务的职责？事务管理的边界是什么？</strong></p>

<p><strong>应用层承担管理事务的职责</strong></p>

<p>事务本质是一种技术手段，而领域模型本身与技术无关，因此事务应该由应用层负责管理。</p>

<p><strong>事务管理的边界是聚合，有时限界上下文也可以</strong></p>

<p>资源库操作的基本单元是聚合，因此事务管理的边界是聚合便是自然而然得出的结论。这里需要考虑的是当需要保证事务属性的不仅仅只有资源库操作，还包括发布领域事件时（即保证聚合落库和事件发布的原子性），我们可能需要采用<strong>可靠事件模式</strong>，即通过把领域事件落库事件表来表示事件的发布。此时应用层在管理事务时就没什么心智负担了。当然，采用可靠事件模式实际是限制了领域模型的实现，也算是技术对领域模型的一种入侵吧，但相比于解放应用层而言，应该是利大于弊。</p>

<p>我们也知道，应用层的核心职责是负责编排和协调不同聚合的领域服务，而应用层又负责事务管理，自然我们能推到出事务管理的边界是多个聚合（即限界上下文）。但这里有两个关注点：</p>

<p>a）一般是出于质量需求（性能会好一些，时效性更高一些）；</p>

<p>b）同一个限界上下文内的多个聚合共享一个 DB。</p>

<h3 id="9-2-2-saga-事务"><strong>9.2.2 Saga 事务</strong></h3>

<p>为了避免耦合，DDD 主张通过柔性事务来保证跨聚合、跨限界上下文的最终一致性。而目前业界比较主流的应用是 Saga 模式：<strong>通过使用异步消息来协调一系列本地事务，从而维度多个服务之间的数据一致性</strong>。而另一个非常著名的柔性事务方案 TCC 为啥没有 Saga 契合呢？</p>

<p>TCC 共分为三个阶段：</p>

<ol>
<li>Try 阶段：准备阶段，对资源进行锁定或预留；</li>
<li>Confirm 阶段：提交阶段，执行实际的操作；</li>
<li>Cancel 阶段：补偿阶段，任意执行的操作出错了，就需要执行补偿，即释放 Try 阶段预留的资源。</li>
</ol>

<p>可以看到 TCC 实际对领域模型的侵入是比较大的：</p>

<p>a）TCC 要求领域模型设计时，定义相关的属性以支持资源锁定 / 预留的问题；</p>

<p>b）TCC 对服务接口定义做出了要求，领域模型需要提供 Try，Confirm 和 Cancel 相应的领域服务。</p>

<p>Saga 模式并不要求其对资源进行锁定 / 预留，而其补偿操作也是通过执行操作的<strong>逆操作</strong>来完成（比如支付的逆操作是退款）。而大部分情况下，完整的领域模型都会对外提供操作及其逆操作。</p>

<h3 id="10-参考"><strong>10. 参考</strong></h3>

<ol>
<li>《解耦 - 领域驱动设计》</li>
<li>《领域驱动设计：软件核心复杂性应对之道》</li>
<li>《实现领域驱动设计》</li>
<li>《微服务架构设计模式》</li>
<li>极客时间《DDD 实战课》</li>
<li>极客时间《如何落地业务建模》</li>
<li>《领域驱动设计精粹》</li>
</ol>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://geek.zshipu.com/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://geek.zshipu.com/post/tlg/output/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%8E%8C%E6%8F%A1%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD/">https://geek.zshipu.com/post/tlg/output/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%8E%8C%E6%8F%A1%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%AC%AC-2-%E9%83%A8%E5%88%86%E9%99%84%E6%8F%92%E5%9B%BE/">浏览器的工作原理 - 获取数据（第 2 部分，附插图）🚀</a></li>
        
        <li><a href="/post/%E4%B8%BA%E4%BB%80%E4%B9%88-Flutter-%E4%BD%BF%E7%94%A8-Dart/">为什么 Flutter 使用 Dart</a></li>
        
        <li><a href="/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%B8%A6%E6%8F%92%E5%9B%BE%EF%B8%8F/">浏览器的工作原理 - 导航（第 1 部分，带插图）⚙️💥</a></li>
        
        <li><a href="/post/DDD-%E5%8D%81%E9%80%9A%E8%BF%87%E9%A2%84%E5%AE%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/">DDD-十、通过预定作业的最终一致性</a></li>
        
        <li><a href="/post/DDD-%E4%B9%9D%E4%BD%BF%E7%94%A8-Spring-%E5%A4%84%E7%90%86%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/">DDD-九、使用 Spring Data 发布领域事件</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            没有标签
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-geek"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://geek.zshipu.com/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://geek.zshipu.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://geek.zshipu.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://geek.zshipu.com/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%AC%AC-2-%E9%83%A8%E5%88%86%E9%99%84%E6%8F%92%E5%9B%BE/" title="浏览器的工作原理 - 获取数据（第 2 部分，附插图）🚀">浏览器的工作原理 - 获取数据（第 2 部分，附插图）🚀</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E4%B8%BA%E4%BB%80%E4%B9%88-Flutter-%E4%BD%BF%E7%94%A8-Dart/" title="为什么 Flutter 使用 Dart">为什么 Flutter 使用 Dart</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%B8%A6%E6%8F%92%E5%9B%BE%EF%B8%8F/" title="浏览器的工作原理 - 导航（第 1 部分，带插图）⚙️💥">浏览器的工作原理 - 导航（第 1 部分，带插图）⚙️💥</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E5%8D%81%E9%80%9A%E8%BF%87%E9%A2%84%E5%AE%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/" title="DDD-十、通过预定作业的最终一致性">DDD-十、通过预定作业的最终一致性</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E4%B9%9D%E4%BD%BF%E7%94%A8-Spring-%E5%A4%84%E7%90%86%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/" title="DDD-九、使用 Spring Data 发布领域事件">DDD-九、使用 Spring Data 发布领域事件</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E5%85%AB%E4%BD%BF%E7%94%A8-Spring-Data-%E5%8F%91%E5%B8%83%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/" title="DDD-八、使用 Spring 处理领域事件">DDD-八、使用 Spring 处理领域事件</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E4%B8%83%E5%9C%A8-Hibernate-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%81%9A%E5%90%88%E6%A0%87%E8%AF%86%E7%AC%A6/" title="DDD-七、在 Hibernate 中使用值对象作为聚合标识符">DDD-七、在 Hibernate 中使用值对象作为聚合标识符</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E5%85%AD%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E5%AD%98%E5%82%A8%E5%BA%93/" title="DDD-六、使用 Spring Data 构建存储库">DDD-六、使用 Spring Data 构建存储库</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E4%BA%94%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E8%81%9A%E5%90%88/" title="DDD-五、使用 Spring Data 构建聚合">DDD-五、使用 Spring Data 构建聚合</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/DDD-%E5%9B%9B%E5%9C%A8-JPA-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1/" title="DDD-四、在 JPA 中使用值对象">DDD-四、在 JPA 中使用值对象</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【2019双12】ALL IN CLoud 低至1折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1_rYHo7P2gK0jSZPxXXacQpXa-690-388.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="助力产业智慧升级，云服务器首年88元起，更有千元代金券礼包免费领！" target="_blank" style="color:red">
                
                    <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-7c71532bd4935fbdd9a67c1a71e577b1767b805c.200%E7%89%88%E6%9C%ACB.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【渠道专享低折扣】11月特惠 限时2折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1hblJl7Y2gK0jSZFgXXc5OFXa-750-400.jpg">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://geek.zshipu.com/categories/flutter/">flutter (30)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/iOS/">iOS (7)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/unix/">unix (9)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/%E7%AE%97%E6%B3%95/">算法 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://geek.zshipu.com/tags/BI/">BI</a>
    
    <a href="https://geek.zshipu.com/tags/DDD/">DDD</a>
    
    <a href="https://geek.zshipu.com/tags/DDD%E5%AE%9E%E6%88%98/">DDD实战</a>
    
    <a href="https://geek.zshipu.com/tags/DevOps/">DevOps</a>
    
    <a href="">JS</a>
    
    <a href="https://geek.zshipu.com/tags/Java/">Java</a>
    
    <a href="https://geek.zshipu.com/tags/JavaScript/">JavaScript</a>
    
    <a href="https://geek.zshipu.com/tags/Monorepo/">Monorepo</a>
    
    <a href="https://geek.zshipu.com/tags/NextJS/">NextJS</a>
    
    <a href="">Nextjs</a>
    
    <a href="https://geek.zshipu.com/tags/Typora/">Typora</a>
    
    <a href="https://geek.zshipu.com/tags/WebRTC/">WebRTC</a>
    
    <a href="https://geek.zshipu.com/tags/android/">android</a>
    
    <a href="https://geek.zshipu.com/tags/css/">css</a>
    
    <a href="https://geek.zshipu.com/tags/flutter/">flutter</a>
    
    <a href="https://geek.zshipu.com/tags/game/">game</a>
    
    <a href="https://geek.zshipu.com/tags/go/">go</a>
    
    <a href="https://geek.zshipu.com/tags/golang/">golang</a>
    
    <a href="">java</a>
    
    <a href="https://geek.zshipu.com/tags/js/">js</a>
    
    <a href="https://geek.zshipu.com/tags/mysql/">mysql</a>
    
    <a href="https://geek.zshipu.com/tags/nifi/">nifi</a>
    
    <a href="https://geek.zshipu.com/tags/npm/">npm</a>
    
    <a href="https://geek.zshipu.com/tags/python/">python</a>
    
    <a href="https://geek.zshipu.com/tags/reactjs/">reactjs</a>
    
    <a href="https://geek.zshipu.com/tags/sqllit/">sqllit</a>
    
    <a href="https://geek.zshipu.com/tags/vuejs/">vuejs</a>
    
    <a href="https://geek.zshipu.com/tags/web/">web</a>
    
    <a href="https://geek.zshipu.com/tags/web3/">web3</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%B9%A6%E7%B1%8D/">书籍</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%88%86%E8%AF%8D/">分词</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%96%87%E6%91%98/">文摘</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9E%B6%E6%9E%84/">架构</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
    <a href="https://geek.zshipu.com/tags/%E8%B5%B7%E6%AD%A5/">起步</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://geek.zshipu.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>