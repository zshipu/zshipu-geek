<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Netty那点事（五）讲讲Handler | 知识铺的博客</title>
    <meta property="og:title" content="Netty那点事（五）讲讲Handler - 知识铺的博客">
    <meta property="og:type" content="article">
        
    <meta property="article:published_time" content='2022-05-01T20:02:57&#43;08:00'>
        
        
    <meta property="article:modified_time" content='2022-05-01T20:02:57&#43;08:00'>
        
    <meta name="Keywords" content="golang,go语言,go语言笔记,知识铺,java,android,博客,项目管理,python,软件架构,公众号,小程序">
    <meta name="description" content="Netty那点事（五）讲讲Handler">
        <meta name="author" content="知识铺">
        
    <meta property="og:url" content="https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/">
    <link rel="shortcut icon" href='/favicon.ico'  type="image/x-icon">

    <link rel="stylesheet" href='/css/normalize.css'>
    <link rel="stylesheet" href='/css/style.css'>
    <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    
    <script data-ad-client="ca-pub-2874221941555456" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    
    
    
    
    
    
    
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
    new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
    j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
    'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
    })(window,document,'script','dataLayer','GTM-WLWJSST');</script>
    
</head>


<body>

<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WLWJSST"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>

    <header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="https://geek.zshipu.com/">
                        知识铺的博客
                    </a>
                
                <p class="description">专注于Android、Java、Go语言(golang)、移动互联网、项目管理、软件架构</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://geek.zshipu.com/">首页</a>
                    
                    <a  href="https://geek.zshipu.com/archives/" title="归档">归档</a>
                    
                    <a  href="https://geek.zshipu.com/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>

    <div id="body">
        <div class="container">
            <div class="col-group">

                <div class="col-8" id="main">
                    
<div class="res-cons">
    <style type="text/css">
    .post-toc {
        position: fixed;
        width: 200px;
        margin-left: -210px;
        padding: 5px 10px;
        font-family: Athelas, STHeiti, Microsoft Yahei, serif;
        font-size: 12px;
        border: 1px solid rgba(0, 0, 0, .07);
        border-radius: 5px;
        background-color: rgba(255, 255, 255, 0.98);
        background-clip: padding-box;
        -webkit-box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        box-shadow: 1px 1px 2px rgba(0, 0, 0, .125);
        word-wrap: break-word;
        white-space: nowrap;
        -webkit-box-sizing: border-box;
        box-sizing: border-box;
        z-index: 999;
        cursor: pointer;
        max-height: 70%;
        overflow-y: auto;
        overflow-x: hidden;
    }

    .post-toc .post-toc-title {
        width: 100%;
        margin: 0 auto;
        font-size: 20px;
        font-weight: 400;
        text-transform: uppercase;
        text-align: center;
    }

    .post-toc .post-toc-content {
        font-size: 15px;
    }

    .post-toc .post-toc-content>nav>ul {
        margin: 10px 0;
    }

    .post-toc .post-toc-content ul {
        padding-left: 20px;
        list-style: square;
        margin: 0.5em;
        line-height: 1.8em;
    }

    .post-toc .post-toc-content ul ul {
        padding-left: 15px;
        display: none;
    }

    @media print,
    screen and (max-width:1057px) {
        .post-toc {
            display: none;
        }
    }
</style>
<div class="post-toc" style="position: absolute; top: 188px;">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
        <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#netty那点事-五-讲讲handler">Netty那点事（五）讲讲Handler</a></li>
<li><a href="#业务多线程执行">业务多线程执行</a></li>
<li><a href="#orderedmemoryawarethreadpoolexecutor">OrderedMemoryAwareThreadPoolExecutor</a>
<ul>
<li><a href="#使用netty-4-1进行内存感知通道处理-memory-aware-channel-handling-with-netty-4-1">使用Netty 4.1进行内存感知通道处理(Memory-aware Channel handling with Netty 4.1)</a></li>
</ul></li>
<li><a href="#executionhandler">ExecutionHandler</a></li>
<li><a href="#粘包-分包">粘包/分包</a>
<ul>
<li>
<ul>
<li><a href="#1-delimiterbasedframedecoder使用特殊字符作为分割-如果使用的话-注意特殊字符不能在真正要传输的内容中出现">1.  DelimiterBasedFrameDecoder使用特殊字符作为分割,如果使用的话,注意特殊字符不能在真正要传输的内容中出现,</a></li>
<li><a href="#2-fixedlengthframedecoder定长-这个也不常用">2.  FixedLengthFrameDecoder定长,这个也不常用</a></li>
<li><a href="#3-linebasedframedecoder-换行符在发送消息加上换行符-n">3.  LineBasedFrameDecoder 换行符在发送消息加上换行符 \n</a></li>
<li><a href="#4-lengthfieldbasedframedecoder和lengthfieldprepender">4.  LengthFieldBasedFrameDecoder和LengthFieldPrepender</a></li>
</ul></li>
<li><a href="#tcp粘包和拆包">TCP粘包和拆包</a></li>
</ul></li>
</ul></li>
<li><a href="#tcp粘包和拆包现象实例">TCP粘包和拆包现象实例</a></li>
<li><a href="#tcp粘包和拆包解决方案">TCP粘包和拆包解决方案</a></li>
<li><a href="#tcp粘包-拆包解决方案实现">TCP粘包, 拆包解决方案实现</a>
<ul>
<li><a href="#新建协议messageprotocol">新建协议MessageProtocol</a></li>
<li><a href="#新建编码器">新建编码器</a></li>
<li><a href="#新建解码器">新建解码器</a></li>
<li><a href="#新建服务器端">新建服务器端</a></li>
<li><a href="#新建客户端">新建客户端</a></li>
<li><a href="#测试">测试</a></li>
<li><a href="#faq">FAQ</a>
<ul>
<li><a href="#修改客户端发送消息数量">修改客户端发送消息数量</a></li>
<li><a href="#重新测试">重新测试</a></li>
<li><a href="#解决方案">解决方案</a></li>
<li><a href="#最终解决">最终解决</a></li>
<li><a href="#最终测试">最终测试</a></li>
<li><a href="#总结">总结</a></li>
</ul></li>
<li><a href="#编码-解码">编码/解码</a>
<ul>
<li><a href="#replayingdecoder">ReplayingDecoder</a></li>
<li><a href="#replayingdecoder-的原理"><code>ReplayingDecoder</code>的原理</a></li>
<li><a href="#继承基类-bytetomessagedecoder-的方式">继承基类<code>ByteToMessageDecoder</code>的方式</a></li>
<li><a href="#继承基类-replayingdecoder-的方式">继承基类<code>ReplayingDecoder</code>的方式</a></li>
<li><a href="#状态管理和-checkpoint-方法">状态管理和<code>checkpoint</code>方法</a></li>
</ul></li>
</ul></li>
<li><a href="#一-设计模式为啥老是用不好">一、设计模式为啥老是用不好？</a></li>
<li><a href="#二-在阅读开源框架源码中学习设计模式">二、在阅读开源框架源码中学习设计模式！</a>
<ul>
<li><a href="#1-在-netty-中如何自定义实现整数解码器">1、在 Netty 中如何自定义实现整数解码器？</a>
<ul>
<li><a href="#1-1-bytetomessagedecoder">1.1、ByteToMessageDecoder：</a></li>
<li><a href="#1-2-replayingdecoder">1.2、ReplayingDecoder：</a></li>
<li><a href="#1-3-测试用例">1.3、测试用例：</a></li>
</ul></li>
<li><a href="#2-解读-replayingdecoder-的原理">2、解读 ReplayingDecoder 的原理</a>
<ul>
<li><a href="#2-1-replayingdecoder的构造函数">2.1、ReplayingDecoder的构造函数：</a></li>
<li><a href="#2-2-继续探讨-replayingdecoderbytebuf">2.2、继续探讨 ReplayingDecoderByteBuf：</a></li>
</ul></li>
</ul></li>
<li><a href="#三-装饰器模式的特点">三、装饰器模式的特点</a>
<ul>
<li>
<ul>
<li><a href="#onetooneencoder">OneToOneEncoder</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
    </div>
</div>
<script type="text/javascript">
    $(document).ready(function () {
        var postToc = $(".post-toc");
        if (postToc.length) {
            var leftPos = $("#main").offset().left;
            if(leftPos<220){
                postToc.css({"width":leftPos-10,"margin-left":(0-leftPos)})
            }

            var t = postToc.offset().top - 20,
                a = {
                    start: {
                        position: "absolute",
                        top: t
                    },
                    process: {
                        position: "fixed",
                        top: 20
                    },
                };
            $(window).scroll(function () {
                var e = $(window).scrollTop();
                e < t ? postToc.css(a.start) : postToc.css(a.process)
            })
        }
    })
</script>
    <article class="post">
        <header>
            <h1 class="post-title">Netty那点事（五）讲讲Handler</h1>
        </header>
        <date class="post-meta meta-date">
            2022年5月1日
        </date>
        
        
        <div class="post-meta">
            <span id="busuanzi_container_page_pv">|<span id="busuanzi_value_page_pv"></span><span>
                    阅读</span></span>
        </div>
        
        
        <div class="post-content">
            

<h2 id="netty那点事-五-讲讲handler">Netty那点事（五）讲讲Handler</h2>

<p>至上部分为止，我觉得Netty的架构部分已经差不多说完了，还有些细节，可以在实践中慢慢掌握。</p>

<p>但是对于实践来说，Netty还有不容忽视的一部分：Netty提供了大量的ChannelHandler，可以完成不同的任务。用好它们，会使Netty在你手里更加得心应手！</p>

<h2 id="业务多线程执行">业务多线程执行</h2>

<h2 id="orderedmemoryawarethreadpoolexecutor">OrderedMemoryAwareThreadPoolExecutor</h2>

<h3 id="使用netty-4-1进行内存感知通道处理-memory-aware-channel-handling-with-netty-4-1">使用Netty 4.1进行内存感知通道处理(Memory-aware Channel handling with Netty 4.1)</h3>

<pre><code> 在4（3.x）之前的Netty版本中，有一种方法可以通过执行程序OrderedMemoryAwareThreadPoolExecutor内存来进行通道处理，并使用OrderedMemoryAwareThreadPoolExecutor执行程序对其进行排序，以执行给定Channel 。 3.x中的OrderedMemoryAwareThreadPoolExecutor将负责为通道排序事件处理，即使它们可以由不同的线程执行，也可以限制Channel使用的总内存。 如果通道内存（由于排队事件）超过某个阈值，则会阻止事件的执行，直到释放内存为止。  
 然而，在4.x中，没有这样的机制。 新的线程模型确实提供了对已执行事件的排序（因为特定通道的事件由单个线程执行），但似乎没有办法限制任何EventExecutorGroup单个Channel消耗的内存。 这意味着，如果无法做到这一点，发送到某个特定Channel的大量事件可能会耗尽服务器上的内存。 虽然我还没有对此事进行测试，但我认为在这里询问Netty 4.x的情况是否值得。  
 所以我的问题基本上是：  
 在Netty 4.x中使用带有ChannelHandler的EventExecutorGroup时，有没有办法限制单个Channel消耗的内存？ 
 
 
 这种情况是可能的。  
 但是，Netty为您的频道提供了ChannelOption.WRITE_BUFFER_WATER_MARK选项。 因此，当您在某个频道写入太快并且待处理消息队列超过ChannelOption.WRITE_BUFFER_WATER_MARK限制时，您写入的频道将变得不可写。 所以你可以用以下方法保护你的代码  
if (channel.isWritable()) {
}
 
 要么  
if (ctx.channel().isWritable()) {
}
 
 因此，当通道繁忙或缓慢消耗事件时，可防止内存耗尽。  
 您还可以为生成事件的通道更改ChannelOption.AUTO_READ ，并使用以下方法手动处理此事件：  
 ctx.channel().config().setAutoRead(false);
 
 因此，您的服务器将停止从生成它们的通道中读取事件。 这是展示这种方式的pull请求 。 
</code></pre>

<h2 id="executionhandler">ExecutionHandler</h2>

<p>如果业务处理handler耗时长，将严重影响可支持的并发数。</p>

<p>针对这一问题，经过学习，发现了可以使用ExecutionHandler来优化。</p>

<p>先来回顾一下没有使用ExecutionHandler优化的流程：</p>

<p>1）Boss线程（接收到客户端连接）-&gt;生成Channel-&gt;交给Worker线程池处理。</p>

<p>2）某个被分配到任务的Worker线程-&gt;读完已接收的数据到ChannelBuffer-&gt;触发ChannelPipeline中的ChannelHandler链来处理业务逻辑。</p>

<p>注意：执行ChannelHandler链的整个过程是同步的，如果业务逻辑的耗时较长，会将导致Work线程长时间被占用得不到释放，从而影响了整个服务器的并发处理能力。</p>

<p><strong>一、引入ExecutionHandler优化</strong></p>

<pre><code>//HttpServerPipelineFactory.java
private final ExecutionHandler executionHandler = new ExecutionHandler(
             new OrderedMemoryAwareThreadPoolExecutor(16, 1048576, 1048576));
public class HttpServerPipelineFactory implements ChannelPipelineFactory {
    @Override
    public ChannelPipeline getPipeline() throws Exception {
        ChannelPipeline pipeline = Channels.pipeline();
        pipeline.addLast(&quot;decoder&quot;, new HttpRequestDecoder());
        pipeline.addLast(&quot;encoder&quot;, new HttpResponseEncoder());
        pipeline.addLast(&quot;execution&quot;, executionHandler);
        pipeline.addLast(&quot;handler&quot;, new HttpServerHandler());
        return pipeline;
    }
}
</code></pre>

<p>当我们引入ExecutionHandler后，原本同步的ChannelHandler链在经过 ExecutionHandler后就结束了，它会被ChannelFactory的worker线程池所回收，而剩下的ChannelHandler链将由ExecutionHandler的线程池接手处理。</p>

<p>对于ExecutionHandler需要的线程池模型，Netty提供了两种可选：</p>

<p>​    1） MemoryAwareThreadPoolExecutor 通过对线程池内存的使用控制，可控制Executor中待处理任务的上限（超过上限时，后续进来的任务将被阻塞），并可控制单个Channel待处理任务的上限，防止内存溢出错误。但是它不维持同一Channel的ChannelEvents秩序，当经过ExecutionHandler后的ChannelHandler链中有不止一个Handler时，这些事件驱动存在混乱的可能。例如：</p>

<pre><code>
----------------------------------------&gt; Timeline -------------------------------------&gt;
Thread X: --- Channel A (Event 2) --- Channel A (Event 1) -----------------------------&gt;
Thread Y: --- Channel A (Event 3) --- Channel B (Event 2) --- Channel B (Event 3) ---&gt;
Thread Z: --- Channel B (Event 1) --- Channel B (Event 4) --- Channel A (Event 4) ---&gt;
</code></pre>

<p>​    2） OrderedMemoryAwareThreadPoolExecutor 是 MemoryAwareThreadPoolExecutor 的子类。除了MemoryAwareThreadPoolExecutor 的功能之外，它还可以保证同一Channel中处理的事件流的顺序性（不同Channel使用不同的key保持事件顺序），这主要是控制事件在异步处理模式下可能出现的错误事件顺序，但它并不保证同一 Channel中的事件都在一个线程中执行（通常也没必要）。例如：</p>

<pre><code>----------------------------------------&gt; Timeline ----------------------------------------&gt;`` ``Thread X: --- Channel A (Event ``1``) --.  .-- Channel B (Event ``2``) --- Channel B (Event ``3``) ---&gt;``                   ``\ /``                    ``X``                   ``/ \`` ``Thread Y: --- Channel B (Event ``1``) --``'  '``-- Channel A (Event ``2``) --- Channel A (Event ``3``) ---&gt;
</code></pre>

<p><strong>二、具有可伸缩性的OrderedMemoryAwareThreadPoolExecutor</strong><strong>使用策略</strong></p>

<p>在大多数情况下，我们会使用OrderedMemoryAwareThreadPoolExecutor，它的构造函数要求我们提供线程池的大小，在上面的代码中，我们使用了16这个具体的值，是一种很不好的写法，通常情况下，我们会使用配置文件使之可变，但是在实际部署时，并不能保证实施人员能很好的去调整，故提供如下的一种写法：</p>

<pre><code>
double coefficient = 0.8;  //系数
int numberOfCores = Runtime.getRuntime().availableProcessors();
int poolSize = (int)(numberOfCores / (1 - coefficient));
</code></pre>

<p>我们可以使用poolSize取代OrderedMemoryAwareThreadPoolExecutor(16, 1048576, 1048576)中的那个16，因为当一个系统被开发出来后，它是CPU密集型还是IO密集型是可评估的，通过评估其密集型，调整系数即可：CPU密集型接近0，IO密集型接近1。</p>

<h2 id="粘包-分包">粘包/分包</h2>

<h4 id="1-delimiterbasedframedecoder使用特殊字符作为分割-如果使用的话-注意特殊字符不能在真正要传输的内容中出现">1.  DelimiterBasedFrameDecoder使用特殊字符作为分割,如果使用的话,注意特殊字符不能在真正要传输的内容中出现,</h4>

<p>客户端</p>

<pre><code class="language-java">public class NettyClient {
    public static void main(String[] args) throws Exception {
//客户端需要一个事件循环组
        EventLoopGroup group = new NioEventLoopGroup ();
        try {
//创建客户端启动对象
//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap
            Bootstrap bootstrap = new Bootstrap ();
//设置相关参数
            bootstrap.group (group) //设置线程组
                    .channel (NioSocketChannel.class) // 使用 NioSocketChannel 作为客户端的通道实现
                    .handler (new ChannelInitializer&lt;SocketChannel&gt; () {
                        @Override
                        protected void initChannel(SocketChannel channel) throws Exception {
                            //字符串编码器
                            //channel.pipeline ().addLast (new StringEncoder ());
                            //long编码器
//                            channel.pipeline ().addLast (new OutEncoder ());
                            ByteBuf delimiter = Unpooled.copiedBuffer (&quot;$_$&quot;.getBytes ());
                            channel.pipeline ().addLast (new DelimiterBasedFrameDecoder (1024, delimiter));
                            //加入处理器
                            channel.pipeline ().addLast (new NettyClientHandler ());
                        }
                    });
            System.out.println (&quot;netty client start&quot;);
            //启动客户端去连接服务器端
            ChannelFuture channelFuture = bootstrap.connect (&quot;127.0.0.1&quot;, 9000).sync ();
            //对关闭通道进行监听
            channelFuture.channel ().closeFuture ().sync ();
        } finally {
            group.shutdownGracefully ();
        }
    }
}
</code></pre>

<p>客户端的handler</p>

<pre><code class="language-java">public class NettyClientHandler extends ChannelInboundHandlerAdapter {

    /**
     * 当客户端连接服务器完成就会触发该方法
     *
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println (&quot;发送消息&quot;);
        for (int i = 0; i &lt; 2; i++) {
            //拆包用分隔符
            ByteBuf buf = Unpooled.copiedBuffer (&quot;HelloServer$_$&quot;, CharsetUtil.UTF_8);
            ctx.writeAndFlush (buf);
        }
        ctx.fireChannelActive ();
    }
    //当通道有读取事件时会触发，即服务端发送数据给客户端
    //msg就额是接受的消息
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = ( ByteBuf ) msg;
        //因为已经使用了StringDecoder传过来的已经string类型
        System.out.println (&quot;收到服务端的消息:&quot; + buf);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace ();
        ctx.close ();
    }
}
</code></pre>

<p>服务端</p>

<pre><code class="language-java"> public static void main(String[] args) throws Exception {

        //创建两个线程组bossGroup和workerGroup,
        //NioEventLoop的个数默认为cpu核数的两倍
        // bossGroup只是处理连接请求 ,真正的和客户端业务处理，workerGroup完成
        EventLoopGroup bossGroup = new NioEventLoopGroup (1);
        EventLoopGroup workerGroup = new NioEventLoopGroup (8);
        try {
            //创建服务器端的引导对象
            ServerBootstrap bootstrap = new ServerBootstrap ();
            //将两个线程组放进引导对象
            bootstrap.group (bossGroup, workerGroup)
                    //NioServerSocketChannel服务端channel
                    .channel (NioServerSocketChannel.class)
                    // 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一个客户端连接。
                    // 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理
                    .option (ChannelOption.SO_BACKLOG, 1024)
                    .childHandler (new ChannelInitializer&lt;SocketChannel&gt; () {//创建通道初始化对象，设置初始化参数
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            //每一个链接过来(每一次创建channel)都会执行这个方法
                            System.out.println (&quot;初始化pipeline&quot;);
                            //编码,将String转码为ByteBuf
                            ch.pipeline ().addLast (&quot;encode&quot;, new StringEncoder ());
                            //用分割符处理粘包问题,分隔符可以是多个,
                            // 1024代表1024个字节内还没有找到分隔符抛出异常,TooLongFrameException,
                            //如果后续的Handler重写了exceptionCaught方法就会调用exceptionCaught方法
                            //DelimiterBasedFrameDecoder分割是转义成ByteBuf才分割的,所以如果添加了StringDecoder的话,
                            // 要把StringDecoder放在DelimiterBasedFrameDecoder的后面
                            ByteBuf delimiter = Unpooled.copiedBuffer (&quot;$_$&quot;.getBytes ());
                            ch.pipeline ().addLast (new DelimiterBasedFrameDecoder (1024, delimiter));
                            //解码,将ByteBuf解码为String
                            ch.pipeline ().addLast (&quot;decode&quot;, new StringDecoder ());
                            //handler一般都是放在最后面,建议一个就可以,如果业务复杂拆分多个,那在handler中调用fireXXX才会向下一个handler继续调用
                            ch.pipeline ().addLast (new NettyServerHandler ());
                        }
                    });
            System.out.println (&quot;netty server start。。&quot;);
            //绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况
            //启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕
            //我们可以去掉sync,添加事件监听,如果链接成功失败相对应的处理
            ChannelFuture cf = bootstrap.bind (9000);
            //给cf注册监听器，监听我们关心的事件
            cf.addListener (new ChannelFutureListener () {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    if (cf.isSuccess ()) {
                        //这里只是简单的打印,
                        System.out.println (&quot;监听端口9000成功&quot;);
                    } else {
                        System.out.println (&quot;监听端口9000失败&quot;);
                    }
                }
            });
            //对通道关闭进行监听，closeFuture是异步操作，监听通道关闭
            // 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成
            cf.channel ().closeFuture ().sync ();
        } finally {
            bossGroup.shutdownGracefully ();
            workerGroup.shutdownGracefully ();
        }
    }
}
</code></pre>

<p>服务端的handler</p>

<pre><code class="language-java">public class NettyServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {

        System.out.println (&quot;channelActive打印&quot; + Thread.currentThread ().getName () + ctx.channel ().remoteAddress ());
        //如果此handler后续还有handler的话,只有调用了fireXXX才能向下继续调用
        ctx.fireChannelActive ();
    }

    /**
     * 读取客户端发送的数据
     *
     * @param ctx 上下文对象, 含有通道channel，管道pipeline
     * @param msg 就是客户端发送的数据
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
         //使用了Stingdecoder所以这里接受到消息就是string类型的,不需要再次抓交换
         System.out.println (&quot;客户端发送消息是:&quot; +msg);
        //这是返回给客户端消息,如果使用StringEncoder,直接发String类型就可以,如果没有使用就先转为ByteBuf
        ByteBuf buf1 = Unpooled.copiedBuffer (&quot;HelloClient$_$&quot;, CharsetUtil.UTF_8);
        Channel channel = ctx.channel ();
        channel.writeAndFlush (buf1);
    }

    /**
     * 数据读取完毕处理方法,这个方法个人认为不太好用,
     *
     * @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
     * System.out.println (&quot;服务端接受消息结束&quot;);
     * ByteBuf buf = Unpooled.copiedBuffer (&quot;HelloClient$_$&quot;, CharsetUtil.UTF_8);
     * ctx.writeAndFlush (buf);
     * }
     */
    @Override
    //处理异常, 一般是需要关闭通道
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        System.out.println (cause.getMessage ());
        ctx.close ();
    }
}
</code></pre>

<h4 id="2-fixedlengthframedecoder定长-这个也不常用">2.  FixedLengthFrameDecoder定长,这个也不常用</h4>

<pre><code class="language-csharp">//每一个链接过来(每一次创建channel)都会执行这个方法

System.out.println (&quot;初始化pipeline&quot;);
//编码,将String转码为ByteBuf
ch.pipeline ().addLast (&quot;encode&quot;, new StringEncoder ());
//固定接受10个字节,如果超过这个字节数,超出的部分存在tcp的缓存中,等待下一次传输,超出的部分不会丢弃掉
ch.pipeline ().addLast (new FixedLengthFrameDecoder (10));
//解码,将ByteBuf解码为String
ch.pipeline ().addLast (&quot;decode&quot;, new StringDecoder ());
//handler一般都是放在最后面,建议一个就可以,如果业务复杂拆分多个,那在handler中调用fireXXX才会向下一个handler继续调用
ch.pipeline ().addLast (new NettyServerHandler ());
</code></pre>

<p>客户端发送的消息为HelloServer11个字节,可以看到超出的r会放到下一次的消息中,
 一个汉字为3个字节,所以很难在实际项目中使用
 客户端发送消息是:HelloServe
 客户端发送消息是:rHelloServ</p>

<h4 id="3-linebasedframedecoder-换行符在发送消息加上换行符-n">3.  LineBasedFrameDecoder 换行符在发送消息加上换行符 \n</h4>

<pre><code class="language-csharp">System.out.println (&quot;初始化pipeline&quot;);
//编码,将String转码为ByteBuf
ch.pipeline ().addLast (&quot;encode&quot;, new StringEncoder ());
//如果字节超过1024还没有找到换行符则抛出异常
ch.pipeline ().addLast (new LineBasedFrameDecoder (1024));
//解码,将ByteBuf解码为String
ch.pipeline ().addLast (&quot;decode&quot;, new StringDecoder ());
//handler一般都是放在最后面,建议一个就可以,如果业务复杂拆分多个,那在handler中调用fireXXX才会向下一个handler继续调用
ch.pipeline ().addLast (new NettyServerHandler ());
</code></pre>

<h4 id="4-lengthfieldbasedframedecoder和lengthfieldprepender">4.  LengthFieldBasedFrameDecoder和LengthFieldPrepender</h4>

<p>LengthFieldPrepender编码器,将发送消息的前面加上请求体的字节长度
 LengthFieldBasedFrameDecoder获取请求头的长度,根据长度获取请求体的信息
 个人认为这个比较常用
 客户端</p>

<pre><code class="language-java">public class NettyClient {
    public static void main(String[] args) throws Exception {
//客户端需要一个事件循环组
        EventLoopGroup group = new NioEventLoopGroup ();
        try {
//创建客户端启动对象
//注意客户端使用的不是 ServerBootstrap 而是 Bootstrap
            Bootstrap bootstrap = new Bootstrap ();
//设置相关参数
            bootstrap.group (group) //设置线程组
                    .channel (NioSocketChannel.class) // 使用 NioSocketChannel 作为客户端的通道实现
                    .handler (new ChannelInitializer&lt;SocketChannel&gt; () {
                        @Override
                        protected void initChannel(SocketChannel channel) throws Exception {
                            //规定标记消息提长度所占字节数
                            channel.pipeline().addLast(new LengthFieldPrepender (2));
                            channel.pipeline ().addLast (new NettyClientHandler ());
                        }
                    });
            System.out.println (&quot;netty client start&quot;);
            //启动客户端去连接服务器端
            ChannelFuture channelFuture = bootstrap.connect (&quot;127.0.0.1&quot;, 9000).sync ();
            //对关闭通道进行监听
            channelFuture.channel ().closeFuture ().sync ();
        } finally {
            group.shutdownGracefully ();
        }
    }
}
</code></pre>

<p>客户端handler</p>

<pre><code class="language-java">public class NettyClientHandler extends ChannelInboundHandlerAdapter {

    /**
     * 当客户端连接服务器完成就会触发该方法
     *
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        System.out.println (&quot;发送消息&quot;);
        for (int i = 0; i &lt; 2; i++) {
            //拆包用分隔符
            ByteBuf buf = Unpooled.copiedBuffer (&quot;HelloServer&quot;+i, CharsetUtil.UTF_8);
            ctx.writeAndFlush (buf);
        }
        ctx.fireChannelActive ();
    }
    //当通道有读取事件时会触发，即服务端发送数据给客户端
    //msg就额是接受的消息
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf buf = ( ByteBuf ) msg;
        //因为已经使用了StringDecoder传过来的已经string类型
        System.out.println (&quot;收到服务端的消息:&quot; + buf);
    }
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace ();
        ctx.close ();
    }
}
</code></pre>

<p>服务端</p>

<pre><code class="language-java">public class NettyServer {

    public static void main(String[] args) throws Exception {

        //创建两个线程组bossGroup和workerGroup,
        //NioEventLoop的个数默认为cpu核数的两倍
        // bossGroup只是处理连接请求 ,真正的和客户端业务处理，workerGroup完成
        EventLoopGroup bossGroup = new NioEventLoopGroup (1);
        EventLoopGroup workerGroup = new NioEventLoopGroup (8);
        try {
            //创建服务器端的引导对象
            ServerBootstrap bootstrap = new ServerBootstrap ();
            //将两个线程组放进引导对象
            bootstrap.group (bossGroup, workerGroup)
                    //NioServerSocketChannel服务端channel
                    .channel (NioServerSocketChannel.class)
                    // 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一个客户端连接。
                    // 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理
                    .option (ChannelOption.SO_BACKLOG, 1024)
                    .childHandler (new ChannelInitializer&lt;SocketChannel&gt; () {//创建通道初始化对象，设置初始化参数
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            //每一个链接过来(每一次创建channel)都会执行这个方法
                            System.out.println (&quot;初始化pipeline&quot;);

                            // 这里将LengthFieldBasedFrameDecoder添加到pipeline的首位，因为其需要对接收到的数据
                            // 进行长度字段解码，这里也会对数据进行粘包和拆包处理
                            //maxFrameLength：指定了每个包所能传递的最大数据包大小；
                            //lengthFieldOffset：指定了长度字段在字节码中的偏移量；
                            //lengthFieldLength：指定了长度字段所占用的字节长度；
                            //lengthAdjustment：对一些不仅包含有消息头和消息体的数据进行消息头的长度的调整，这样就可以只得到消息体的数据，这里的lengthAdjustment指定的就是消息头的长度；
                            //initialBytesToStrip：对于长度字段在消息头中间的情况，可以通过initialBytesToStrip忽略掉消息头以及长度字段占用的字节。
                            //1024最大数据包长度,包括长度所占的字节数
                            //0,因为第一字符开始就是长度
                            //2消息体长度所占字节数
                            //0因为第一个字符就是长度
                            //2去掉长度所占字节数,获取剩下的消息体
                            //注2就是下面LengthFieldPrepender中的规定长度所占的字节数
                            ch.pipeline().addLast(new LengthFieldBasedFrameDecoder (1024, 0, 2, 0, 2));
                            // LengthFieldPrepender是一个编码器，主要是在响应字节数据前面添加字节长度字段
                            ch.pipeline().addLast(new LengthFieldPrepender (2));
                            //handler一般都是放在最后面,建议一个就可以,如果业务复杂拆分多个,那在handler中调用fireXXX才会向下一个handler继续调用
                            //StringDecoder要放到LengthFieldBasedFrameDecoder后面,对得到消息体的ByteBuf转码为String类型,个人认为这个比较常用
                            ch.pipeline ().addLast (&quot;encode&quot;, new StringDecoder ());
                            ch.pipeline ().addLast (new NettyServerHandler ());
                        }
                    });
            System.out.println (&quot;netty server start。。&quot;);
            //绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况
            //启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕
            //我们可以去掉sync,添加事件监听,如果链接成功失败相对应的处理
            ChannelFuture cf = bootstrap.bind (9000);
            //给cf注册监听器，监听我们关心的事件
            cf.addListener (new ChannelFutureListener () {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    if (cf.isSuccess ()) {
                        //这里只是简单的打印,
                        System.out.println (&quot;监听端口9000成功&quot;);
                    } else {
                        System.out.println (&quot;监听端口9000失败&quot;);
                    }
                }
            });
            //对通道关闭进行监听，closeFuture是异步操作，监听通道关闭
            // 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成
            cf.channel ().closeFuture ().sync ();
        } finally {
            bossGroup.shutdownGracefully ();
            workerGroup.shutdownGracefully ();
        }
    }
}
</code></pre>

<p>服务端handler</p>

<pre><code class="language-java">/**
 * 继承了ChannelInboundHandlerAdapter 属于Inbound,输入的处理器
 */
@ChannelHandler.Sharable
public class NettyServerHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {

        System.out.println (&quot;channelActive打印&quot; + Thread.currentThread ().getName () + ctx.channel ().remoteAddress ());
        //如果此handler后续还有handler的话,只有调用了fireXXX才能向下继续调用
        ctx.fireChannelActive ();
    }

    /**
     * 读取客户端发送的数据
     *
     * @param ctx 上下文对象, 含有通道channel，管道pipeline
     * @param msg 就是客户端发送的数据
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
         //使用了Stingdecoder所以这里接受到消息就是string类型的,不需要再次抓交换
         System.out.println (&quot;客户端发送消息是:&quot; +msg);
    }

    /**
     * 数据读取完毕处理方法,这个方法个人认为不太好用,
     *
     * @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
     * System.out.println (&quot;服务端接受消息结束&quot;);
     * ByteBuf buf = Unpooled.copiedBuffer (&quot;HelloClient$_$&quot;, CharsetUtil.UTF_8);
     * ctx.writeAndFlush (buf);
     * }
     */
    @Override
    //处理异常, 一般是需要关闭通道
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        System.out.println (cause.getMessage ());
        ctx.close ();
    }
}
</code></pre>

<h3 id="tcp粘包和拆包">TCP粘包和拆包</h3>

<ol>
<li>TCP是面向连接的, 面向流的, 提供可靠性服务, 收发两端(客户端和服务器端) 都有一一成对的Socket,因此发送端为了将多个发给接收端的包, 更有效的发给对方, 使用了优化算法(Nagle算法),将多次间隔较小且数据量小的数据,合并成一个大的数据块,然后进行封包, 这样做虽然提高了效率,但是接收端就难于分辨出完整的数据包了,因为面向流的通信是无消息保护边界的</li>

<li><p>由于TCP无消息保护边界, 需要在接收端处理消息边界问题, 也就是我们所说的粘包,拆包问题,看一张图</p></li>

<li><p>示意图TCP粘包,拆包图解</p></li>
</ol>

<p><a href="https://img2022.cnblogs.com/blog/1979837/202201/1979837-20220121161608521-1989139836.png"><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012017422.png" alt="img" /></a></p>

<p>对图的说明</p>

<p>假设客户端分别发送了两个数据包D1和D2给服务端, 由于服务端一次读取到字节数是不确定的,故有可能存在以下四种情况</p>

<ol>
<li>服务端分别两次读取到了两个独立的数据包, 分别是D1 和 D2, 没有粘包和拆包</li>

<li><p>服务端一次接收到了两个数据包D1和D2粘在了一起,称之为TCP粘包</p></li>

<li><p>服务端分两次读取到了数据包, 第一次读取到了完整的D1包和D2包的部分内容, 第二次读取到了D2包的剩余部分, 称之为TCP拆包</p></li>

<li><p>服务器分两次读取到了数据包, 第一次读取到了D1包的部分内容D1_1, 第二次读取到了D1包的剩余部分D1_2, 和完整的D2包</p></li>
</ol>

<h1 id="tcp粘包和拆包现象实例">TCP粘包和拆包现象实例</h1>

<p>在编写Netty程序时, 如果没有做处理,就会发生粘包和拆包问题</p>

<p>看一个具体的实例</p>

<p>NettyServer</p>

<pre><code>package com.dance.netty.netty.tcp;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

public class NettyServer {

    public static void main(String[] args) {

        NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
        NioEventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup,workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true)
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline pipeline = ch.pipeline();
                            pipeline.addLast(new NettyServerHandler());
                        }
                    });
            ChannelFuture sync = serverBootstrap.bind(&quot;127.0.0.1&quot;, 7000).sync();
            System.out.println(&quot;server is ready ......&quot;);
            sync.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }

    }

    static class NettyServerHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {

        private int count = 0;

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
            byte[] bytes = new byte[msg.readableBytes()];
            msg.readBytes(bytes);
            count++;
            System.out.println(&quot;服务器第&quot;+count+&quot;次接收到来自客户端的数据:&quot; + new String(bytes, StandardCharsets.UTF_8));
            // 服务器回送数据给客户端 回送随机的UUID给客户端
            ctx.writeAndFlush(Unpooled.copiedBuffer(UUID.randomUUID().toString(),StandardCharsets.UTF_8));
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
            cause.printStackTrace();
        }
    }

}
</code></pre>

<p>NettyClient</p>

<pre><code>package com.dance.netty.netty.tcp;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.nio.charset.StandardCharsets;

public class NettyClient {
    public static void main(String[] args) {
        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(eventExecutors)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline pipeline = ch.pipeline();
                            pipeline.addLast(new NettyClientHandler());
                        }
                    });
            ChannelFuture sync = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync();
            sync.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            eventExecutors.shutdownGracefully();
        }
    }

    static class NettyClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; {

        private int count = 0;

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            // 连续发送10条数据
            for (int i = 0; i &lt; 10; i++) {
                ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello,server!&quot; + i, StandardCharsets.UTF_8));
            }
        }

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception {
            byte[] bytes = new byte[msg.readableBytes()];
            msg.readBytes(bytes);
            // 接收服务器的返回
            count++;
            System.out.println(&quot;客户端第&quot;+count+&quot;次接收服务端的回送:&quot; + new String(bytes, StandardCharsets.UTF_8));
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
            cause.printStackTrace();
        }
    }
}
</code></pre>

<p>执行结果</p>

<p>Server</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
server is ready ......
服务器第1次接收到来自客户端的数据:hello,server!0hello,server!1hello,server!2hello,server!3hello,server!4hello,server!5hello,server!6hello,server!7hello,server!8hello,server!9
服务器第1次接收到来自客户端的数据:hello,server!0
服务器第2次接收到来自客户端的数据:hello,server!1
服务器第3次接收到来自客户端的数据:hello,server!2hello,server!3hello,server!4
服务器第4次接收到来自客户端的数据:hello,server!5hello,server!6
服务器第5次接收到来自客户端的数据:hello,server!7hello,server!8hello,server!9
</code></pre>

<p>Client1</p>

<pre><code>客户端第1次接收服务端的回送:84653e99-0e7f-431d-a897-c215af959a3b
</code></pre>

<p>Client2</p>

<pre><code>客户端第1次接收服务端的回送:6f3b0e79-2f40-4066-bb6b-80f988ecec116b6bbd94-b345-46d6-8d36-a114534331a850628e04-ece1-4f58-b684-d30189f6cf26b2139027-6bda-4d40-9238-9fc0e59bc7a64b568ffe-f616-4f48-8f1c-05ecf3e817ee
</code></pre>

<p>分析:</p>

<p>服务器启动后到server is ready &hellip;&hellip;</p>

<p>第一个客户端启动后 TCP将10次发送直接封包成一次直接发送,所以导致了服务器一次就收到了所有的数据,产生了TCP粘包,拆包的问题</p>

<p>第二客户端启动后 TCP将10次发送分别封装成了5次请求,产生粘包,拆包问题</p>

<h1 id="tcp粘包和拆包解决方案">TCP粘包和拆包解决方案</h1>

<ol>
<li>使用自定义协议 + 编解码器来解决</li>
<li>关键就是要解决 服务器每次读取数据长度的问题, 这个问题解决, 就不会出现服务器多读或少读数据的问题,从而避免TCP粘包和拆包</li>
</ol>

<h1 id="tcp粘包-拆包解决方案实现">TCP粘包, 拆包解决方案实现</h1>

<ol>
<li>要求客户端发送5个Message对象, 客户端每次发送一个Message对象</li>
<li>服务器端每次接收一个Message, 分5次进行解码, 每读到一个Message, 会回复一个Message对象给客户端</li>
</ol>

<p><a href="https://img2022.cnblogs.com/blog/1979837/202201/1979837-20220121161608529-484933126.png"><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012017423.png" alt="img" /></a></p>

<h2 id="新建协议messageprotocol">新建协议MessageProtocol</h2>

<pre><code>package com.dance.netty.netty.protocoltcp;

/**
 * 消息协议
 */
public class MessageProtocol {

    private int length;

    private byte[] content;

    public MessageProtocol() {
    }

    public MessageProtocol(int length, byte[] content) {
        this.length = length;
        this.content = content;
    }

    public int getLength() {
        return length;
    }

    public void setLength(int length) {
        this.length = length;
    }

    public byte[] getContent() {
        return content;
    }

    public void setContent(byte[] content) {
        this.content = content;
    }
}
</code></pre>

<h2 id="新建编码器">新建编码器</h2>

<pre><code>package com.dance.netty.netty.protocoltcp;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.MessageToByteEncoder;

/**
 * 自定义协议编码器
 */
public class MyMessageProtocolEncoder extends MessageToByteEncoder&lt;MessageProtocol&gt; {
    @Override
    protected void encode(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out) throws Exception {
//        System.out.println(&quot;自定义协议----&gt;开始编码&quot;);
        // 开始发送数据
        out.writeInt(msg.getLength()); // 优先发送长度,定义边界
        out.writeBytes(msg.getContent());
//        System.out.println(&quot;自定义协议----&gt;编码完成&quot;);
    }
}
</code></pre>

<h2 id="新建解码器">新建解码器</h2>

<pre><code>package com.dance.netty.netty.protocoltcp;

import io.netty.buffer.ByteBuf;
import io.netty.channel.ChannelHandlerContext;
import io.netty.handler.codec.ByteToMessageDecoder;

import java.util.List;

public class MyMessageProtocolDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception {
//        System.out.println(&quot;自定义协议----&gt;开始解码&quot;);
        // 获取定义的边界长度
        int length = in.readInt();
        if(in.readableBytes() &gt;= length){
            // 根据长度读取数据
            byte[] bytes = new byte[length];
            in.readBytes(bytes);
            // 反构造成MessageProtocol
            MessageProtocol messageProtocol = new MessageProtocol(length, bytes);
            out.add(messageProtocol);
//            System.out.println(&quot;自定义协议----&gt;解码完成&quot;);
        }else{
            // 内容长度不够
        }
    }
}
</code></pre>

<h2 id="新建服务器端">新建服务器端</h2>

<pre><code>package com.dance.netty.netty.protocoltcp;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

import java.nio.charset.StandardCharsets;
import java.util.UUID;

public class NettyServer {

    public static void main(String[] args) {

        NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
        NioEventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup,workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true)
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline pipeline = ch.pipeline();
                            // 加入自定义协议编解码器
                            pipeline.addLast(new MyMessageProtocolDecoder());
                            pipeline.addLast(new MyMessageProtocolEncoder());
                            pipeline.addLast(new NettyServerHandler());
                        }
                    });
            ChannelFuture sync = serverBootstrap.bind(&quot;127.0.0.1&quot;, 7000).sync();
            System.out.println(&quot;server is ready ......&quot;);
            sync.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }

    }

    static class NettyServerHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; {

        private int count = 0;

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception {
            byte[] bytes = msg.getContent();
            count++;
            System.out.println(&quot;服务器第&quot;+count+&quot;次接收到来自客户端的数据:&quot; + new String(bytes, StandardCharsets.UTF_8));
            // 服务器回送数据给客户端 回送随机的UUID给客户端
            byte[] s = UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8);
            ctx.writeAndFlush(new MessageProtocol(s.length,s));
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
            cause.printStackTrace();
        }
    }

}
</code></pre>

<h2 id="新建客户端">新建客户端</h2>

<pre><code>package com.dance.netty.netty.protocoltcp;

import io.netty.bootstrap.Bootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;

import java.nio.charset.StandardCharsets;

public class NettyClient {
    public static void main(String[] args) {
        NioEventLoopGroup eventExecutors = new NioEventLoopGroup();
        try {
            Bootstrap bootstrap = new Bootstrap();
            bootstrap.group(eventExecutors)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline pipeline = ch.pipeline();
                            // 加入自定义分割符号
//                            ByteBuf delimiter = Unpooled.copiedBuffer(&quot;\r\n&quot;.getBytes());
//                            pipeline.addFirst(new DelimiterBasedFrameDecoder(8192, delimiter));

                            // 添加自定义协议编解码器
                            pipeline.addLast(new MyMessageProtocolDecoder());
                            pipeline.addLast(new MyMessageProtocolEncoder());
                            pipeline.addLast(new NettyClientHandler());
                        }
                    });
            ChannelFuture sync = bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync();
            sync.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            eventExecutors.shutdownGracefully();
        }
    }

    static class NettyClientHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; {

        private int count = 0;

        @Override
        public void channelActive(ChannelHandlerContext ctx) throws Exception {
            // 连续发送10条数据
            for (int i = 0; i &lt; 10; i++) {
                String msg = &quot;今天天气冷, 打火锅&quot; + i;
                byte[] bytes = msg.getBytes(StandardCharsets.UTF_8);
                // 使用自定义协议
                MessageProtocol messageProtocol = new MessageProtocol(bytes.length, bytes);
                ctx.writeAndFlush(messageProtocol);
            }
        }

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception {
            byte[] bytes = msg.getContent();
            // 接收服务器的返回
            count++;
            System.out.println(&quot;客户端第&quot;+count+&quot;次接收服务端的回送:&quot; + new String(bytes, StandardCharsets.UTF_8));
        }

        @Override
        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
            ctx.close();
            cause.printStackTrace();
        }
    }
}
</code></pre>

<h2 id="测试">测试</h2>

<p>发送10次</p>

<p>服务器端</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
server is ready ......
服务器第1次接收到来自客户端的数据:今天天气冷, 打火锅0
......
服务器第10次接收到来自客户端的数据:今天天气冷, 打火锅9
</code></pre>

<p>客户端</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
客户端第1次接收服务端的回送:a6b69f1c-daba-435a-802a-c19a6350ca94
......
客户端第10次接收服务端的回送:5af5c297-8668-48aa-b8c4-35656142f591
</code></pre>

<p>ok,没有问题, 但是真的没有问题吗?答案是有问题</p>

<h2 id="faq">FAQ</h2>

<p>发送1000次</p>

<h3 id="修改客户端发送消息数量">修改客户端发送消息数量</h3>

<pre><code>@Override
public void channelActive(ChannelHandlerContext ctx) throws Exception {
    // 连续发送10条数据
    for (int i = 0; i &lt; 1000; i++) {
        ......
    }
}
</code></pre>

<h3 id="重新测试">重新测试</h3>

<p>服务器端</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
server is ready ......
服务器第1次接收到来自客户端的数据:今天天气冷, 打火锅0
......
服务器第31次接收到来自客户端的数据:今天天气冷, 打火锅30
服务器第32次接收到来自客户端的数据:今天天气冷, 打火锅31
io.netty.handler.codec.DecoderException: java.lang.NegativeArraySizeException
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
    at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:265)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:340)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1412)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:362)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:348)
    at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:943)
    at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:141)
    at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:645)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:580)
    at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:497)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:459)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.NegativeArraySizeException
    at com.dance.netty.netty.protocoltcp.MyMessageProtocolDecoder.decode(MyMessageProtocolDecoder.java:17)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
    ... 16 more
io.netty.handler.codec.DecoderException: java.lang.IndexOutOfBoundsException: readerIndex(1022) + length(4) exceeds writerIndex(1024): PooledUnsafeDirectByteBuf(ridx: 1022, widx: 1024, cap: 1024)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:459)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:392)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInputClosed(ByteToMessageDecoder.java:359)
    at io.netty.handler.codec.ByteToMessageDecoder.channelInactive(ByteToMessageDecoder.java:342)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
    at io.netty.channel.AbstractChannelHandlerContext.fireChannelInactive(AbstractChannelHandlerContext.java:224)
    at io.netty.channel.DefaultChannelPipeline$HeadContext.channelInactive(DefaultChannelPipeline.java:1407)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:245)
    at io.netty.channel.AbstractChannelHandlerContext.invokeChannelInactive(AbstractChannelHandlerContext.java:231)
    at io.netty.channel.DefaultChannelPipeline.fireChannelInactive(DefaultChannelPipeline.java:925)
    at io.netty.channel.AbstractChannel$AbstractUnsafe$8.run(AbstractChannel.java:822)
    at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
    at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:404)
    at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:463)
    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:886)
    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
    at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.IndexOutOfBoundsException: readerIndex(1022) + length(4) exceeds writerIndex(1024): PooledUnsafeDirectByteBuf(ridx: 1022, widx: 1024, cap: 1024)
    at io.netty.buffer.AbstractByteBuf.checkReadableBytes0(AbstractByteBuf.java:1403)
    at io.netty.buffer.AbstractByteBuf.readInt(AbstractByteBuf.java:786)
    at com.dance.netty.netty.protocoltcp.MyMessageProtocolDecoder.decode(MyMessageProtocolDecoder.java:14)
    at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:489)
    at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:428)
    ... 17 more
</code></pre>

<p>what ? 直接报错了, 数组下标越界, 读索引1022 + 长度4 &gt; 写缩影1024了</p>

<p>这个是什么问题呢 ? 我看网上关于这个BUG的解决方案很少,基本没有, 好多都是贴问题的, 我翻了将近1个小时,才找到一个大佬写的一篇文章解决了, 感谢大佬</p>

<p>博客地址:</p>

<pre><code>https://blog.csdn.net/u011035407/article/details/80454511
</code></pre>

<p>问题描述:</p>

<p>这样在刚开始的工作中数据包传输没有问题，不过数据包的大小超过<strong>512b</strong>的时候就会抛出异常了。</p>

<h3 id="解决方案">解决方案</h3>

<p>配合解码器DelimiterBasedFrameDecoder一起使用，在数据包的末尾使用换行符\n表示本次数据包已经结束，当DelimiterBasedFrameDecoder把数据切割之后，再使用ByteToMessageDecoder实现decode方法把数据流转换为Message对象。</p>

<p>我们在ChannelPipeline加入DelimiterBasedFrameDecoder解码器</p>

<p>客户端和服务器端都加</p>

<pre><code>//使用\n作为分隔符
pipeline.addLast(new LoggingHandler(LogLevel.INFO));
pipeline.addLast(new DelimiterBasedFrameDecoder(8192, Delimiters.lineDelimiter()));
</code></pre>

<p>在MessageToByteEncoder的实现方法encode()增加out.writeBytes(new byte[]{&rsquo;\n&rsquo;});</p>

<pre><code>//在写出字节流的末尾增加\n表示数据结束
out.writeBytes(new byte[]{'\n'});
</code></pre>

<p>这时候就可以愉快的继续处理数据了。
等我还没有高兴半天的时候，问题又来了。还是一样的问题</p>

<p>等等等，，，怎么又报错了，不是已经加了黏包处理了吗？？，解决问题把，首先看解析的数据包结构</p>

<pre><code>         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 01 01 01 00 00 00 06 00 00 01 0a 7b 22 69 64 22 |...........{&quot;id&quot;|
|00000010| 3a 33 2c 22 75 73 65 72 6e 61 6d 65 22 3a 22 31 |:3,&quot;username&quot;:&quot;1|
|00000020| 38 35 30 30 33 34 30 31 36 39 22 2c 22 6e 69 63 |8500340169&quot;,&quot;nic|
|00000030| 6b 6e 61 6d 65 22 3a 22 e4 bb 96 e5 9b 9b e5 a4 |kname&quot;:&quot;........|
|00000040| a7 e7 88 b7 22 2c 22 72 6f 6f 6d 49 64 22 3a 31 |....&quot;,&quot;roomId&quot;:1|
|00000050| 35 32 37 32 33 38 35 36 39 34 37 34 2c 22 74 65 |527238569474,&quot;te|
|00000060| 61 6d 4e 61 6d 65 22 3a 22 e4 bf 84 e7 bd 97 e6 |amName&quot;:&quot;.......|
|00000070| 96 af 22 2c 22 75 6e 69 74 73 22 3a 7b 22 75 6e |..&quot;,&quot;units&quot;:{&quot;un|
|00000080| 69 74 31 22 3a 7b 22 78 22 3a 31 30 2e 30 2c 22 |it1&quot;:{&quot;x&quot;:10.0,&quot;|
|00000090| 79 22 3a 31 30 2e 30 7d 2c 22 75 6e 69 74 32 22 |y&quot;:10.0},&quot;unit2&quot;|
|000000a0| 3a 7b 22 78 22 3a 31 30 2e 30 2c 22 79 22 3a 31 |:{&quot;x&quot;:10.0,&quot;y&quot;:1|
|000000b0| 30 2e 30 7d 2c 22 75 6e 69 74 33 22 3a 7b 22 78 |0.0},&quot;unit3&quot;:{&quot;x|
|000000c0| 22 3a 31 30 2e 30 2c 22 79 22 3a 31 30 2e 30 7d |&quot;:10.0,&quot;y&quot;:10.0}|
|000000d0| 2c 22 75 6e 69 74 34 22 3a 7b 22 78 22 3a 31 30 |,&quot;unit4&quot;:{&quot;x&quot;:10|
|000000e0| 2e 30 2c 22 79 22 3a 31 30 2e 30 7d 2c 22 75 6e |.0,&quot;y&quot;:10.0},&quot;un|
|000000f0| 69 74 35 22 3a 7b 22 78 22 3a 31 30 2e 30 2c 22 |it5&quot;:{&quot;x&quot;:10.0,&quot;|
|00000100| 79 22 3a 31 30 2e 30 7d 7d 2c 22 73 74 61 74 75 |y&quot;:10.0}},&quot;statu|
|00000110| 73 22 3a 31 7d 0a                               |s&quot;:1}.          |
+--------+-------------------------------------------------+----------------+
</code></pre>

<p>接收到的数据是完整的没错，但是还是报错了，而且数据结尾的字节的确是0a，转化成字符就是\n没有问题啊。</p>

<p>在ByteToMessageDecoder的decode方法里打印ByteBuf buf的长度之后，问题找到了 长度 : 10</p>

<p>这就是说在进入到ByteToMessageDecoder这个解码器的时候，数据包已经只剩下10个长度了，那么长的数据被上个解码器DelimiterBasedFrameDecoder隔空劈开了- -。问题出现在哪呢，看上面那块字节流的字节，找到第11个字节，是0a。。。。因为不是标准的json格式，最前面使用了3个字节 加上2个int长度的属性，所以 数据包头应该是11个字节长。</p>

<p>而DelimiterBasedFrameDecoder在读到第11个字节的时候读成了\n，自然而然的就认为这个数据包已经结束了，而数据进入到ByteToMessageDecoder的时候就会因为规定的body长度不等于length长度而出现问题。</p>

<p>思来想去 不实用\n 这样的单字节作为换行符，很容易在数据流中遇到，转而使用\r\n俩字节来处理，而这俩字节出现在前面两个int长度中的几率应该很小。</p>

<h3 id="最终解决">最终解决</h3>

<p>在客户端和服务器端的pipeline中添加 以 &ldquo;\r\n&rdquo; 定义为边界的符号来标识数据包结束</p>

<pre><code>//这里使用自定义分隔符
ByteBuf delimiter = Unpooled.copiedBuffer(&quot;\r\n&quot;.getBytes());
pipeline.addFirst(new DelimiterBasedFrameDecoder(8192, delimiter));
</code></pre>

<p>Server端</p>

<p><a href="https://img2022.cnblogs.com/blog/1979837/202201/1979837-20220121161608521-1422354603.png"><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012017424.png" alt="img" /></a></p>

<p>Client端</p>

<p><a href="https://img2022.cnblogs.com/blog/1979837/202201/1979837-20220121161608507-1923564175.png"><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012017425.png" alt="img" /></a></p>

<p>编码器中发送结束位置增加</p>

<pre><code>//这里最后修改使用\r\n
out.writeBytes(new byte[]{'\r','\n'});
</code></pre>

<p><a href="https://img2022.cnblogs.com/blog/1979837/202201/1979837-20220121161608527-928236420.png"><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012017426.png" alt="img" /></a></p>

<p>再次运行程序 数据包可以正常接收了。</p>

<h3 id="最终测试">最终测试</h3>

<p>服务器端</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
server is ready ......
服务器第1次接收到来自客户端的数据:今天天气冷, 打火锅0
......
服务器第999次接收到来自客户端的数据:今天天气冷, 打火锅998
服务器第1000次接收到来自客户端的数据:今天天气冷, 打火锅999
</code></pre>

<p>客户端</p>

<pre><code>log4j:WARN No appenders could be found for logger (io.netty.util.internal.logging.InternalLoggerFactory).
log4j:WARN Please initialize the log4j system properly.
log4j:WARN See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.
客户端第1次接收服务端的回送:48fa6d78-8079-4700-b488-ca2af9eb3f8c
......
客户端第999次接收服务端的回送:581da47b-d77b-4972-af11-6d33057f6610
客户端第1000次接收服务端的回送:0014e906-69cb-4900-9409-f4d1af9148dd
</code></pre>

<h3 id="总结">总结</h3>

<p>以前使用netty的时候也仅限于和硬件交互，而当时的硬件受限于成本问题是一条一条处理数据包的，所以基本上不会考虑黏包问题</p>

<p>然后就是ByteToMessageDecoder和MessageToByteEncoder两个类是比较底层实现数据流处理的，并没有带有拆包黏包的处理机制，需要自己在数据包头规定包的长度，而且无法处理过大的数据包，因为我一开始首先使用了这种方式处理数据，所以后来就没有再换成DelimiterBasedFrameDecoder加 StringDecoder来解析数据包，最后使用json直接转化为对象。</p>

<h2 id="编码-解码">编码/解码</h2>

<h3 id="replayingdecoder">ReplayingDecoder</h3>

<h3 id="replayingdecoder-的原理"><code>ReplayingDecoder</code>的原理</h3>

<ul>
<li><p><code>ReplayingDecoder</code>继承了<code>ByteToMessageDecoder</code>，但是使用<code>ReplayingDecoder</code>的好处在于：<code>ReplayingDecoder</code>在处理数据时可以认为<strong>所有的数据（ByteBuf）</strong> 已经接收完毕，而不用判断接收数据的长度。</p>

<pre><code class="language-java">public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder
</code></pre></li>

<li><p><code>ReplayingDecoder</code>使用了特殊的<code>ByteBuf</code>：<code>ReplayingDecoderByteBuf</code>，当数据不够时会抛出一类特殊的错误，然后<code>ReplayingDecoder</code>会重置<code>readerIndex</code>并且再次调用<code>decode</code>方法。</p></li>

<li><p>泛型<code>&lt;S&gt;</code>使用 <strong>枚举<code>Enum</code></strong> 来表示状态，其内部存在状态管理。如果是无状态的，则使用 <strong><code>Void</code></strong>。</p></li>
</ul>

<h3 id="继承基类-bytetomessagedecoder-的方式">继承基类<code>ByteToMessageDecoder</code>的方式</h3>

<p>下面是一个用来解码带有长整型（<code>Long</code>）数据头head的解码器：</p>

<pre><code class="language-java">public class LongHeaderFrameDecoder extends ByteToMessageDecoder {
  
    @Override
    protected void decode(ChannelHandlerContext ctx,
                         ByteBuf buf, List&lt;Object&gt; out) throws Exception {

        //总字节数&lt;8，不够Long的长度，返回
        if (buf.readableBytes() &lt; 8) {
          return;
        }
        
        buf.markReaderIndex();
        //读取head的值，例如6，说明body的长度是6个字节
        int length = buf.readLong();
        
        //body的总字节数不够6，返回
        if (buf.readableBytes() &lt; length) {
          buf.resetReaderIndex();
          return;
        }
        
        //读取6个长度的body
        out.add(buf.readBytes(length));
    }
}
</code></pre>

<p>从以上代码可以看出，在<code>decode</code>方法中需要对数据的长度做判断，依据<code>ByteBuf</code>的<code>readerIndex</code>来获取真实数据，逻辑比较复杂。</p>

<h3 id="继承基类-replayingdecoder-的方式">继承基类<code>ReplayingDecoder</code>的方式</h3>

<p>如果以上的例子选择继承<code>ReplayingDecoder</code>，那逻辑会非常简单。由于不存在状态管理，所以泛型使用<code>Void</code>。</p>

<pre><code class="language-java">public class LongHeaderFrameDecoder extends ReplayingDecoder&lt;Void&gt; {
  
    @Override
    protected void decode(ChannelHandlerContext ctx,
                         ByteBuf buf, List&lt;Object&gt; out) throws Exception {
        // 读取head的值，例如6，说明body的长度是6个字节
        int length = buf.readLong();   
        // 读取6个长度的body
        out.add(buf.readBytes(length));
    }
}
</code></pre>

<h3 id="状态管理和-checkpoint-方法">状态管理和<code>checkpoint</code>方法</h3>

<p>状态可以使用枚举<code>Enum</code>来表示，如：</p>

<pre><code class="language-java">public enum MyDecoderState {
     READ_HEAD,
     READ_BODY;
}
</code></pre>

<p>当调用<code>checkpoint(MyDecoderState state)</code>时，<code>ReplayingDecoder</code>会将当前<code>readerIndex</code>赋值给<code>int</code>类型的成员变量<code>checkpoint</code>，在后续数据读取过程中方便重置。</p>

<pre><code class="language-java">protected void checkpoint(S state) {
    checkpoint();
    state(state);
}

protected void checkpoint() {
    checkpoint = internalBuffer().readerIndex();
}
</code></pre>

<p>使用状态管理后的<code>LongHeaderFrameDecoder</code>:</p>

<pre><code class="language-java">public class LongHeaderFrameDecoder
        extends ReplayingDecoder&lt;MyDecoderState&gt; {
     // HEAD的长度
     private int length;
    
     public LongHeaderFrameDecoder() {
       // 初始状态是读取头部HEAD
       super(MyDecoderState.READ_LENGTH);
     }
    
      @Override
     protected void decode(ChannelHandlerContext ctx,
                             ByteBuf buf, List&lt;Object&gt; out) throws Exception {
       switch (state()) {
           case READ_HEAD:
             length = buf.readLong();
             checkpoint(MyDecoderState.READ_BODY);
           case READ_BODY:
             ByteBuf frame = buf.readBytes(length);
             checkpoint(MyDecoderState.READ_BODY);
             out.add(frame);
             break;
           default:
             throw new Error(&quot;Shouldn't reach here.&quot;);
           }
     }
}
</code></pre>

<h1 id="一-设计模式为啥老是用不好">一、设计模式为啥老是用不好？</h1>

<p>想要写出更屌的代码，提高代码的健壮性和可扩展性，那么设计模式可谓是必学的技能。</p>

<p>关于学习设计模式，大家可能都觉得设计模式的概念太过于抽象，理解起来有点费劲；又或者看的时候是理解了，但是写起代码时，却毫无头绪，压根不知道可以套用哪个设计模式。</p>

<p>对，可以看到我使用了 “套” 这个字眼，正是因为我们无法深入理解设计模式的设计理念和使用场景，所以我们往往是想让我们的代码套用设计模式，而不理会业务场景是否合适。</p>

<p>关于设计模式的学习，我不会推荐任何书，因为我自己也没看过，哈哈哈。我看过的是龙哥的设计模式系列文章，里面的文章不但会介绍设计模式的概念，也会用非常有趣的场景去讲解设计模式的设计理念，下面先分享一波链接：<a href="https://blog.csdn.net/zuoxiaolong8810/category_1434962.html">龙哥设计模式全集</a>。</p>

<p>对于我自己而言，关于设计模式的使用，除非是非常深刻的理解了，又或者某种设计模式的使用场景非常的清晰明确（例如创建型设计模式中的单例模式、结构型设计模式中的组合模式、行为型设计模式中的策略模式等等），不然我也不知道该如何使用，和什么时候使用。</p>

<h1 id="二-在阅读开源框架源码中学习设计模式">二、在阅读开源框架源码中学习设计模式！</h1>

<p><strong>想学习设计模式的使用方式，何不研究一下各大优秀的开源框架的源码。</strong></p>

<p>想更深层次的理解设计模式，往往阅读优秀的框架和中间件的源码是非常好的方式。优秀的开源框架和中间件，里面都使用了大量的设计模式，使得框架的实用性、可扩展性和性能非常的高。</p>

<p>很巧，今天在工作的空余时间中，我继续阅读一本关于并发的书，并看到关于 Netty 的内置解码器，其中最常用的有 ReplayingDecoder，它是 ByteToMessageDecoder 的子类，作用是： 在读取ByteBuf缓冲区的数据之前，需要检查缓冲区是否有足够的字节；若ByteBuf中有足够的字节，则会正常读取；反之，如果没有足够的字节，则会停止解码。</p>

<p>它是如何做到自主控制解码的时机的呢？其实底层是使用了 ReplayingDecoderByteBuf 这个继承于 ByteBuf 的实现类。而它使用了装饰器设计模式。</p>

<h2 id="1-在-netty-中如何自定义实现整数解码器">1、在 Netty 中如何自定义实现整数解码器？</h2>

<h3 id="1-1-bytetomessagedecoder">1.1、ByteToMessageDecoder：</h3>

<p>我们需要自定义类需要继承 ByteToMessageDecoder 抽象类，然后重写 decode 方法即可。</p>

<p>看代码：</p>

<pre><code class="language-java">/**
 * @author Howinfun
 * @desc
 * @date 2020/8/21
 */
public class MyIntegerDecoder extends ByteToMessageDecoder {
    @Override
    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception {
        while (byteBuf.readableBytes() &gt;= 4){
            
            int num = byteBuf.readInt();
            System.out.println(&quot;解码出一个整数：&quot;+num);
            list.add(num);
        }
    }
}
</code></pre>

<p>我们可以看到非常的简单，就是不断地判断缓冲区里的的可读字节数是否大于等于4（Java 中整数的大小）；如果是的话就读取4个字节大小的内容，然后放到结果集里面。</p>

<h3 id="1-2-replayingdecoder">1.2、ReplayingDecoder：</h3>

<p>我们需要自定义类需要继承 ReplayingDecoder 类，然后重写 decode 方法即可。</p>

<p>看代码：</p>

<pre><code class="language-java">/**
 * @author Howinfun
 * @desc
 * @date 2020/8/21
 */
public class MyIntegerDecoder2 extends ReplayingDecoder {

    @Override
    protected void decode(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list) throws Exception {

        int num = byteBuf.readInt();
        System.out.println(&quot;解码出一个整数：&quot;+num);
        list.add(num);
    }
}
</code></pre>

<p>这个实现更加简单，那就是去掉判断，直接调用 ByteBuf 的 readInt() 方法去获取整数即可。</p>

<h3 id="1-3-测试用例">1.3、测试用例：</h3>

<p><strong>1.3.1、自定义业务处理器：</strong></p>

<p>先创建一个业务处理器 IntegerProcessHandler，用于处理上面的自定义解码器解码之后的 Java Integer 整数。其功能是：读取上一站的入站数据，把它转换成整数，并且输出到Console控制台上。</p>

<p>码如下：</p>

<pre><code class="language-java">/**
 * @author Howinfun
 * @desc
 * @date 2020/8/21
 */
public class IntegerProcessorHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        Integer integer = (Integer) msg;
        System.out.println(&quot;打印出一个整数：&quot;+integer);
    }
}
</code></pre>

<p>这个业务处理器非常的简单，直接继承 ChannelInBoundHandlerAdapter，然户重写 channelRead() 方法即可。</p>

<p><strong>1.3.2、利用 EmbeddedChannel 进行测试：</strong></p>

<p>为了测试入站处理器，需要确保通道能接收到 ByteBuf 入站数据。这里调用 writeInbound 方法，模拟入站数据的写入，向嵌入式通道 EmbeddedChannel 写入100次 ByteBuf 入站缓冲；每一次写入仅仅包含一个整数。</p>

<p>EmbeddedChannel 的 writeInbound 方法模拟入站数据，会被流水线上的两个入站处理器所接收和处理。接着，这些入站的二进制字节被解码成一个一个的整数，然后逐个地输出到控制台上。</p>

<p>看代码：</p>

<pre><code class="language-java">public class Test{
    public static void main(String[] args){
      ChannelInitializer i = new ChannelInitializer&lt;EmbeddedChannel&gt;() {
          @Override
          protected void initChannel(EmbeddedChannel channel) throws Exception {
              // 继承 ByteToMessageDecoder 抽象类的自定义解码器
              // channel.pipeline().addLast(new MyIntegerDecoder()).addLast(new IntegerProcessorHandler());
              // 继承 ReplayingDecoder 类的自定义解码器
              channel.pipeline().addLast(new MyIntegerDecoder2()).addLast(new IntegerProcessorHandler());
          }
      };
        EmbeddedChannel channel = new EmbeddedChannel(i);
        for (int j = 0;j &lt; 20;j++){
            ByteBuf byteBuf = Unpooled.buffer();
            byteBuf.writeInt(j);
            channel.writeInbound(byteBuf);
        }
        ThreadUtil.sleep(Integer.MAX_VALUE);
    }
}
</code></pre>

<p>通过测试，两个自定义 Decoder 都是没问题的。而他们的最大不同点在于：继承抽象类 ByteToMessageDecoder 的解码器需要判断可读字节数是否大于等于4，大于等于才可以读取一个整数出来；而继承 ReplayingDecoder 的解码器直接调用 readInt() 方法即可。</p>

<h2 id="2-解读-replayingdecoder-的原理">2、解读 ReplayingDecoder 的原理</h2>

<p>其实其中的原理非常的简单，我们可以直接从 ReplayingDecoder 的源码入手：</p>

<h3 id="2-1-replayingdecoder的构造函数">2.1、ReplayingDecoder的构造函数：</h3>

<p>首先是构造函数，此处我们用了无参构造函数：</p>

<pre><code class="language-java">protected ReplayingDecoder() {
    this((Object)null);
}

protected ReplayingDecoder(S initialState) {
    this.replayable = new ReplayingDecoderByteBuf();
    this.checkpoint = -1;
    this.state = initialState;
}
</code></pre>

<p>我们可以看到，主要是初始化了 ReplayingDecoderByteBuf（其实就是加了点料的 ByteBuf）、checkpoint（读指针下标） 和 state。我们这篇文章不需要理会 state 属性，这个属性是稍微高级一点的用法。
我们最需要关注的是 ReplayingDecoderByteBuf 这个类。</p>

<h3 id="2-2-继续探讨-replayingdecoderbytebuf">2.2、继续探讨 ReplayingDecoderByteBuf：</h3>

<p>那么接下来看看 ReplayingDecoderByteBuf 的源码。</p>

<p><strong>2.2.1、ReplayingDecoderByteBuf 的属性：</strong></p>

<pre><code class="language-java">final class ReplayingDecoderByteBuf extends ByteBuf {
    private static final Signal REPLAY;
    private ByteBuf buffer;
    private boolean terminated;
    private SwappedByteBuf swapped;
    static final ReplayingDecoderByteBuf EMPTY_BUFFER;

    ReplayingDecoderByteBuf() {
    }
    //...
}
</code></pre>

<p>我们可以看到，它继承了 ByteBuf 抽象类，并且里面包含一个 ByteBuf 类型的 buffer 属性，剩余的其他属性暂时不需要看懂。</p>

<p><strong>2.2.2、瞧一瞧 readInt() 方法：</strong></p>

<p>那么接下来，我们就是直接看 ReplayingDecoderByteBuf 的 readInt() 方法了，因为我们知道，在上面的自定义解码器 MyIntegerDecoder2 的 decode() 方法中，只需要直接调用 ByteBuf（也就是 ReplayingDecoderByteBuf） 的 readInt() 方法即可解码一个整数。</p>

<pre><code class="language-java">public int readInt() {
    this.checkReadableBytes(4);
    return this.buffer.readInt();
}
</code></pre>

<p>readInt() 方法非常简单，首先是调用 checkReadableBytes() 方法，并且传入 4。根据方法名，我们就可以猜到，先判断缓冲区中是否有4个可读字节；如果是的话，就调用 buffer 的 readInt() 方法，读取一个整数。</p>

<p><strong>2.2.3、继续看看 checkReadableBytes() 方法：</strong></p>

<p>代码如下：</p>

<pre><code class="language-java">private void checkReadableBytes(int readableBytes) {
    if (this.buffer.readableBytes() &lt; readableBytes) {
        throw REPLAY;
    }
}
</code></pre>

<p>方法非常简单，其实和我们上面的 MyIntegerDecoder 一样，就是判断缓冲区中是否有 4个字节的可读数据，如果不是的话，则抛出异常。</p>

<p><strong>2.2.4、Signal 异常：</strong></p>

<p>而我们最需要关注的就是这个异常，这个异常是 ReplayingDecoder 的静态成员变量。它是继承了 error 的异常类，是 netty 提供配合 ReplayingDecoder 一起使用的。</p>

<p>至于如何使用，我们可以看到 ReplayingDecoder 的 callDecode() 方法：</p>

<pre><code class="language-java">protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) {
    // 调用 ReplayingDecoderByteBuf 的 setCumulation() 方法，使用 ReplayingDecoderByteBuf 装饰 ByteBuf
    this.replayable.setCumulation(in);

    try {
        while(in.isReadable()) {
            int oldReaderIndex = this.checkpoint = in.readerIndex();
            int outSize = out.size();
            if (outSize &gt; 0) {
                // 将结果集流到下一个 InBoundChannel
                fireChannelRead(ctx, out, outSize);
                out.clear();
                if (ctx.isRemoved()) {
                    break;
                }

                outSize = 0;
            }

            S oldState = this.state;
            int oldInputLength = in.readableBytes();

            try {
                // 调用自定义解码器的 decode() 方法进行解码
                this.decodeRemovalReentryProtection(ctx, this.replayable, out);
                if (ctx.isRemoved()) {
                    break;
                }

                if (outSize == out.size()) {
                    if (oldInputLength == in.readableBytes() &amp;&amp; oldState == this.state) {
                        throw new DecoderException(StringUtil.simpleClassName(this.getClass()) + &quot;.decode() must consume the inbound data or change its state if it did not decode anything.&quot;);
                    }
                    continue;
                }
            } catch (Signal var10) {
                // 如果不是 Sinal 异常，则往外抛
                var10.expect(REPLAY);
                if (!ctx.isRemoved()) {
                    // 设置读指针为原来的位置
                    int checkpoint = this.checkpoint;
                    if (checkpoint &gt;= 0) {
                        in.readerIndex(checkpoint);
                    }
                }
                break;
            }

            // ......
        }

    } catch (DecoderException var11) {
        throw var11;
    } catch (Exception var12) {
        throw new DecoderException(var12);
    }
}
</code></pre>

<p>到这里，我们可以捋一下思路：</p>

<ol>
<li>当缓冲区数据流到继承 ReplayingDecoder 的解码器时，会先判断结果集是否有数据，如果有则流入到下一个 InBoundChannel；</li>
<li>接着会调用自定义解码器的 decode() 方法，而这里就是是直接调用 ByteBuf 的 readInt() 方法，即 ReplayingDecoderByteBuf 的 readInt() 方法；里面会先判断可读字节大小是否大于 4，如果大于则读取，否则抛出 Signal 这个 Error 类型的异常。</li>
<li>如果 ReplayingDecoder 捕捉 Signal 这个异常，会先判断 checkpoint（即读指针下标不） 是否为零，如果不是则重新设置读指针下标，然后跳出读循环。</li>
</ol>

<p>ReplayingDecoder 能做到自主控制解码的时机，是因为使用 ReplayingDecoderByteBuf 对 ByteBuf 进行修饰，在调用 ByteBuf 的方法前，会先调用自己的判断逻辑，这也就是我们常说的装饰器模式。</p>

<h1 id="三-装饰器模式的特点">三、装饰器模式的特点</h1>

<p>首先，被装饰的类和装饰类都是继承同一个类（抽象类）或实现同一个接口。</p>

<p>接着，被装饰类会作为装饰类的成员变量。</p>

<p>最后，在执行被装饰类的方法前后，可能会调用装饰类的方法。</p>

<p><strong>场景总结：</strong></p>

<p>装饰器模式常用于这么一个场景：在不修改类的状态（属性或行为）下，对类的功能进行扩展！</p>

<p>当然啦，这是我自己个人的总结，大家可去阅读专业的书籍来证实这是否正确。如果有更好的总结，可以留言给我，让我也学习学习~</p>

<h3 id="onetooneencoder">OneToOneEncoder</h3>

<p><img src="https://cdn.jsdelivr.net/gh/zshipu/images/202205012018172.png" alt="image-20220501201812821" /></p>

        </div>

        
<div class="post-archive">
    <ul class="post-copyright">
        <li><strong>原文作者：</strong><a rel="author" href="https://geek.zshipu.com/">知识铺</a></li>
        <li style="word-break:break-all"><strong>原文链接：</strong><a href="https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/">https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/</a></li>
        <li><strong>版权声明：</strong>本作品采用<a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议</a>进行许可，非商业转载请注明出处（作者，原文链接），商业转载请联系作者获得授权。</li>
        <li><strong>免责声明：</strong>本页面内容均来源于站内编辑发布，部分信息来源互联网，并不意味着本站赞同其观点或者证实其内容的真实性，如涉及版权等问题，请立即联系客服进行更改或删除，保证您的合法权益。转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。也可以邮件至 sblig@126.com</li>
    </ul>
</div>
<br/>



        

<div class="post-archive">
    <h2>See Also</h2>
    <ul class="listing">
        
        <li><a href="/post/netty/netty-learning/ch4-reactor/">Netty那点事（四）Netty与Reactor模式</a></li>
        
        <li><a href="/post/netty/netty-learning/ch3-pipeline/">Netty那点事（三）Channel中的Pipeline</a></li>
        
        <li><a href="/post/netty/netty-learning/ch2-buffer/">Netty那点事（二）Netty中的buffer</a></li>
        
        <li><a href="/post/netty/netty-learning/ch1-overview/">Netty那点事（一）概述</a></li>
        
        <li><a href="/post/web/%E6%9B%B4%E5%BF%AB%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84-10-%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/">更快学习编程的 10 个关键技巧</a></li>
        
    </ul>
</div>


        <div class="post-meta meta-tags">
            
            <ul class="clearfix">
                
                <li><a href='/tags/Netty'>Netty</a></li>
                
            </ul>
            
        </div>
    </article>
    
    

    
    
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "zshipu/zshipu-geek"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
    
</div>

                    <footer id="footer">
    <div>
        &copy; 2022 <a href="https://geek.zshipu.com/">知识铺的博客 By 知识铺</a>
        
        | <a rel="nofollow" target="_blank" href="https://beian.miit.gov.cn/">浙 ICP 备19032823号-1</a>
        
    </div>
    <br />
    <div>
        <div class="github-badge">
            <a href="https://gohugo.io/" target="_black" rel="nofollow"><span class="badge-subject">Powered by</span><span class="badge-value bg-blue">Hugo</span></a>
        </div>
        <div class="github-badge">
            <a href="https://www.flysnow.org/" target="_black"><span class="badge-subject">Design by</span><span class="badge-value bg-brightgreen">飞雪无情</span></a>
        </div>
        <div class="github-badge">
            <a href="https://github.com/flysnow-org/maupassant-hugo" target="_black"><span class="badge-subject">Theme</span><span class="badge-value bg-yellowgreen">Maupassant</span></a>
        </div>
    </div>
</footer>


    
    <script type="text/javascript">
        window.MathJax = {
            tex2jax: {
                inlineMath: [['$', '$']],
                processEscapes: true
                }
            };
    </script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

<a id="rocket" href="#top"></a>
<script type="text/javascript" src='/js/totop.js?v=0.0.0' async=""></script>



    <script type="text/javascript" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>




                </div>

                <div id="secondary">
    <section class="widget">
        <form id="search" action='https://geek.zshipu.com/search/' method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://geek.zshipu.com/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://geek.zshipu.com/post/react/level01/2.-React-%E5%BE%88%E6%A3%92%E7%9A%84%E7%BB%84%E4%BB%B6/" title="2. React 很棒的组件">2. React 很棒的组件</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/react/level01/1.-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84-React-/" title="1.初学者的 React">1.初学者的 React</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/css/CSS-%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/" title="CSS 特性的完整指南">CSS 特性的完整指南</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/web/Web-3.0%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E6%8C%87%E5%8D%97%E5%92%8C%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90/" title="Web 3.0：开发者路线图、指南和入门资源">Web 3.0：开发者路线图、指南和入门资源</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/detail/ch1-async-in-netty/" title="Netty那点事（八）理解Netty中的异步">Netty那点事（八）理解Netty中的异步</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/trival-notes/" title="Netty那点事（七）层层分析Netty中的Channel(下)">Netty那点事（七）层层分析Netty中的Channel(下)</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/socks-proxy-by-netty/" title="Netty那点事（六）使用netty构建一个socks proxy">Netty那点事（六）使用netty构建一个socks proxy</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/" title="Netty那点事（五）讲讲Handler">Netty那点事（五）讲讲Handler</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/ch4-reactor/" title="Netty那点事（四）Netty与Reactor模式">Netty那点事（四）Netty与Reactor模式</a>
    </li>
    
    <li>
        <a href="https://geek.zshipu.com/post/netty/netty-learning/ch3-pipeline/" title="Netty那点事（三）Channel中的Pipeline">Netty那点事（三）Channel中的Pipeline</a>
    </li>
    
</ul>
    </section>

    
<section class="widget">
    <h3 class="widget-title" style="color:red">福利派送</h3>
    <ul class="widget-list">
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【2019双12】ALL IN CLoud 低至1折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1_rYHo7P2gK0jSZPxXXacQpXa-690-388.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="助力产业智慧升级，云服务器首年88元起，更有千元代金券礼包免费领！" target="_blank" style="color:red">
                
                    <img src="https://upload-dianshi-1255598498.file.myqcloud.com/345-7c71532bd4935fbdd9a67c1a71e577b1767b805c.200%E7%89%88%E6%9C%ACB.jpg">
                
            </a>
        </li>
        
        <li>
            <a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?source=5176.11533457&amp;userCode=tzm8r4hc" title="【渠道专享低折扣】11月特惠 限时2折" target="_blank" style="color:red">
                
                    <img src="https://img.alicdn.com/tfs/TB1hblJl7Y2gK0jSZFgXXc5OFXa-750-400.jpg">
                
            </a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title"><a href='/categories/'>分类</a></h3>
<ul class="widget-list">
    
    <li><a href="https://geek.zshipu.com/categories/flutter/">flutter (30)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/iOS/">iOS (7)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/unix/">unix (9)</a></li>
    
    <li><a href="https://geek.zshipu.com/categories/%E7%AE%97%E6%B3%95/">算法 (3)</a></li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title"><a href='/tags/'>标签</a></h3>
<div class="tagcloud">
    
    <a href="https://geek.zshipu.com/tags/BI/">BI</a>
    
    <a href="https://geek.zshipu.com/tags/DDD/">DDD</a>
    
    <a href="https://geek.zshipu.com/tags/DDD%E5%AE%9E%E6%88%98/">DDD实战</a>
    
    <a href="https://geek.zshipu.com/tags/DevOps/">DevOps</a>
    
    <a href="https://geek.zshipu.com/tags/IM/">IM</a>
    
    <a href="https://geek.zshipu.com/tags/JS/">JS</a>
    
    <a href="">Java</a>
    
    <a href="https://geek.zshipu.com/tags/JavaScript/">JavaScript</a>
    
    <a href="https://geek.zshipu.com/tags/Monorepo/">Monorepo</a>
    
    <a href="https://geek.zshipu.com/tags/Netty/">Netty</a>
    
    <a href="https://geek.zshipu.com/tags/NextJS/">NextJS</a>
    
    <a href="">Nextjs</a>
    
    <a href="https://geek.zshipu.com/tags/Typora/">Typora</a>
    
    <a href="https://geek.zshipu.com/tags/WebRTC/">WebRTC</a>
    
    <a href="https://geek.zshipu.com/tags/android/">android</a>
    
    <a href="https://geek.zshipu.com/tags/css/">css</a>
    
    <a href="https://geek.zshipu.com/tags/flutter/">flutter</a>
    
    <a href="https://geek.zshipu.com/tags/game/">game</a>
    
    <a href="https://geek.zshipu.com/tags/github/">github</a>
    
    <a href="https://geek.zshipu.com/tags/go/">go</a>
    
    <a href="https://geek.zshipu.com/tags/golang/">golang</a>
    
    <a href="https://geek.zshipu.com/tags/java/">java</a>
    
    <a href="">js</a>
    
    <a href="https://geek.zshipu.com/tags/mysql/">mysql</a>
    
    <a href="https://geek.zshipu.com/tags/nifi/">nifi</a>
    
    <a href="https://geek.zshipu.com/tags/nodejs/">nodejs</a>
    
    <a href="https://geek.zshipu.com/tags/npm/">npm</a>
    
    <a href="https://geek.zshipu.com/tags/python/">python</a>
    
    <a href="https://geek.zshipu.com/tags/react/">react</a>
    
    <a href="https://geek.zshipu.com/tags/reactjs/">reactjs</a>
    
    <a href="https://geek.zshipu.com/tags/sqllit/">sqllit</a>
    
    <a href="https://geek.zshipu.com/tags/vuejs/">vuejs</a>
    
    <a href="https://geek.zshipu.com/tags/web/">web</a>
    
    <a href="https://geek.zshipu.com/tags/web3/">web3</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%B9%A6%E7%B1%8D/">书籍</a>
    
    <a href="https://geek.zshipu.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%88%86%E8%AF%8D/">分词</a>
    
    <a href="https://geek.zshipu.com/tags/%E5%AD%A6%E4%B9%A0/">学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%96%87%E6%91%98/">文摘</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
    
    <a href="https://geek.zshipu.com/tags/%E6%9E%B6%E6%9E%84/">架构</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%88%AC%E8%99%AB/">爬虫</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/">用户画像</a>
    
    <a href="https://geek.zshipu.com/tags/%E7%BA%BF%E7%A8%8B/">线程</a>
    
    <a href="https://geek.zshipu.com/tags/%E8%B5%B7%E6%AD%A5/">起步</a>
    
</div>
    </section>

    
<section class="widget">
    <h3 class="widget-title">友情链接</h3>
    <ul class="widget-list">
        
        <li>
            <a target="_blank" href="https://blog.zshipu.com//" title="知识铺的博客">知识铺的博客</a>
        </li>
        
    </ul>
</section>


    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://geek.zshipu.com/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
            </div>
        </div>
    </div>
</body>

</html>