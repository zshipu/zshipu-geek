<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>知识铺的博客</title>
    <link>https://geek.zshipu.com/</link>
    <description>Recent content on 知识铺的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 02 Feb 2023 14:39:33 +0800</lastBuildDate>
    
	<atom:link href="https://geek.zshipu.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>阿里篇-1.3.9 如何判断两个链表是否相交</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.9-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</link>
      <pubDate>Thu, 02 Feb 2023 14:39:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.9-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4/</guid>
      <description>题目：如何判断两个链表是否相交 出题人：阿里巴巴新零售技术质量部 参考答案： $O(n^2)$: 两层遍历，总能发现是否相交 $O(n)$: 一层遍历，遍历完两个链表，如果两个链表的最后一个结点指针相同，则相交，否则不相交</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.8 如何测试一辆自行车</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.8-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E8%BE%86%E8%87%AA%E8%A1%8C%E8%BD%A6/</link>
      <pubDate>Thu, 02 Feb 2023 14:38:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.8-%E5%A6%82%E4%BD%95%E6%B5%8B%E8%AF%95%E4%B8%80%E8%BE%86%E8%87%AA%E8%A1%8C%E8%BD%A6/</guid>
      <description>题目：如何测试一辆自行车 出题人：阿里巴巴新零售技术质量部 参考答案： 开放性问题，如果联系到测试角度上看的话，可以这么作答： 骑车试一试，看有没有问题，对应测试能不能跑通 看看车的核心部件，例如车闸，车把等，对应软件的核心功能 看看车是否安全，配锁质量如何，对应软件是否有安全问题</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.7 请评估一下程序的执行结果？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.7-%E8%AF%B7%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Thu, 02 Feb 2023 14:37:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.7-%E8%AF%B7%E8%AF%84%E4%BC%B0%E4%B8%80%E4%B8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid>
      <description>题目：请评估一下程序的执行结果？ public class SynchronousQueueQuiz { public static void main(String[] args) throws Exception { BlockingQueue&amp;lt;Integer&amp;gt; queue = new SynchronousQueue&amp;lt;&amp;gt;(); System. out .print(queue.offer(1) + &amp;quot; &amp;quot;); System. out .print(queue.offer(2) + &amp;quot; &amp;quot;); System. out .print(queue.offer(3) + &amp;quot; &amp;quot;); System. out .print(queue.take() + &amp;quot; &amp;quot;); System. out .println(queue.size()); } } A. true true true 1 3 B. true true true (阻塞) C. false false false null 0 D. false false false (阻塞) 出题人：阿里巴巴出题专家：桃谷／阿里云中间件技术专家 参考答案：D</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.6 假如给你一个新产品，你将从哪些方面来保障它的质量？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.6-%E5%81%87%E5%A6%82%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%A7%E5%93%81%E4%BD%A0%E5%B0%86%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%9D%A5%E4%BF%9D%E9%9A%9C%E5%AE%83%E7%9A%84%E8%B4%A8%E9%87%8F/</link>
      <pubDate>Thu, 02 Feb 2023 14:36:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.6-%E5%81%87%E5%A6%82%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BA%A7%E5%93%81%E4%BD%A0%E5%B0%86%E4%BB%8E%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E6%9D%A5%E4%BF%9D%E9%9A%9C%E5%AE%83%E7%9A%84%E8%B4%A8%E9%87%8F/</guid>
      <description>题目：假如给你一个新产品，你将从哪些方面来保障它的质量？ 出题人：阿里巴巴出题专家：晨晖 ／阿里云中间件技术部测试开发专家 参考答案： 可以从代码开发、测试保障、线上质量三个方面来保障。 在代码开发阶段，有单元测试、代码Review、静态代码扫描等； 测试保障阶段，有功能测试、性能测试、高可</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.5 给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.5-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%84%E5%8A%A0%E5%92%8C%E7%AD%89%E4%BA%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0%E9%9C%80%E8%A6%81%E6%9C%80%E4%BC%98%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
      <pubDate>Thu, 02 Feb 2023 14:35:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.5-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E5%92%8C%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E7%B4%A2%E5%BC%95%E8%BF%99%E4%B8%A4%E4%B8%AA%E7%B4%A2%E5%BC%95%E6%8C%87%E5%90%91%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%84%E5%8A%A0%E5%92%8C%E7%AD%89%E4%BA%8E%E6%8C%87%E5%AE%9A%E7%9A%84%E6%95%B4%E6%95%B0%E9%9C%80%E8%A6%81%E6%9C%80%E4%BC%98%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
      <description>题目：给定一个整数数组和一个整数，返回两个数组的索引，这两个索引指向的数字的加和等于指定的整数。需要最优的算法，分析算法的空间和时间复杂度 参考答案： public int[] twoSum(int[] nums, int target) { if(nums==null || nums.length&amp;lt;2) return new int[]{0,0}; HashMap&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;Integer, Integer&amp;gt;(); for(int i=0; i&amp;lt;nums.length; i++){ if(map.containsKey(nums[i])){ return new int[]{map.get(nums[i]), i}; }else{ map.put(target-nums[i], i); } } return new int[]{0,0}; } 分析：空间复杂度和时间复杂度均为 O(n)</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.4 如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.4-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93NOSQL-%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%B5%81%E5%8A%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%8A%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 02 Feb 2023 14:34:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.4-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E6%95%B0%E6%8D%AE%E5%BA%93NOSQL-%E5%92%8C%E5%A4%A7%E6%95%B0%E6%8D%AE%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%97%B6%E6%B5%81%E5%8A%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%8A%E5%A4%84%E7%90%86%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BD%A0%E4%BC%9A%E8%80%83%E8%99%91%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>题目：如果让你来设计一个支持数据库、NOSQL 和大数据之间数据实时流动的数据流及处理的系统，你会考虑哪些问题？如何设计？ 出题人：阿里巴巴出题专家：千震／阿里云数据库高级技术专家 参考答案：开放性问题，无标准答案。</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.3 如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.3-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%92%E7%BA%A7%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 02 Feb 2023 14:33:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.3-%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E6%94%AF%E6%8C%81%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A7%92%E7%BA%A7%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E7%9A%84%E7%B3%BB%E7%BB%9F%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>题目：如果让你设计一个通用的、支持各种数据库秒级备份和恢复的系统，你会如何设计？ 出题人：阿里巴巴出题专家：千震／阿里云数据库高级技术专家 参考答案：开放性问题，无标准答案。</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.2 给定一个链表，删除链表的倒数第N个节点，并且返回链表的头结点</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.2-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9/</link>
      <pubDate>Thu, 02 Feb 2023 14:32:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.2-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9%E5%B9%B6%E4%B8%94%E8%BF%94%E5%9B%9E%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E7%BB%93%E7%82%B9/</guid>
      <description>题目：给定一个链表，删除链表的倒数第 N 个节点，并且返回链表的头结点。 ◼ 示例： 给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&amp;gt;2-&amp;gt;3-&amp;gt;5. 说明： 给定的 n 保证是有效的。 要求： 只允许对链表进行一次遍历。 出题人：阿里巴巴出题专家：屹平／阿里云视频云边缘计算高级技术专家 参考答案： 我们可以使</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.1 最大频率栈</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.1-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</link>
      <pubDate>Thu, 02 Feb 2023 14:31:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.1-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E6%A0%88/</guid>
      <description>题目：最大频率栈。 实现 FreqStack，模拟类似栈的数据结构的操作的一个类。FreqStack 有两个函数： push(int x)，将整数 x 推入栈中。pop()，它移除并返回栈中出现最频繁的元素。如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。 ◼ 示例： push [5,7,5,7,4,5] pop() -&amp;gt; 返回 5，因为 5 是出现频率最高</description>
    </item>
    
    <item>
      <title>阿里篇-1.3.0 在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.0-%E5%9C%A8%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%AF%8F%E5%A4%A9%E8%BF%90%E8%A1%8C%E7%9D%80%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%AF%8F%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%83%BD%E8%A6%81%E8%BF%9B%E8%A1%8C-IO-%E8%AF%BB%E5%86%99/</link>
      <pubDate>Thu, 02 Feb 2023 14:30:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.3.0-%E5%9C%A8%E4%BA%91%E8%AE%A1%E7%AE%97%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%AF%8F%E5%A4%A9%E8%BF%90%E8%A1%8C%E7%9D%80%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%AF%8F%E4%B8%AA%E4%BB%BB%E5%8A%A1%E9%83%BD%E8%A6%81%E8%BF%9B%E8%A1%8C-IO-%E8%AF%BB%E5%86%99/</guid>
      <description>题目：在云计算大数据处理场景中，每天运行着成千上万的任务，每个任务都要进行 IO 读写。存储系统为了更好的服务，经常会保证高优先级的任务优先执行。当多个作业或用户访问存储系统时，如何保证优先级和公平性。 出题人：阿里巴巴出题专家：田磊磊／阿里云文件存储高级技术专家 参考答案：开放性问题，无</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.9 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.9-%E4%BD%A0%E7%90%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E5%A6%82%E9%98%BF%E9%87%8C%E5%92%8C%E5%8F%8B%E5%95%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B7%AE%E5%BC%82%E4%BB%A5%E5%8F%8A%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%92%8C%E6%8A%80%E6%9C%AF%E7%93%B6%E9%A2%88%E5%9C%A8%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Thu, 02 Feb 2023 14:29:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.9-%E4%BD%A0%E7%90%86%E8%A7%A3%E5%B8%B8%E8%A7%81%E5%A6%82%E9%98%BF%E9%87%8C%E5%92%8C%E5%8F%8B%E5%95%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B7%AE%E5%BC%82%E4%BB%A5%E5%8F%8A%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF%E5%92%8C%E6%8A%80%E6%9C%AF%E7%93%B6%E9%A2%88%E5%9C%A8%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%96%B9%E9%9D%A2%E8%BF%9B%E8%A1%8C%E6%A6%82%E8%BF%B0/</guid>
      <description>题目： 你理解常见如阿里，和友商大数据平台的技术体系差异以及发展趋势和技术瓶颈，在存储和计算两个方面进行概述。 出题人： 阿里巴巴出题专家：映泉／阿里巴巴高级技术专家 参考答案：开放性问题，无标准答案。</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.8 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.8-%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E4%B8%AD%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BC%9A%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Thu, 02 Feb 2023 14:28:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.8-%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0%E4%B8%AD%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E4%BC%9A%E5%AF%B9%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>题目： 对大数据平台中的元数据管理是怎么理解的，元数据收集管理体系是怎么样的，会对大数据应用有什么样的影响。 出题人： 阿里巴巴出题专家：映泉／阿里巴巴高级技术专家 参考答案：开放性问题，无标准答案。</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.7 请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.7-%E8%AF%B7%E5%88%86%E6%9E%90-MaxCompute-%E4%BA%A7%E5%93%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B3%E7%B3%BB%E5%BD%93%E5%89%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%B1%BB%E4%BA%A7%E5%93%81%E7%9A%84%E5%B8%82%E5%9C%BA%E7%8E%B0%E7%8A%B6%E5%92%8C%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/</link>
      <pubDate>Thu, 02 Feb 2023 14:27:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.7-%E8%AF%B7%E5%88%86%E6%9E%90-MaxCompute-%E4%BA%A7%E5%93%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E7%9A%84%E5%85%B3%E7%B3%BB%E5%BD%93%E5%89%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E7%B1%BB%E4%BA%A7%E5%93%81%E7%9A%84%E5%B8%82%E5%9C%BA%E7%8E%B0%E7%8A%B6%E5%92%8C%E5%8F%91%E5%B1%95%E8%B6%8B%E5%8A%BF/</guid>
      <description>题目：请分析 MaxCompute 产品与分布式技术的关系、当前大数据计算平台类产品的市场现状和发展趋势。 出题人：阿里巴巴出题专家：云郎／阿里 MaxCompute 高级产品专家 参考答案： 开放性问题，无标准答案。</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.6 一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.6-%E4%B8%80%E9%A2%97%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%AF%8F%E7%A7%92%E5%A4%A7%E6%A6%82%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%A4%9A%E5%B0%91%E6%9D%A1%E7%AE%80%E5%8D%95%E7%9A%84MOV%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0/</link>
      <pubDate>Thu, 02 Feb 2023 14:26:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.6-%E4%B8%80%E9%A2%97%E7%8E%B0%E4%BB%A3%E5%A4%84%E7%90%86%E5%99%A8%E6%AF%8F%E7%A7%92%E5%A4%A7%E6%A6%82%E5%8F%AF%E4%BB%A5%E6%89%A7%E8%A1%8C%E5%A4%9A%E5%B0%91%E6%9D%A1%E7%AE%80%E5%8D%95%E7%9A%84MOV%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%BB%E8%A6%81%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0/</guid>
      <description>题目：一颗现代处理器，每秒大概可以执行多少条简单的MOV指令，有哪些主要的影响因素？ 出题人：阿里巴巴出题专家：子团／创新产品虚拟化&amp;amp;稳定性资深技术专家 参考答案： 及格： 每执行一条mov指令需要消耗1个时钟周期，所以每秒执行的mov指令和CPU主频相关。 加分： 在CPU微架构上</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.5 请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.5-%E8%AF%B7%E8%AE%A1%E7%AE%97XILINX%E5%85%AC%E5%8F%B8VU9P%E8%8A%AF%E7%89%87%E7%9A%84%E7%AE%97%E5%8A%9B%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%A4%9A%E5%B0%91TOPS%E7%BB%99%E5%87%BA%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Thu, 02 Feb 2023 14:25:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.5-%E8%AF%B7%E8%AE%A1%E7%AE%97XILINX%E5%85%AC%E5%8F%B8VU9P%E8%8A%AF%E7%89%87%E7%9A%84%E7%AE%97%E5%8A%9B%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%A4%9A%E5%B0%91TOPS%E7%BB%99%E5%87%BA%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%85%AC%E5%BC%8F/</guid>
      <description>题目：请计算XILINX公司VU9P芯片的算力相当于多少TOPS，给出计算过程与公式。 出题人： 阿里巴巴出题专家：隐达／阿里云异构计算资深专家 参考答案：基于不同的算法，这个值在十几到几百之间。但是，如果只是单纯比算力，FPGA和ASIC、GPU相比并无太大优势，甚至大多时候有较大劣</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.4 关于并行计算的一些基础开放问题</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.4-%E5%85%B3%E4%BA%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%BC%80%E6%94%BE%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 02 Feb 2023 14:24:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.4-%E5%85%B3%E4%BA%8E%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E5%BC%80%E6%94%BE%E9%97%AE%E9%A2%98/</guid>
      <description>题目： 关于并行计算的一些基础开放问题。 ◼ 如何定义并计算，请分别阐述分布式内存到共享内存模式行编程的区别和实现（例子代码）？ ◼ 请使用 MPI 和 OpenMP 分别实现 N 个处理器对 M 个变量的求和？ ◼ 请说明 SIMD 指令在循环中使用的权限？向量化优化有哪些手段？ ◼ 请用 Amdahl 定律说明什么是并行效率以及并行算法的扩展性？</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.3 如何实现两金额数据相加（最多小数点两位）</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%87%91%E9%A2%9D%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0%E6%9C%80%E5%A4%9A%E5%B0%8F%E6%95%B0%E7%82%B9%E4%B8%A4%E4%BD%8D/</link>
      <pubDate>Thu, 02 Feb 2023 14:23:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%87%91%E9%A2%9D%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%8A%A0%E6%9C%80%E5%A4%9A%E5%B0%8F%E6%95%B0%E7%82%B9%E4%B8%A4%E4%BD%8D/</guid>
      <description>题目：如何实现两金额数据相加（最多小数点两位）？ 出题人：阿里巴巴出题专家：御术／蚂蚁金服数据可视化高级技术专家 参考答案： 其实问题并不难，就是考察候选人对 JavaScript 数据运算上的认知以及考虑问题的缜密程度，有很多坑，可以用在笔试题，如果用在面试，回答过程中还可以随机加入有很多计算机基础的延伸</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.2 有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.2-%E6%9C%89%E4%B8%80%E6%89%B9%E6%B0%94%E8%B1%A1%E8%A7%82%E6%B5%8B%E7%AB%99%E7%8E%B0%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96%E8%BF%99%E4%BA%9B%E7%AB%99%E7%82%B9%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0-Hive-%E4%B8%AD%E4%BD%86%E6%98%AF%E6%B0%94%E8%B1%A1%E5%B1%80%E5%8F%AA%E6%8F%90%E4%BE%9B%E4%BA%86-api-%E6%9F%A5%E8%AF%A2%E6%AF%8F%E6%AC%A1%E5%8F%AA%E8%83%BD%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E8%A7%82%E6%B5%8B%E7%82%B9%E9%82%A3%E4%B9%88%E5%A6%82%E6%9E%9C%E8%83%BD%E5%A4%9F%E6%96%B9%E4%BE%BF%E5%BF%AB%E9%80%9F%E5%9C%B0%E8%8E%B7%E5%8F%96%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E8%A7%82%E6%B5%8B%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Thu, 02 Feb 2023 14:22:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.2-%E6%9C%89%E4%B8%80%E6%89%B9%E6%B0%94%E8%B1%A1%E8%A7%82%E6%B5%8B%E7%AB%99%E7%8E%B0%E9%9C%80%E8%A6%81%E8%8E%B7%E5%8F%96%E8%BF%99%E4%BA%9B%E7%AB%99%E7%82%B9%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0-Hive-%E4%B8%AD%E4%BD%86%E6%98%AF%E6%B0%94%E8%B1%A1%E5%B1%80%E5%8F%AA%E6%8F%90%E4%BE%9B%E4%BA%86-api-%E6%9F%A5%E8%AF%A2%E6%AF%8F%E6%AC%A1%E5%8F%AA%E8%83%BD%E6%9F%A5%E8%AF%A2%E5%8D%95%E4%B8%AA%E8%A7%82%E6%B5%8B%E7%82%B9%E9%82%A3%E4%B9%88%E5%A6%82%E6%9E%9C%E8%83%BD%E5%A4%9F%E6%96%B9%E4%BE%BF%E5%BF%AB%E9%80%9F%E5%9C%B0%E8%8E%B7%E5%8F%96%E5%88%B0%E6%89%80%E6%9C%89%E7%9A%84%E8%A7%82%E6%B5%8B%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>题目：有一批气象观测站，现需要获取这些站点的观测数据，并存储到 Hive 中。但是气象局只提供了 api 查询，每次只能查询单个观测点。那么如果能够方便快速地获取到所有的观测点的数据？ 出题人：阿里巴巴出题专家：江岚／阿里巴巴数据技术高级技术专家 参考答案： A. 通过 shell 或 python 等调用 api，结果先暂存本地，最</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.1 现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.1-%E7%8E%B0%E6%9C%89%E4%B8%80%E6%89%B9%E9%82%AE%E4%BB%B6%E9%9C%80%E8%A6%81%E5%8F%91%E9%80%81%E7%BB%99%E8%AE%A2%E9%98%85%E9%A1%BE%E5%AE%A2%E4%B8%94%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E9%9B%86%E7%BE%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E4%B8%8D%E5%AE%9A%E4%BC%9A%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%9D%A5%E8%B4%9F%E8%B4%A3%E5%85%B7%E4%BD%93%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%B0%BD%E5%BF%AB%E5%9C%B0%E5%AE%8C%E6%88%90%E5%8F%91%E9%80%81/</link>
      <pubDate>Thu, 02 Feb 2023 14:21:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.1-%E7%8E%B0%E6%9C%89%E4%B8%80%E6%89%B9%E9%82%AE%E4%BB%B6%E9%9C%80%E8%A6%81%E5%8F%91%E9%80%81%E7%BB%99%E8%AE%A2%E9%98%85%E9%A1%BE%E5%AE%A2%E4%B8%94%E6%9C%89%E4%B8%80%E4%B8%AA%E9%9B%86%E7%BE%A4%E9%9B%86%E7%BE%A4%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E4%B8%8D%E5%AE%9A%E4%BC%9A%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%9D%A5%E8%B4%9F%E8%B4%A3%E5%85%B7%E4%BD%93%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81%E4%BB%BB%E5%8A%A1%E5%A6%82%E4%BD%95%E8%AE%A9%E7%B3%BB%E7%BB%9F%E5%B0%BD%E5%BF%AB%E5%9C%B0%E5%AE%8C%E6%88%90%E5%8F%91%E9%80%81/</guid>
      <description>题目：现有一批邮件需要发送给订阅顾客，且有一个集群（集群的节点数不定，会动态扩容缩容）来负责具体的邮件发送任务，如何让系统尽快地完成发送？请详述技术方案！ 出题人：阿里巴巴出题专家：江岚／阿里巴巴数据技术高级技术专家 参考答案： A. 借助消息中间件，通过发布者订阅者模式来进行任务分配 B. master-slave</description>
    </item>
    
    <item>
      <title>阿里篇-1.2.0 请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.0-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%B9%BF%E6%99%97%E5%8F%91%E5%B8%83%E6%81%8B%E6%83%85%E7%9A%84%E6%97%B6%E5%80%99%E5%BE%AE%E5%8D%9A%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Thu, 02 Feb 2023 14:20:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.2.0-%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%B9%BF%E6%99%97%E5%8F%91%E5%B8%83%E6%81%8B%E6%83%85%E7%9A%84%E6%97%B6%E5%80%99%E5%BE%AE%E5%8D%9A%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B4%A9%E6%BA%83%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</guid>
      <description>题目：请解释下为什么鹿晗发布恋情的时候，微博系统会崩溃，如何解决？ 出题人：阿里巴巴出题专家：江岚／阿里巴巴数据技术高级技术专家 参考答案： A. 获取微博通过 pull 方式还是 push 方式 B. 发布微博的频率要远小于阅读微博 C. 流量明星的发微博，和普通博主要区分对待，比如在 sharding的时候，也要考虑这</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.9 输入 ping IP 后敲回车，发包前会发生什么？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.9-%E8%BE%93%E5%85%A5-ping-IP-%E5%90%8E%E6%95%B2%E5%9B%9E%E8%BD%A6%E5%8F%91%E5%8C%85%E5%89%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</link>
      <pubDate>Thu, 02 Feb 2023 14:19:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.9-%E8%BE%93%E5%85%A5-ping-IP-%E5%90%8E%E6%95%B2%E5%9B%9E%E8%BD%A6%E5%8F%91%E5%8C%85%E5%89%8D%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88/</guid>
      <description>题目：输入 ping IP 后敲回车，发包前会发生什么？ 出题人：阿里巴巴出题专家：怀虎／阿里云云效平台负责人 参考答案： ping目标ip时，先查路由表，确定出接口 - 如果落在直连接口子网内，此时若为以太网等 多路访问网络 则先查询arp缓存，命中则直接发出，否则在该接口上发arp询问目标ip的mac地</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.8 NFS与SMB的区别？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.8-NFS%E4%B8%8ESMB%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Thu, 02 Feb 2023 14:18:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.8-NFS%E4%B8%8ESMB%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>题目：NFS 和 SMB 是最常见的两种 NAS（Network Attached Storage）协议，当把一个文件系统同时通过 NFS 和 SMB 协议共享给多个主机访问时，以下哪些说法是错误的：（多选） A. 不可能有这样的操作，即把一个文件系统同时通过 NFS 和 SMB协议共享给多个主机访问。 B. 主机 a 的用户通过NFS 协议创建的文件</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.7 MySQL的数据如何恢复到任意时间点？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.7-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E7%82%B9/</link>
      <pubDate>Thu, 02 Feb 2023 14:17:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.7-MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E6%81%A2%E5%A4%8D%E5%88%B0%E4%BB%BB%E6%84%8F%E6%97%B6%E9%97%B4%E7%82%B9/</guid>
      <description>题目：MySQL 的数据如何恢复到任意时间点？ 出题人：阿里巴巴出题专家：近秋／阿里云数据库产品技术部技术专家参考答案 参考答案：恢复到任意时间点以定时的做全量备份，以及备份增量的 binlog 日志为前提。恢复到任意时间点首先将全量备份恢复之后，再此基础上回放增加的 binlog 直至指定的时间点。</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.6 从innodb的索引结构分析，为什么索引的 key 长度不能太长</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.6-%E4%BB%8Einnodb%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%9A%84-key-%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E5%A4%AA%E9%95%BF/</link>
      <pubDate>Thu, 02 Feb 2023 14:16:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.6-%E4%BB%8Einnodb%E7%9A%84%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E7%9A%84-key-%E9%95%BF%E5%BA%A6%E4%B8%8D%E8%83%BD%E5%A4%AA%E9%95%BF/</guid>
      <description>题目：从 innodb 的索引结构分析，为什么索引的 key 长度不能太长？ 出题人：阿里巴巴出题专家：近秋／阿里云数据库产品技术部技术专家 参考答案：key 太长会导致一个页当中能够存放的 key 的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.5 关于epoll和select的区别，以下哪些说法是正确的</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.5-%E5%85%B3%E4%BA%8Eepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E8%AF%B4%E6%B3%95%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84/</link>
      <pubDate>Thu, 02 Feb 2023 14:14:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.5-%E5%85%B3%E4%BA%8Eepoll%E5%92%8Cselect%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E8%AF%B4%E6%B3%95%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84/</guid>
      <description>问题：关于 epoll 和 select 的区别，哪些说法是正确的？（多选） A. epoll 和 select 都是 I/O 多路复用的技术，都可以实现同时监听多个 I/O 事件的状态。 B. epoll 相比 select 效率更高，主要是基于其操作系统支持的I/O事件通知机制，而 select 是基于轮询机制。 C. epoll 支持水平触发和边沿触发两种模式。 D. select 能并行支持 I/O 比较小，且无法修改。 出题人</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.4 LRU缓存机制</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.4-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Thu, 02 Feb 2023 14:13:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.4-LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>题目：LRU 缓存机制 设计和实现一个 LRU（最近最少使用）缓存数据结构，使它应该支持一下操作：get 和 put。 get(key) - 如果 key 存在于缓存中，则获取 key 的 value（总是正数），否则返回 -1。 put(key,value) - 如果 key 不存在，请设置或插入 value。当缓存达到其容量时，它应该在插入新项目之前使最近最少使用的</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.3 给定一个二叉搜索树(BST)，找到树中第 K 小的节点</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.3-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST%E6%89%BE%E5%88%B0%E6%A0%91%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 02 Feb 2023 14:12:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.3-%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91BST%E6%89%BE%E5%88%B0%E6%A0%91%E4%B8%AD%E7%AC%AC-K-%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>题目：给定一个二叉搜索树(BST)，找到树中第 K 小的节点。 出题人：阿里巴巴出题专家：文景／阿里云 CDN 资深技术专家 参考答案： * 考察点 基础数据结构的理解和编码能力 递归使用 * 示例 5 / \ 3 6 / \ 2 4 / 1 说明：保证输入的 K 满足 1&amp;lt;=K&amp;lt;=(节点数目） 解法1：树相关的题目，第一眼就</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.2 已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.2-%E5%B7%B2%E7%9F%A5sqrt2%E7%BA%A6%E7%AD%89%E4%BA%8E1.414%E8%A6%81%E6%B1%82%E4%B8%8D%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BA%93%E6%B1%82sqrt2%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E10%E4%BD%8D/</link>
      <pubDate>Wed, 01 Feb 2023 14:11:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.2-%E5%B7%B2%E7%9F%A5sqrt2%E7%BA%A6%E7%AD%89%E4%BA%8E1.414%E8%A6%81%E6%B1%82%E4%B8%8D%E7%94%A8%E6%95%B0%E5%AD%A6%E5%BA%93%E6%B1%82sqrt2%E7%B2%BE%E7%A1%AE%E5%88%B0%E5%B0%8F%E6%95%B0%E7%82%B9%E5%90%8E10%E4%BD%8D/</guid>
      <description>题目：已知 sqrt (2)约等于 1.414，要求不用数学库，求 sqrt (2)精确到小数点后 10 位。 出题人：——阿里巴巴出题专家：文景／阿里云 CDN 资深技术专家 参考答案： * 考察点 基础算法的灵活应用能力（二分法学过数据结构的同学都知道，但不一定往这个方向考虑；如果学过数值计算的同学，应该还要能想到牛顿迭</description>
    </item>
    
    <item>
      <title>阿里篇-1.1.1 如何实现一个高效的单向链表逆序输出？</title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.1-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA/</link>
      <pubDate>Wed, 01 Feb 2023 14:10:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/01.%E9%98%BF%E9%87%8C%E7%AF%87/1.1.1-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AB%98%E6%95%88%E7%9A%84%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E8%BE%93%E5%87%BA/</guid>
      <description>问题：如何实现一个高效的单向链表逆序输出？ 出题人：阿里巴巴出题专家：昀龙／阿里云弹性人工智能负责人 参考答案：下面是其中一种写法，也可以有不同的写法，比如递归等。供参考。 typedef struct node{ int data; struct node* next; node(int d):data(d), next(NULL){} }node; void reverse(node* head) { if(head == NULL){ return; } node* pleft = NULL; node* pcurrent = head; node* pright = head-&amp;gt;next; while(pright){ pcurrent-&amp;gt;next = pleft; node *ptemp = pright-&amp;gt;next; pright-&amp;gt;next = pcurrent; pleft = pcurrent; pcurrent = pright; pright = ptemp; } while(pcurrent !=</description>
    </item>
    
    <item>
      <title>003 Apache Doris 数据模型</title>
      <link>https://geek.zshipu.com/post/bi/doris/004-Apache-Doris-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 01 Sep 2022 09:16:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/004-Apache-Doris-%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</guid>
      <description>数据模型 本文档主要从逻辑层面，描述 Doris 的数据模型，以帮助用户更好的使用 Doris 应对不同的业务场景。 基本概念 在 Doris 中，数据以表（Table）的形式进行逻辑上的描述。 一张表包括行（Row）和列（Column）。Row 即用户的一行数据。Column 用于描述一行数据中不同的字段。 Column 可以分为两大类：</description>
    </item>
    
    <item>
      <title>003 Apache Doris 创建表</title>
      <link>https://geek.zshipu.com/post/bi/doris/003-Apache-Doris-%E5%88%9B%E5%BB%BA%E8%A1%A8/</link>
      <pubDate>Thu, 01 Sep 2022 09:14:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/003-Apache-Doris-%E5%88%9B%E5%BB%BA%E8%A1%A8/</guid>
      <description>2.3 建表 使用 CREATE TABLE 命令建立一个表(Table)。更多详细参数可以查看: HELP CREATE TABLE; 首先切换数据库: USE example_db; Doris支持支持单分区和复合分区两种建表方式。 2.3.1 单分区 建立一个名字为 table1 的逻辑表。分桶列为 siteid，桶数为 10。 这个表的 schema 如下： siteid：类型是INT（4字节）, 默认值为10 cit</description>
    </item>
    
    <item>
      <title>002 Apache Doris 创建数据库</title>
      <link>https://geek.zshipu.com/post/bi/doris/002-Apache-Doris-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 01 Sep 2022 09:12:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/002-Apache-Doris-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>2.1 创建数据库 初始可以通过 root 或 admin 用户创建数据库： CREATE DATABASE example_db; 所有命令都可以使用 ‘HELP command;’ 查看到详细的语法帮助。如：HELP CREATE DATABASE; 如果不清楚命令的全名，可以使用 “help 命令某一字段” 进行模糊查询。如键入 ‘HELP CREATE’，可以匹配到 CREATE DATABASE, CREATE TABLE, CREATE USER 等命令。 数据库创建完成</description>
    </item>
    
    <item>
      <title>001 Apache Doris 安装</title>
      <link>https://geek.zshipu.com/post/bi/doris/001-Apache-Doris-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Thu, 01 Sep 2022 09:10:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/001-Apache-Doris-%E5%AE%89%E8%A3%85/</guid>
      <description>一.编译前准备 1.1 环境准备 主机配置: IP 主机名 部署 192.168.9.119 hw5 FE FS_Broker 192.168.9.120 hw6 BE FS_Broker 192.168.9.121 hw7 BE FS_Broker,FE Observer 192.168.9.122 hw8 BE FS_Broker 硬件配置： 每台主机：CPU4核、内存8G、硬盘150G 软件版本： 名称 版本 操作系统 CentOS release 7.8 (Final) 64位 JDK 1.11 yum install -y java-11-openjdk-devel.x86_64 ln -s /usr/lib/jvm/java-11-openjdk-11.0.13.0.8-1.el7_9.x86_64 /usr/lib/jvm/java11 vi /etc/profile JAVA_HOME=/usr/lib/jvm/java11 PATH=$JAVA_HOME/bin:$PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export JAVA_HOME export PATH export CLASSPATH source /etc/profile 1.2 安装Docker 1.2.1 卸载旧版本 yum remove docker docker-common docker-selinux docker-engine 1.2.2 安装需要的软件包</description>
    </item>
    
    <item>
      <title>000 Apache Doris 简介</title>
      <link>https://geek.zshipu.com/post/bi/doris/000-Apache-Doris-%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Thu, 01 Sep 2022 09:09:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/000-Apache-Doris-%E7%AE%80%E4%BB%8B/</guid>
      <description>一. Doris简介 Apache Doris是一个现代化的MPP分析型数据库产品。仅需亚秒级响应时间即可获得查询结果，有效地支持实时数据分析。Apache Doris的分布式架构非常简洁，易于运维，并且可以支持10PB以上的超大数据集。 Apache Doris可以满足多种数据分析需求，例如固定历史报表，实时</description>
    </item>
    
    <item>
      <title>BI-数据仓-数据体系的要义：贴源、规范、建模、标签、设计、建设</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB%E7%9A%84%E8%A6%81%E4%B9%89%E8%B4%B4%E6%BA%90%E8%A7%84%E8%8C%83%E5%BB%BA%E6%A8%A1%E6%A0%87%E7%AD%BE%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%BE/</link>
      <pubDate>Mon, 29 Aug 2022 19:30:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB%E7%9A%84%E8%A6%81%E4%B9%89%E8%B4%B4%E6%BA%90%E8%A7%84%E8%8C%83%E5%BB%BA%E6%A8%A1%E6%A0%87%E7%AD%BE%E8%AE%BE%E8%AE%A1%E5%BB%BA%E8%AE%BE/</guid>
      <description>.</description>
    </item>
    
    <item>
      <title>Apache Doris 是一个基于 MPP 架构的高性能、实时的分析型数据库</title>
      <link>https://geek.zshipu.com/post/bi/doris/Apache-Doris-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E-MPP-%E6%9E%B6%E6%9E%84%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9E%E6%97%B6%E7%9A%84%E5%88%86%E6%9E%90%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Wed, 17 Aug 2022 09:14:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/doris/Apache-Doris-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E-MPP-%E6%9E%B6%E6%9E%84%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9E%E6%97%B6%E7%9A%84%E5%88%86%E6%9E%90%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>版本：1.1 快速开始 Apache Doris 是一个基于 MPP 架构的高性能、实时的分析型数据库，以极速易用的特点被人们所熟知，仅需亚秒级响应时间即可返回海量数据下的查询结果，不仅可以支持高并发的点查询场景，也能支持高吞吐的复杂分析场景，这个简短的指南将告诉你如何下载 Doris 最新稳定版本，在单节点上安装并运行它，</description>
    </item>
    
    <item>
      <title>4.完全掌握 Next.js 文章系列</title>
      <link>https://geek.zshipu.com/post/react/level01/4.%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-Next.js-%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97/</link>
      <pubDate>Sun, 07 Aug 2022 09:07:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/level01/4.%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-Next.js-%E6%96%87%E7%AB%A0%E7%B3%BB%E5%88%97/</guid>
      <description>社区 GitHub Next GitHub 讨论Next.js 基本会话 博客 学习 韦尔塞尔电视 防弹 Next 文章 将 Next.js 与 FaunaDB 配合使用：如何从您的应用程序中查询数据库 如何使用ButterCMS构建无服务器Next.js博客 使用 Next 构建通用 JavaScript 应用.js Next.js — 设置应用 “Next.js — 引入数据 如何构建 Next.js React 通用应用 Next到Next.js 在</description>
    </item>
    
    <item>
      <title>3.Github1000个顶级组件应对各种业务场景</title>
      <link>https://geek.zshipu.com/post/react/level01/3.Github1000%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%94%E5%AF%B9%E5%90%84%E7%A7%8D%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Sun, 07 Aug 2022 09:05:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/level01/3.Github1000%E4%B8%AA%E9%A1%B6%E7%BA%A7%E7%BB%84%E4%BB%B6%E5%BA%94%E5%AF%B9%E5%90%84%E7%A7%8D%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF/</guid>
      <description>用户界面组件 可编辑的数据网格/电子表格 fortune-sheet - 一种在线spreedsheet组件，提供开箱即用的功能，就像Excel一样。 AG Grid - 高级数据网格/支持Javascript / React / AngularJS / Web Components的数据表。 gigatables-react - 排序，分页/无限滚动，全局/列搜索，AJAX CRUD等。 MUI X 数据网格 - 演</description>
    </item>
    
    <item>
      <title>React.js 中以正确的方式创建表单</title>
      <link>https://geek.zshipu.com/post/react/save01/React.js-%E4%B8%AD%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%8D%95/</link>
      <pubDate>Wed, 03 Aug 2022 10:00:25 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React.js-%E4%B8%AD%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%8D%95/</guid>
      <description>介绍 当创建一个注册表单时，发现自己创建了几十个 useStates，然后为这些 useStates 创建了几十个 onChange 处理程序。像这样的🤮 伙计，即使写这个是为了说明，也感到困倦！ 此外，不客气，用那可怕的*One Light*主题代码片段让你大开眼界。一些白色是有利于注意的！😉 所以&amp;hellip;&amp;helli</description>
    </item>
    
    <item>
      <title>前端知识点大全</title>
      <link>https://geek.zshipu.com/post/css/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Fri, 17 Jun 2022 09:05:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/css/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E5%85%A8/</guid>
      <description>一、简历 简历在找工作过程中是非常非常重要的，无论你是什么途径去面试的，面试你的人一定会看你的简历。 1、重点 简历就像高考作文——阅卷时间非常短。 内容要简洁。 直击重点，表现出自己的优势（只要是符合招人单位要求的都是优势，不是别人不会的你会才叫优势）。 2、简历包含的内容 个人信息。 专业技</description>
    </item>
    
    <item>
      <title>web3.0 全栈 Web3 开发完整指南</title>
      <link>https://geek.zshipu.com/post/web3.0/%E5%85%A8%E6%A0%88-Web3-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 11 Jun 2022 08:10:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E5%85%A8%E6%A0%88-Web3-%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <description>使用 Next.js、Polygon、Solidity、The Graph、IPFS 和 Hardhat 构建全栈 web3 应用程序 本教程的视频也可在此处获得 在这个深入的教程中，您将学习用于构建全栈 web3 应用程序的工具、协议和框架，最重要的是 - 如何将所有内容放在一起为将来构建您自己的任何想法奠定基础。 此应用程序的</description>
    </item>
    
    <item>
      <title>web3.0 全栈以太坊开发完整指南</title>
      <link>https://geek.zshipu.com/post/web3.0/%E5%85%A8%E6%A0%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 11 Jun 2022 07:00:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E5%85%A8%E6%A0%88%E4%BB%A5%E5%A4%AA%E5%9D%8A%E5%BC%80%E5%8F%91%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <description>使用 React、Ethers.js、Solidity 和 Hardhat 构建全栈 dApp 在本教程中，您将学习一个 web3 技术堆栈，该堆栈将允许您利用以太坊虚拟机 (EVM) 在包括 Ethereum、Polygon、Avalanche、Celo 和许多其他区块链网络在内的数十个区块链网络上构建全栈应用程序。 该项目的代码位于</description>
    </item>
    
    <item>
      <title>以太坊从零到略懂5：Truffle 快速入门体验智能合约</title>
      <link>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%825Truffle-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</link>
      <pubDate>Sat, 11 Jun 2022 05:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%825Truffle-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</guid>
      <description>安装Truffle 在你可以使用 Truffle 之前，你必须使用 npm 安装它。打开终端并使用以下命令进行全局安装。 npm install -g truffle 注意：我们建议您将 npm 与 nvm 之类的节点版本管理器一起使用，这实际上是 npm 本身所推荐的。请参阅npm 的这篇文章，了解如何使用节点版本管理器安装 npm。我们还建议不要sudo在安装 Truffle 时使用</description>
    </item>
    
    <item>
      <title>以太坊从零到略懂4： Web3.0 和 Solidity 开发路线图</title>
      <link>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%8242021-%E5%B9%B4-Web3.0-%E5%92%8C-Solidity-%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/</link>
      <pubDate>Sat, 11 Jun 2022 05:04:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%8242021-%E5%B9%B4-Web3.0-%E5%92%8C-Solidity-%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF%E5%9B%BE/</guid>
      <description>从完全零编程知识到 Solidity 和区块链专家，这就是我们将从计算机科学基础开始的原因。 1. Web3.0和区块链之前：计算机科学基础 摩天大楼需要坚实的基础才能不倒塌。 区块链开发这是一个艰难的主题，我不会撒谎。在深入研究节点和块并开始您的路线图之前，请更好地学习计算机科学的基础知识：哈佛大学自己发</description>
    </item>
    
    <item>
      <title>web3.0 以太坊从零到略懂3：开发第一个合约</title>
      <link>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%823%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6/</link>
      <pubDate>Sat, 11 Jun 2022 05:02:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%823%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6/</guid>
      <description>在这篇文章中，如果我们离开并开始开发一个基本的智能合约，并了解更多关于可靠性和合约如何工作的信息，我们将继续学习。 以太坊区块链最有趣的品质之一是创建数字代币的能力。代币是可以代表任何事物的数字资产，从硬币、忠诚度积分到物理世界中的实际对象。代币也可用于与其他智能合约进行交互。 代币</description>
    </item>
    
    <item>
      <title>web3.0 以太坊从零到略懂2：设置开发环境</title>
      <link>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%822%E8%AE%BE%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sat, 11 Jun 2022 05:01:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%822%E8%AE%BE%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <description>第 0 步：要求 您正在使用MacOS 您对软件开发有基本的了解 你知道以太坊是什么并且理解它是基本的用法。 您对MacOS 终端的使用有基本的了解。 你已经安装了自制软件 第一步：设置测试网 虽然我们正在学习以太坊开发的来龙去脉，但我们可能不想用真实的以太币来测试真实的生产网络。 例如，为此目的，有</description>
    </item>
    
    <item>
      <title>web3.0 以太坊从零到略懂1：简介</title>
      <link>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%821%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Sat, 11 Jun 2022 05:00:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web3.0/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BB%8E%E9%9B%B6%E5%88%B0%E7%95%A5%E6%87%821%E7%AE%80%E4%BB%8B/</guid>
      <description>2017 年可以说是加密货币的一年，比特币成为最受关注的焦点；在比特币的核心，我们有区块链。 区块链技术应用远远超出了数字货币，最好的例子之一是以太坊，它是一个运行智能合约的去中心化平台。 这允许开发人员构建功能强大的去中心化应用程序，此时围绕区块链和以太坊仍有许多积极的开发和创新。 所有这些</description>
    </item>
    
    <item>
      <title>css-level-007 CSS不透明度-透明度</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-007-CSS%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6-%E9%80%8F%E6%98%8E%E5%BA%A6/</link>
      <pubDate>Thu, 02 Jun 2022 10:08:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-007-CSS%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6-%E9%80%8F%E6%98%8E%E5%BA%A6/</guid>
      <description>该opacity属性指定元素的不透明度/透明度。 透明图像 该opacity属性的取值范围为 0.0 - 1.0。值越低，越透明： 不透明度 0.2 不透明度 0.5 不透明度 1 例子 img { opacity: 0.5; } 透明悬停效果 该opacity属性通常与:hover 选择器一起使用以更改鼠标悬停时的不透明度： 鼠标经过 例子 img { opacity: 0.5; } img:hover { opacity:</description>
    </item>
    
    <item>
      <title>css-level-006 CSS 中px、em、rem、%、vw、vh单位之间的区别详解</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-006-CSS-%E4%B8%ADpxemremvwvh%E5%8D%95%E4%BD%8D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Thu, 02 Jun 2022 10:07:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-006-CSS-%E4%B8%ADpxemremvwvh%E5%8D%95%E4%BD%8D%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E8%AF%A6%E8%A7%A3/</guid>
      <description>1 、px px就是pixel（像素）的缩写，相对长度单位，相对于屏幕分辨率。 2、em 参考物是父元素的font-size，具有继承的特点。浏览器默认字体是16px，整个页面内1em不是一个固定的值。 字体大小同样都是1.5em，但是效果却截然不同，按照W3C提供的公式，我们可以计算下：</description>
    </item>
    
    <item>
      <title>css-level-005 CSS选择器</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-005-CSS%E9%80%89%E6%8B%A9%E5%99%A8/</link>
      <pubDate>Wed, 01 Jun 2022 10:07:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-005-CSS%E9%80%89%E6%8B%A9%E5%99%A8/</guid>
      <description>CSS中，选择器用来指定网页上我们想要样式化的HTML元素。有CSS选择器提供了很多种方法，所以在选择要样式化的元素时，我们可以做到很精细的地步。本文和本文的子篇中，我们将会详细地讲授选择器的不同使用方式，并了解它们的工作原理。 学习前提： 计算机的基本知识， 安装了基础软件，处理文件</description>
    </item>
    
    <item>
      <title>css-level-004 CSS颜色体系-HSL</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-004-CSS%E9%A2%9C%E8%89%B2%E4%BD%93%E7%B3%BB-HSL/</link>
      <pubDate>Wed, 01 Jun 2022 10:06:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-004-CSS%E9%A2%9C%E8%89%B2%E4%BD%93%E7%B3%BB-HSL/</guid>
      <description>必看颜色 工具：调色板 HSL hue 色相 0° Red 60° Yellow 120° Green 180° Cyan 240° Blue 300° Magenta saturation 饱和度 饱和度（Saturation）是指色彩的纯度，饱和度越高色彩越纯越浓，饱和度越低则色彩变灰变淡。 lightness 亮度 亮度（Lightness）指的是色彩的明暗程度，亮度值越高，色彩越白，亮度越低，色彩越黑</description>
    </item>
    
    <item>
      <title>css-level-003 CSS颜色体系</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-003-CSS%E9%A2%9C%E8%89%B2%E4%BD%93%E7%B3%BB/</link>
      <pubDate>Wed, 01 Jun 2022 10:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-003-CSS%E9%A2%9C%E8%89%B2%E4%BD%93%E7%B3%BB/</guid>
      <description>&amp;lt;颜色&amp;gt; CSS 数据类型表示一种颜色。A 还可以包括 Alpha 通道*透明度值*，指示颜色应如何与其背景复合。&amp;lt;color&amp;gt; 可以通过以下任一方式定义 A：&amp;lt;color&amp;gt; 使用关键字（如 或 ）。所有现有关键字都指定 sRGB 色彩空间中的颜色bluetransparent 使用 RGB 三</description>
    </item>
    
    <item>
      <title>css-level-002 CSS基础</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-002-CSS%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 31 May 2022 10:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-002-CSS%E5%9F%BA%E7%A1%80/</guid>
      <description>一、 CSS组成部分 &amp;lt;p&amp;gt;Lorem ipsum dolor sit amet.&amp;lt;/p&amp;gt; &amp;lt;style&amp;gt; p{ color: red; } &amp;lt;/style&amp;gt; p : selector 选择器 {}: 放在在大括号内 color: property 属性 red: value 值 ；：每行结尾分号 二、三种方式添加CSS 外部样式表 保持.css link 引入到html 最常用 内部样式表 html文件内 style 包裹 偶热使用 内联样式 仅影响一个元素 html元素的style属性中添加 不推荐使用 三、选择器 &amp;lt;p</description>
    </item>
    
    <item>
      <title>nexp-level-002 01 Next.js &#43; NextUI 完美组合，引入CSS组件库</title>
      <link>https://geek.zshipu.com/post/nexp/level002/nexp-level-002-01-Next.js-&#43;-NextUI-%E5%AE%8C%E7%BE%8E%E7%BB%84%E5%90%88%E5%BC%95%E5%85%A5CSS%E7%BB%84%E4%BB%B6%E5%BA%93/</link>
      <pubDate>Mon, 30 May 2022 10:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level002/nexp-level-002-01-Next.js-&#43;-NextUI-%E5%AE%8C%E7%BE%8E%E7%BB%84%E5%90%88%E5%BC%95%E5%85%A5CSS%E7%BB%84%E4%BB%B6%E5%BA%93/</guid>
      <description>React + NextUI 安装 安装 在 React 项目目录中，通过运行以下任一命令安装 NextUI： yarn add @nextui-org/react # or npm i @nextui-org/react 设置 为了让 NextUI 正常工作，您需要NextUIProvider在应用程序的根目录下设置。 React 转到应用程序的根目录并执行以下操作： import * as React from &#39;react&#39;; // 1. import `NextUIProvider` component import { NextUIProvider } from &#39;@nextui-org/react&#39;; function App({ Component }) { // 2. Use at the root of your app return ( &amp;lt;NextUIProvider&amp;gt; &amp;lt;Component /&amp;gt; &amp;lt;/NextUIProvider&amp;gt; );</description>
    </item>
    
    <item>
      <title>Sharding JDBC  分片策略四：Hint强制路由HintShardingStrategy</title>
      <link>https://geek.zshipu.com/post/mybatis/Sharding-JDBC-%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5%E5%9B%9BHint%E5%BC%BA%E5%88%B6%E8%B7%AF%E7%94%B1HintShardingStrategy/</link>
      <pubDate>Mon, 23 May 2022 15:45:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/mybatis/Sharding-JDBC-%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5%E5%9B%9BHint%E5%BC%BA%E5%88%B6%E8%B7%AF%E7%94%B1HintShardingStrategy/</guid>
      <description>一、Hint强制路由HintShardingStrategy 在分库分区中，有些特定的SQL，Sharding-jdbc、Mycat、Vitess都不支持（可以查看相关文档各自对哪些SQL不支持）,例如：insert into table1 select * from table2 where &amp;hellip;.这种SQL 路由很麻烦，需要解析ta</description>
    </item>
    
    <item>
      <title>css-level-001 学习 TailwindCSS：制作个人资料卡</title>
      <link>https://geek.zshipu.com/post/nexp/css-level-01/css-level-001-%E5%AD%A6%E4%B9%A0-TailwindCSS%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E5%8D%A1/</link>
      <pubDate>Mon, 23 May 2022 10:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/css-level-01/css-level-001-%E5%AD%A6%E4%B9%A0-TailwindCSS%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E8%B5%84%E6%96%99%E5%8D%A1/</guid>
      <description>Tailwind 是一个 CSS 框架 Tailwind 是一个 CSS 框架，可让您轻松构建出色的响应式 UI。 如果您正在学习 TailwindCSS，此博客可以帮助您通过在 5 分钟内创建一个带有按钮的迷你配置文件卡来构建更强大的概念。 首先，您需要在项目中安装 Tailwind。现在有以下3种方法。访问您喜欢的那个。由于这是一张简单的</description>
    </item>
    
    <item>
      <title>nexp-level-001 06 添加组件级 CSS</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-06-%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6%E7%BA%A7-CSS/</link>
      <pubDate>Sat, 21 May 2022 10:05:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-06-%E6%B7%BB%E5%8A%A0%E7%BB%84%E4%BB%B6%E7%BA%A7-CSS/</guid>
      <description>Next.js 通过 [name].module.css 文件命名约定来支持 CSS 模块 。 CSS 模块通过自动创建唯一的类名从而将 CSS 限定在局部范围内。 这使您可以在不同文件中使用相同的 CSS 类名，而不必担心冲突。 此行为使 CSS 模块成为包含组件级 CSS 的理想方法。 CSS 模块文件 可以导入（import）到应用程序中的任何位置。 例如，假设 components/ 目录下有一个可重用 Button 组件</description>
    </item>
    
    <item>
      <title>nexp-level-001 05 学习 Next.js  使用共享组件</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-05-%E5%AD%A6%E4%B9%A0-Next.js-%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Sat, 21 May 2022 10:04:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-05-%E5%AD%A6%E4%B9%A0-Next.js-%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E7%BB%84%E4%BB%B6/</guid>
      <description>使用共享组件 我们知道 Next.js 是和页面相关的. 通过导出一个 React组件创建一个页面, 然后把它放到 pages 目录中, 基于这个文件名, Next.js存在一个固定的URL. 因为导出的页面是Javascript模块, 我们当然也能够导入其他组件进来. 在这节课中, 我们会创建一个共享的页头组件, 并在多个页面</description>
    </item>
    
    <item>
      <title>nexp-level-001 04 Next 的最佳样式选项</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-04-Next-%E7%9A%84%E6%9C%80%E4%BD%B3%E6%A0%B7%E5%BC%8F%E9%80%89%E9%A1%B9/</link>
      <pubDate>Sat, 21 May 2022 10:03:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-04-Next-%E7%9A%84%E6%9C%80%E4%BD%B3%E6%A0%B7%E5%BC%8F%E9%80%89%E9%A1%B9/</guid>
      <description>鲜为人知的是，Next.js提供了许多在应用程序中支持CSS的方法。无论你喜欢实用程序CSS及其类还是更喜欢CSS-in-JS，Next.js都能满足您的需求。在本教程中，您将发现在 Next.js 应用程序中实现样式设置的几种方法。让我们实现一个样式文本，当用户将其悬停在一起时，该文本将变为红</description>
    </item>
    
    <item>
      <title>nexp-level-001 03 服务器端渲染与客户端渲染</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-03-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Sat, 21 May 2022 10:02:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-03-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93/</guid>
      <description>最近在准备技术面试时，我偶然发现了服务器端渲染 (SSR) 和客户端渲染 (CSR) 的概念，我并不清楚它的含义，也不知道它们之间的区别是什么两种方法。 在我的研究中，我意识到在选择在您的网站上实施哪种方法时，这不是一个简单的决定。出于所有这些原因，我决定写一篇关于什么是 SSR 和 SCR 以及它们的优缺点的博文。 长期</description>
    </item>
    
    <item>
      <title>nexp-level-001 02 Next.js 与 React：差异和最佳前端框架</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-02-Next.js-%E4%B8%8E-React%E5%B7%AE%E5%BC%82%E5%92%8C%E6%9C%80%E4%BD%B3%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sat, 21 May 2022 10:01:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-02-Next.js-%E4%B8%8E-React%E5%B7%AE%E5%BC%82%E5%92%8C%E6%9C%80%E4%BD%B3%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</guid>
      <description>随着每年都有新的 JavaScript 框架和库出现，很难跟上不断变化的 JS 生态系统的步伐。 但即使在JavaScript 框架和库的汪洋大海中，React 和 Next.js 也能脱颖而出。React 是最受前端开发人员欢迎的 JavaScript 库。Next.js 虽然比 React 小，但多年来一直在稳步增长，并有望成为最常用的 JavaScript 框架。 React 的 UI 库非常健壮，</description>
    </item>
    
    <item>
      <title>nexp-level-001 01 Next.js 功能及介绍</title>
      <link>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-01-Next.js-%E5%8A%9F%E8%83%BD%E5%8F%8A%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sat, 21 May 2022 10:00:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nexp/level001/nexp-level-001-01-Next.js-%E5%8A%9F%E8%83%BD%E5%8F%8A%E4%BB%8B%E7%BB%8D/</guid>
      <description>介绍 在设定一个 React 项目时候，通常会使用 create-React-app 这个套件来快速产出开发样板环境，而另外一个选择 Next.js 则包好了许多功能，例如Server Side Render （SSR），Webpack，Router&amp;hellip;. 不需要额外再多花时间在设定方面，但同时又有弹性可以扩充，非常的快速可以马上开发项目，在使用next</description>
    </item>
    
    <item>
      <title>带有 Netflix DGS 和 Spring Boot 的 GraphQL 服务器</title>
      <link>https://geek.zshipu.com/post/graphql/%E5%B8%A6%E6%9C%89-Netflix-DGS-%E5%92%8C-Spring-Boot-%E7%9A%84-GraphQL-%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Wed, 18 May 2022 11:29:08 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/graphql/%E5%B8%A6%E6%9C%89-Netflix-DGS-%E5%92%8C-Spring-Boot-%E7%9A%84-GraphQL-%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>*定义*： GraphQL 是一种用于 API 的查询语言，也是一种使用现有数据完成这些查询的运行时。GraphQL 为您的 API 中的数据提供了完整且易于理解的描述，使客户能够准确地询问他们需要什么，仅此而已，使 API 更容易随着时间的推移而发展，并支持强大的开发人员工具。 什么是 Netflix DGS？ Netflix DGS (Domain Graph Service) 是一个基于 Spring Boot 用</description>
    </item>
    
    <item>
      <title>Docker部署gitlab(避坑版)</title>
      <link>https://geek.zshipu.com/post/gitlab/Docker%E9%83%A8%E7%BD%B2gitlab%E9%81%BF%E5%9D%91%E7%89%88/</link>
      <pubDate>Tue, 17 May 2022 13:49:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/gitlab/Docker%E9%83%A8%E7%BD%B2gitlab%E9%81%BF%E5%9D%91%E7%89%88/</guid>
      <description>1 下载docker # 安装依赖 yum install -y yum-utils device-mapper-persistent-data lvm2 # 设置yum源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 安装docker yum install -y docker-ce # 设置开机启动 systemctl enable docker # 启动 Docker systemctl start docker # 查看版本 docker version 2 下载gitlab镜像 docker pull gitlab/gitlab-ce:latest 3 运行 mkdir gitlab gitlab/etc gitlab/log gitlab/opt docker run -id -p 3000:80 -p 9922:22 -v /root/gitlab/etc:/etc/gitlab -v /root/gitlab/log:/var/log/gitlab -v /root/gitlab/opt:/var/opt/gitlab --restart always --privileged=true --name gitlab gitlab/gitlab-ce &#39;&#39;&#39; 命令解释： -i 以交互模式运行容器，通常与 -t 同时使用命令解释： -d 后</description>
    </item>
    
    <item>
      <title>用户画像-方法论与工程化解决方案</title>
      <link>https://geek.zshipu.com/post/bi/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F-%E6%96%B9%E6%B3%95%E8%AE%BA%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 17 May 2022 09:14:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F-%E6%96%B9%E6%B3%95%E8%AE%BA%E4%B8%8E%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2. React 很棒的组件</title>
      <link>https://geek.zshipu.com/post/react/level01/2.-React-%E5%BE%88%E6%A3%92%E7%9A%84%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 16 May 2022 09:23:02 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/level01/2.-React-%E5%BE%88%E6%A3%92%E7%9A%84%E7%BB%84%E4%BB%B6/</guid>
      <description>react-select - React 的选择组件 react-beautiful-dnd - 使用 React 的列表的漂亮且可访问的拖放 react-dnd - React 的拖放 react-grid-layout - 具有响应断点的可拖动和可调整大小的网格布局 react-table - 用于 React 的轻量级、快速且可扩展的数据网格 react-data-grid - 使用 React 构建的类似 Excel 的网格组件 react-draggable - React可拖动组件 react-resizable-and-movable - React 的可调整大小和可拖动组件 react-resizable - 一个简单的 React 组件，可以通过句柄调整大小</description>
    </item>
    
    <item>
      <title>1.初学者的 React</title>
      <link>https://geek.zshipu.com/post/react/level01/1.-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84-React-/</link>
      <pubDate>Mon, 16 May 2022 09:23:01 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/level01/1.-%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84-React-/</guid>
      <description>首先安装npm install create-react-app -g. 这样您就可以为您机器上的任何文件夹创建或运行 react 应用程序。 创建反应项目create-react-app react-starter运行命令空间并提供您的应用程序名称。所以这个命令创建了反应应用程序。并自动设置必要的开发服务器 babel 和 webpack。开发服务器帮助我们在</description>
    </item>
    
    <item>
      <title>2.3 拓展知识了解 TypeScript 中的高级概念</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.4-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3-TypeScript-%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sat, 14 May 2022 23:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.4-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E4%BA%86%E8%A7%A3-TypeScript-%E4%B8%AD%E7%9A%84%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5/</guid>
      <description>什么是打字稿？ TypeScript 由 Microsoft 创建和维护，是 JavaScript 的超集，这意味着所有功能性 JavaScript 代码在 TypeScript 下都是有效的。该语言可以理解为“用于应用程序级开发的 JavaScript”，主要关注两个方面： 提供从未来 JavaScript 引擎到当前 JavaScript 引擎的功能 为 JavaScript 提供类型系统 TypeScript 的组件通常是语言本身，本质上是 JavaScript 加上附加的功能和语法，将代码转</description>
    </item>
    
    <item>
      <title>2.3 拓展知识学习 TypeScript 指南</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.3-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-TypeScript-%E5%85%A8%E9%9D%A2%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sat, 14 May 2022 22:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.3-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-TypeScript-%E5%85%A8%E9%9D%A2%E6%8C%87%E5%8D%97/</guid>
      <description>什么是 Typescript？ Typescript是JavaScript的类型化超集，由Microsoft于2012年创建，旨在帮助Javascript开发人员使用大规模应用程序。Typescript旨在作为大型代码库的结构机制提供帮助，因为它有助于避免会减慢您速度的常见错误。它使</description>
    </item>
    
    <item>
      <title>2.2 拓展知识构建自己的 UI 组件库</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.2-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-UI-%E7%BB%84%E4%BB%B6%E5%BA%93/</link>
      <pubDate>Sat, 14 May 2022 21:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.2-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-UI-%E7%BB%84%E4%BB%B6%E5%BA%93/</guid>
      <description>UI 组件库是一组现成的 UI 组件，例如按钮、输入、对话框等。它们用作布局的构建块。由于它们的模块化特性，我们可以以多种不同的方式排列组件以实现独特的效果。每个库都有独特的外观和感觉，但它们中的大多数都提供主题，并且它们的组件是可定制和可重用的。 我将引导您完成创建自己的 UI 组件库的过程： React</description>
    </item>
    
    <item>
      <title>2.1 拓展知识_document.js 如何在 Next.js 中改进 SEO</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.1-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86_document.js-%E5%A6%82%E4%BD%95%E5%9C%A8-Next.js-%E4%B8%AD%E6%94%B9%E8%BF%9B-SEO/</link>
      <pubDate>Sat, 14 May 2022 20:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.1-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86_document.js-%E5%A6%82%E4%BD%95%E5%9C%A8-Next.js-%E4%B8%AD%E6%94%B9%E8%BF%9B-SEO/</guid>
      <description>首先，我们需要创建 Next.js 应用程序。如果您是 Next.js 新手，请按照这篇文章生成 Next.js 应用程序脚手架。 你在这里。公平地假设您已经设置了 Next.js 框架，并且您的应用程序正在http://localhost:300上运行。 此时，如果您查看源代码页面，那么您会看到 HTML 和 CSS。您还可以看到元标记、标题和元描述。但是</description>
    </item>
    
    <item>
      <title>2.搭建 Next.js 应用程序</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.%E6%90%AD%E5%BB%BA-Next.js-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Sat, 14 May 2022 19:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/2.%E6%90%AD%E5%BB%BA-Next.js-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</guid>
      <description>在本文中，我们将介绍 如何配置故事书 配置 TailwindCSS 添加 SEO 友好的 _document.js 创建基本组件 配置故事书 在上一篇文章中，我们在 Next.js 应用程序中安装和设置了故事书。安装过程会创建一个名为 stories 的文件夹。并且，在该文件夹下，有安装过程中附带的 JavaScript 文件。删除 stories 文件夹下的所有文件。它会在 6006 端口打破故事书。 安装以下内容： npm install @storybook/addon-postcss</description>
    </item>
    
    <item>
      <title>1.使用 Storybook、Tailwindcss 和 Apollo 客户端设置 Next.Js</title>
      <link>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/1.%E4%BD%BF%E7%94%A8-StorybookTailwindcss-%E5%92%8C-Apollo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E7%BD%AE-Next.Js/</link>
      <pubDate>Sat, 14 May 2022 18:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/storybooktailwindnextjs/1.%E4%BD%BF%E7%94%A8-StorybookTailwindcss-%E5%92%8C-Apollo-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AE%BE%E7%BD%AE-Next.Js/</guid>
      <description>要使用的技术堆栈 前端 作为 CSS 框架的 Tailwind NextJS storybook GraphQL 后端 作为 Perl 爱好者，我将使用 Mojolicious (Mic Drop)。 设置项目前端 在本文的这一部分，我们将设置 NextJs 项目 安装 Tailwind CSS 框架 设置storybook 使用 Apollo 客户端设置 GraphQL 一个 Git 存储库 设置 Next.js 项目 要在 Next.js 中创建新项目，请执行以下命令： npx create-next-app 在下一步中，它将询问应用程序名称，我们</description>
    </item>
    
    <item>
      <title>CSS 特性的完整指南</title>
      <link>https://geek.zshipu.com/post/css/CSS-%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <pubDate>Wed, 11 May 2022 09:05:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/css/CSS-%E7%89%B9%E6%80%A7%E7%9A%84%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <description>将样式应用于 HTML 的基础知识 CSS 为您的网站提供了颜色和设计。我们可以通过 3 种主要方式将样式应用于 HTML。这些都是： 内联样式：内联样式正是顾名思义，它们是与 HTML 元素内联编写的。例如 &amp;lt;div class=&amp;quot;button-link&amp;quot; style=&amp;quot;color: white; border: none; font-size: 16px; background-color: blue; width: 20%; padding: 1rem&amp;quot;&amp;gt;Button Text&amp;lt;/div&amp;gt; 这导致 div 如下所示，并应用了内联样式： 内部样式：内部样式基本上意味着要应用的样式</description>
    </item>
    
    <item>
      <title>Web 3.0：开发者路线图、指南和入门资源</title>
      <link>https://geek.zshipu.com/post/web/Web-3.0%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E6%8C%87%E5%8D%97%E5%92%8C%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90/</link>
      <pubDate>Wed, 11 May 2022 09:04:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/Web-3.0%E5%BC%80%E5%8F%91%E8%80%85%E8%B7%AF%E7%BA%BF%E5%9B%BE%E6%8C%87%E5%8D%97%E5%92%8C%E5%85%A5%E9%97%A8%E8%B5%84%E6%BA%90/</guid>
      <description>区块链仍然很突出，该行业现在迫切需要工程师。这不仅是一个有利可图的领域，而且也是一个令人着迷的领域。 如果您想成为其中的一员并提升您作为 Web 3.0 开发人员的职业生涯，您将需要专注于您的学习。 我将提供一个路线图和一些我在学习如何开始之后发现的很棒的在线资源。在本文中，您将从没有编程经验成为</description>
    </item>
    
    <item>
      <title>开始使用Apollo Graphql服务器</title>
      <link>https://geek.zshipu.com/post/graphql/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Apollo-Graphql%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>Wed, 04 May 2022 11:29:08 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/graphql/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Apollo-Graphql%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid>
      <description>本教程可帮助您： 获得对 GraphQL 原理的基本理解 定义一个表示数据集结构的 GraphQL 模式 运行 Apollo Server 实例，该实例允许您针对架构执行查询 本教程假定您熟悉命令行和 JavaScript，并且您安装了最新版本的 Node.js （12+）。 本教程将引导您完成阿波罗服务器的安装和配置。如果您刚刚开始使用 GraphQL 或 Apollo 平台，我们建议您先完</description>
    </item>
    
    <item>
      <title>Netty那点事（八）理解Netty中的异步</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/detail/ch1-async-in-netty/</link>
      <pubDate>Sun, 01 May 2022 20:07:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/detail/ch1-async-in-netty/</guid>
      <description>理解Netty中的异步 首先，事件驱动的Handler机制本身就是异步的。其次，ChannelFuture为异步操作提供了同步的方式。与Future对应的还有ChannelListener。 Future可以理解为化异步为同步的一个方式。JDK里的Future就是如此。 异步的概念和同</description>
    </item>
    
    <item>
      <title>Netty那点事（七）层层分析Netty中的Channel(下)</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/trival-notes/</link>
      <pubDate>Sun, 01 May 2022 20:06:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/trival-notes/</guid>
      <description>层层分析Netty中的Channel(下) 上篇文章讲到了Netty的Channel内部的运作机制和生命周期。这篇文章会走进Netty处理的内部，结合NIO，讲讲Netty中是如何实现Reactor模式的。 上篇文章讲到了Netty的Channel内部的运作机制，这篇文章详细分析Ch</description>
    </item>
    
    <item>
      <title>Netty那点事（六）使用netty构建一个socks proxy</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/socks-proxy-by-netty/</link>
      <pubDate>Sun, 01 May 2022 20:05:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/socks-proxy-by-netty/</guid>
      <description>【netty实战】使用netty构建一个socks proxy 最近在做的项目，需要自己搭建一个socks代理。netty4.0附带了一个socks代理的样例，但是3.x就没有这个东西了，碰巧使用的又是3.7，就只能自己摸索并实现一遍，也算是对netty和socks协议的一个熟悉。 socks</description>
    </item>
    
    <item>
      <title>Netty那点事（五）讲讲Handler</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/</link>
      <pubDate>Sun, 01 May 2022 20:02:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch5-handler/</guid>
      <description>Netty那点事（五）讲讲Handler 至上部分为止，我觉得Netty的架构部分已经差不多说完了，还有些细节，可以在实践中慢慢掌握。 但是对于实践来说，Netty还有不容忽视的一部分：Netty提供了大量的ChannelHandler，可以完成不同的任务。用好它们，会使Netty在</description>
    </item>
    
    <item>
      <title>Netty那点事（四）Netty与Reactor模式</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch4-reactor/</link>
      <pubDate>Sun, 01 May 2022 20:01:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch4-reactor/</guid>
      <description>Netty那点事（四）Netty与Reactor模式 一：Netty、NIO、多线程？ 时隔很久终于又更新了！之前一直迟迟未动也是因为积累不够，后面比较难下手。过年期间@李林锋hw发布了一个Netty5.0架构剖析和源码解读 http://vdisk.weibo.com/s/C9LV9</description>
    </item>
    
    <item>
      <title>Netty那点事（三）Channel中的Pipeline</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch3-pipeline/</link>
      <pubDate>Sun, 01 May 2022 19:57:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch3-pipeline/</guid>
      <description>Netty那点事（三）Channel中的Pipeline Channel是理解和使用Netty的核心。Channel的涉及内容较多，这里我使用由浅入深的介绍方法。在这篇文章中，我们主要介绍Channel部分中Pipeline实现机制。为了避免枯燥，借用一下《盗梦空间》的“梦境”概念</description>
    </item>
    
    <item>
      <title>Netty那点事（二）Netty中的buffer</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch2-buffer/</link>
      <pubDate>Sun, 01 May 2022 19:56:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch2-buffer/</guid>
      <description>Netty那点事（二）Netty中的buffer 上一篇文章我们概要介绍了Netty的原理及结构，下面几篇文章我们开始对Netty的各个模块进行比较详细的分析。Netty的结构最底层是buffer机制，这部分也相对独立，我们就先从buffer讲起。 What：buffer二三事 buf</description>
    </item>
    
    <item>
      <title>Netty那点事（一）概述</title>
      <link>https://geek.zshipu.com/post/netty/netty-learning/ch1-overview/</link>
      <pubDate>Sun, 01 May 2022 19:55:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/netty/netty-learning/ch1-overview/</guid>
      <description>Netty那点事（一）概述 起：Netty是什么 大概用Netty的，无论新手还是老手，都知道它是一个“网络通讯框架”。所谓框架，基本上都是一个作用：基于底层API，提供更便捷的编程模型。那么&amp;rdquo;通讯框架&amp;rdquo;到底做了什么事情呢？回答这个问题并不太容易，我们不妨反过</description>
    </item>
    
    <item>
      <title>更快学习编程的 10 个关键技巧</title>
      <link>https://geek.zshipu.com/post/web/%E6%9B%B4%E5%BF%AB%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84-10-%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Sun, 01 May 2022 18:55:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/%E6%9B%B4%E5%BF%AB%E5%AD%A6%E4%B9%A0%E7%BC%96%E7%A8%8B%E7%9A%84-10-%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8A%80%E5%B7%A7/</guid>
      <description>1.从基础开始，花更多时间在那里 许多学生在任何学习过程中犯的一个错误是尝试跳过基础知识或花更少的时间学习一门学科的基础知识，而是立即跳到第 3 章或第 4 章——忽略或略读前几章。 虽然这可能适用于某些知识领域，但在学习计算机编程时，您必须花更多时间充分掌握编码的基础知识。如果你是通过导师</description>
    </item>
    
    <item>
      <title>如何使用 MySQL 构建 Node.js REST API</title>
      <link>https://geek.zshipu.com/post/web/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-MySQL-%E6%9E%84%E5%BB%BA-Node.js-REST-API/</link>
      <pubDate>Sun, 01 May 2022 18:50:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-MySQL-%E6%9E%84%E5%BB%BA-Node.js-REST-API/</guid>
      <description>在本教程中，您将构建一个用于添加、更新和删除待办事项的简单数据库，本教程将向您展示如何使用 Express 和 MySQL 创建 REST API。可以克隆此项目的 GitHub 存储库以进行跟进。让我们开始吧，好吗？ 入门 本教程是一个动手演示。在开始之前，请确保您已准备好以下内容： 已安装 MySQL 数据库 安装了 Node.js 什么是 MySQL 数据库 MySQL 是一个开源的</description>
    </item>
    
    <item>
      <title>无需离开 IDE 即可部署您的第一个网站</title>
      <link>https://geek.zshipu.com/post/web/%E6%97%A0%E9%9C%80%E7%A6%BB%E5%BC%80-IDE-%E5%8D%B3%E5%8F%AF%E9%83%A8%E7%BD%B2%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/</link>
      <pubDate>Wed, 27 Apr 2022 11:29:08 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/%E6%97%A0%E9%9C%80%E7%A6%BB%E5%BC%80-IDE-%E5%8D%B3%E5%8F%AF%E9%83%A8%E7%BD%B2%E6%82%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/</guid>
      <description>我为什么建造它 我构建了一个 VS Code Extension，将代码部署到 GitHub Pages。 我一直想构建一个 VS 代码扩展，但我从来没有理由或足够的时间。现在我在 GitHub 的 DevRel 工作，我终于有机会这样做了！Microsoft VS Code 团队举办了一个简历网站研讨会，参与者将使用 HTML 和 CSS 构建的简历部署到 GitHub Pages。 我与</description>
    </item>
    
    <item>
      <title>知乎的用户画像与实时数据的架构与实践</title>
      <link>https://geek.zshipu.com/post/bi/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/%E7%9F%A5%E4%B9%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E4%B8%8E%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 25 Apr 2022 09:14:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/%E7%9F%A5%E4%B9%8E%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E4%B8%8E%E5%AE%9E%E6%97%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9E%B6%E6%9E%84%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>一、前言 知乎业务中，随着各业务线业务的发展，逐渐对用户画像和实时数据这两部分的诉求越来越多。对用户画像方面，期望有更快、更准、更方便的人群筛选工具和方便的用户群体分析能力。对于实时数据方面，期望拥有可以实时响应的用户行为流，同时在算法特征、指标统计、业务外显等业务场景有愈来愈多的</description>
    </item>
    
    <item>
      <title>React 18 - 新功能和改进策略</title>
      <link>https://geek.zshipu.com/post/react/save01/React-18-%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E6%94%B9%E8%BF%9B%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 24 Apr 2022 16:41:52 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-18-%E6%96%B0%E5%8A%9F%E8%83%BD%E5%92%8C%E6%94%B9%E8%BF%9B%E7%AD%96%E7%95%A5/</guid>
      <description>3 月 8 日，React 团队发布了 React 18 RC（Release Candidate）。最新版本带来了许多新功能，可以改变许多应用程序中的编码模式。它带来了一些性能改进，我将在本博客中介绍这些改进。 并发 并发是系统的一种属性，其中多个进程同时执行，并且可能会或可能不会相互交互。太复杂了？让我们</description>
    </item>
    
    <item>
      <title>DOM 和虚拟 DOM 的区别</title>
      <link>https://geek.zshipu.com/post/DDD/DOM-%E5%92%8C%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 24 Apr 2022 16:08:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DOM-%E5%92%8C%E8%99%9A%E6%8B%9F-DOM-%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>在本文中，我们将尝试找出什么是 DOM 及其存在的问题。什么是 Virtual DOM，并解释它是如何解决真实 DOM 的问题的。 [](#intro)介绍 Facebook 开发人员创建的 React 引入了一个新术语，虚拟 DOM。虚拟 DOM 在大幅提高使用该库创建的应用程序的性能方面发挥着重要作用。在下文中，我们将定义虚拟 DOM 和真实 DOM，并解释</description>
    </item>
    
    <item>
      <title>GlideIM - Golang 实现的高性能的分布式 IM</title>
      <link>https://geek.zshipu.com/post/go/GlideIM-Golang-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-IM/</link>
      <pubDate>Sun, 24 Apr 2022 13:08:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/GlideIM-Golang-%E5%AE%9E%E7%8E%B0%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-IM/</guid>
      <description>GlideIM 是一款真正的完全开源, Golang 实现的高性能分布式 IM 服务, 有完整的安卓 APP 示例, JAVA SDK, Web 端示例, 持续更新迭代中. GlideIM 支持单实例, 分布式部署. 支持 WebSocket, TCP 两种连接协议, 内置 JSON, ProtoBuff 两种消息交换协议, 并支持添加其他协议, 消息加密等. 还实现了智能心跳保活机制, 死链接检测, 消息送达机制等功能. 这个项目自 2020 年</description>
    </item>
    
    <item>
      <title>浏览器的工作原理 - 获取数据（第 2 部分，附插图）🚀</title>
      <link>https://geek.zshipu.com/post/react/save01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%AC%AC-2-%E9%83%A8%E5%88%86%E9%99%84%E6%8F%92%E5%9B%BE/</link>
      <pubDate>Sun, 24 Apr 2022 13:08:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%AC%AC-2-%E9%83%A8%E5%88%86%E9%99%84%E6%8F%92%E5%9B%BE/</guid>
      <description>在上一篇文章中，我们谈到navigation了浏览器显示网站的第一步。今天我们将进入下一步，看看如何resources get fetched。 2. 数据获取 HTTP 请求 在我们与服务器建立安全连接后，浏览器将发送一个初始的HTTP GET request. 首先，浏览器将请求HTML页面的标记 ( ) 文档。它将使用 HTTP 协议执行</description>
    </item>
    
    <item>
      <title>Flutter教程开坑篇 001</title>
      <link>https://geek.zshipu.com/post/flutter/Flutter%E6%95%99%E7%A8%8B%E5%BC%80%E5%9D%91%E7%AF%87/</link>
      <pubDate>Sun, 24 Apr 2022 12:31:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/Flutter%E6%95%99%E7%A8%8B%E5%BC%80%E5%9D%91%E7%AF%87/</guid>
      <description>在开始之前，我们先来了解下Flutter的架构和渲染机制 可以看到Flutter的架构主要分为三层:Framework，Engine和Embedder。 1.Framework使用dart实现，包括Material Design风格的Widget,Cupertino(针对iOS)风格的</description>
    </item>
    
    <item>
      <title>如果 Javascript 是单线程的，它是如何异步的</title>
      <link>https://geek.zshipu.com/post/javascript/%E5%A6%82%E6%9E%9C-Javascript-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%82%E6%AD%A5%E7%9A%84/</link>
      <pubDate>Sun, 24 Apr 2022 12:31:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E5%A6%82%E6%9E%9C-Javascript-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%BC%82%E6%AD%A5%E7%9A%84/</guid>
      <description>Javascript 是一种单线程语言。这意味着它有一个调用栈和一个内存堆。正如预期的那样，它按顺序执行代码，并且必须在执行下一段代码之前完成一段代码。它是同步的，但有时可能是有害的。例如，如果一个函数需要一段时间才能执行或必须等待某事，它会同时冻结所有内容。 发生这种情况的一个很好的例子是窗口警报功</description>
    </item>
    
    <item>
      <title>为什么 Flutter 使用 Dart</title>
      <link>https://geek.zshipu.com/post/flutter/%E4%B8%BA%E4%BB%80%E4%B9%88-Flutter-%E4%BD%BF%E7%94%A8-Dart/</link>
      <pubDate>Sun, 24 Apr 2022 11:31:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/%E4%B8%BA%E4%BB%80%E4%B9%88-Flutter-%E4%BD%BF%E7%94%A8-Dart/</guid>
      <description>以下是 Dart 功能的快速列表，它们共同使 Flutter 不可或缺： Dart 是 AOT（Ahead Of Time）编译成快速、可预测的原生代码，它允许几乎所有 Flutter 都可以用 Dart 编写。这不仅使 Flutter 速度更快，而且几乎所有东西（包括所有小部件）都可以自定义。 Dart 也可以进行 JIT（及时）编译，以实现极快的开发周期和改变游戏规则的工</description>
    </item>
    
    <item>
      <title>浏览器的工作原理 - 导航（第 1 部分，带插图）⚙️💥</title>
      <link>https://geek.zshipu.com/post/react/save01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%B8%A6%E6%8F%92%E5%9B%BE%EF%B8%8F/</link>
      <pubDate>Sun, 24 Apr 2022 10:08:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-%E5%AF%BC%E8%88%AA%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%B8%A6%E6%8F%92%E5%9B%BE%EF%B8%8F/</guid>
      <description>Browsers（也称为web browsers或Internet browsers）是安装在我们设备上的软件应用程序，允许我们访问万维网。您在阅读本文时实际上正在使用一个。 今天有许多浏览器在使用，截至 2021 年，最常用的浏览器是：Google Chrome、、Apple&#39;s Safari和。</description>
    </item>
    
    <item>
      <title>DDD-十、通过预定作业的最终一致性</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E5%8D%81%E9%80%9A%E8%BF%87%E9%A2%84%E5%AE%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sat, 23 Apr 2022 15:16:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E5%8D%81%E9%80%9A%E8%BF%87%E9%A2%84%E5%AE%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>如何从单个域事件处理程序失败或整个系统在事务提交后但在所有域事件处理程序处理事件之前崩溃的情况中恢复。 与软件中的大多数（如果不是全部？）问题一样，这里没有万能的解决方案。相反，您必须找到最能满足您的特定系统要求的解决方案。在这篇博文中，我们将研究一种保证最终一致性的简单（ish）</description>
    </item>
    
    <item>
      <title>DDD-九、使用 Spring Data 发布领域事件</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%B9%9D%E4%BD%BF%E7%94%A8-Spring-%E5%A4%84%E7%90%86%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sat, 23 Apr 2022 15:14:15 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%B9%9D%E4%BD%BF%E7%94%A8-Spring-%E5%A4%84%E7%90%86%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/</guid>
      <description>从 Spring 的角度来看，域事件只是另一个应用程序事件，可以使用内置的ApplicationEventPublisher. 换句话说，我们不需要担心构建事件总线或其他一些基础设施来发布域事件：您将事件发布者注入到您的域服务中并发布事件。但是，在大多数情况下，您希望直接从聚合中发布域事件，而不</description>
    </item>
    
    <item>
      <title>DDD-八、使用 Spring 处理领域事件</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E5%85%AB%E4%BD%BF%E7%94%A8-Spring-Data-%E5%8F%91%E5%B8%83%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Sat, 23 Apr 2022 15:14:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E5%85%AB%E4%BD%BF%E7%94%A8-Spring-Data-%E5%8F%91%E5%B8%83%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6/</guid>
      <description>Spring Data 使用标准发布域事件ApplicationEventPublisher。这意味着我们也可以使用标准的 Spring 方式处理事件，@EventListener所以让我们先来看看。 处理事件@EventListener 使用的域事件处理程序（我有时也使用术语*域事件侦听*器 - 它们的意思相同）@Ev</description>
    </item>
    
    <item>
      <title>DDD-七、在 Hibernate 中使用值对象作为聚合标识符</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%83%E5%9C%A8-Hibernate-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%81%9A%E5%90%88%E6%A0%87%E8%AF%86%E7%AC%A6/</link>
      <pubDate>Sat, 23 Apr 2022 15:13:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%83%E5%9C%A8-Hibernate-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E8%81%9A%E5%90%88%E6%A0%87%E8%AF%86%E7%AC%A6/</guid>
      <description>如果您使用的是除 Hibernate 之外的其他 JPA 实现，则必须查看该实现的文档以了解如何创建自定义类型。 属性转换器不会做 第一个想法可能是使用简单的值对象和属性转换器。不幸的是，这是不可能的，因为 JPA 不支持对@Id字段使用属性转换器。您可以做出妥协并为您的@Id字段和简单的值对象使用“原始”ID 以从其他</description>
    </item>
    
    <item>
      <title>DDD-六、使用 Spring Data 构建存储库</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E5%85%AD%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E5%AD%98%E5%82%A8%E5%BA%93/</link>
      <pubDate>Sat, 23 Apr 2022 15:12:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E5%85%AD%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E5%AD%98%E5%82%A8%E5%BA%93/</guid>
      <description>使用 Spring Data 构建存储库非常容易。您需要做的就是声明您的存储库接口并让它扩展 Spring Data 接口JpaRepository。但是，这也很容易意外地为本地实体创建存储库（如果您的开发人员不熟悉 DDD 但熟悉 JPA，则可能会发生这种情况）。因此，我总是像这样声明自己的基础存储库接口： @NoRepositoryBean // &amp;lt;1&amp;gt; public interface BaseRepository&amp;lt;Aggregate extends BaseAggregateRoot&amp;lt;ID&amp;gt;, ID extends Serializable&amp;gt; //</description>
    </item>
    
    <item>
      <title>DDD-五、使用 Spring Data 构建聚合</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%BA%94%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E8%81%9A%E5%90%88/</link>
      <pubDate>Sat, 23 Apr 2022 15:11:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%BA%94%E4%BD%BF%E7%94%A8-Spring-Data-%E6%9E%84%E5%BB%BA%E8%81%9A%E5%90%88/</guid>
      <description>JPA 有自己的@Entity概念，但远没有 DDD 中的实体概念那么严格。这既是优点也是缺点。优点是使用 JPA 实现实体和聚合非常容易。缺点是同样容易做 DDD 不允许的事情。如果您与以前广泛使用过 JPA 但不熟悉 DDD 的开发人员一起工作，这可能会特别成问题。 而值对象只是实现了一个空的标记接口，实体和聚合根将需要更</description>
    </item>
    
    <item>
      <title>DDD-四、在 JPA 中使用值对象</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E5%9B%9B%E5%9C%A8-JPA-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 23 Apr 2022 15:09:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E5%9B%9B%E5%9C%A8-JPA-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%80%BC%E5%AF%B9%E8%B1%A1/</guid>
      <description>在战术设计中，我们了解了值对象是什么以及它有什么用处。我们从未真正研究过如何在实际项目中使用它。现在是时候卷起袖子，仔细看看一些实际的代码了！ 值对象是领域驱动设计中最简单和最有用的构建块之一，因此让我们从了解在 JPA 中使用值对象的不同方式开始。为此，我们将从 XML Schema 规范中窃取*简单类型*</description>
    </item>
    
    <item>
      <title>DDD-三、领域驱动设计和六边形架构</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%89%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 23 Apr 2022 15:08:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%89%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</guid>
      <description>在前两篇文章中，我们了解了战略和战术领域驱动设计。现在是学习如何将领域模型转化为工作软件的时候了——更具体地说，是如何使用六边形架构来实现。 尽管代码示例是用 Java 编写的，但前两篇文章非常通用。虽然本文中的很多理论也可以应用到其他环境和语言中，但我在编写时明确考虑了 Java 和 Vaadin。 同</description>
    </item>
    
    <item>
      <title>DDD-二、战术领域驱动设计</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%BA%8C%E6%88%98%E6%9C%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 23 Apr 2022 14:53:28 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%BA%8C%E6%88%98%E6%9C%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>与战略领域驱动设计相比，战术设计更加亲力亲为，更接近实际代码。战略设计处理抽象的整体，而战术设计处理类和模块。战术设计的目的是将域模型细化到可以转换为工作代码的阶段。 设计是一个迭代过程，因此将战略设计和战术设计结合起来是有意义的。你从战略设计开始，然后是战术设计。最大的领域模型设</description>
    </item>
    
    <item>
      <title>DDD-一、战略领域驱动设计</title>
      <link>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%80%E6%88%98%E7%95%A5%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Sat, 23 Apr 2022 14:36:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD-%E4%B8%80%E6%88%98%E7%95%A5%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>领域驱动设计(DDD) 自_Eric Evans_于 2003 年出版他的有关该主题的书以来就一直存在。几年前，当我加入一个遭受数据一致性问题困扰的项目时，我自己就接触了 DDD。重复出现在数据库中，一些信息根本没有保存，你可能随时随地遇到乐观锁定错误。我们设法通过使用战术领域驱动设计的构建块来</description>
    </item>
    
    <item>
      <title>你必须准备的 50 个 React 面试问题</title>
      <link>https://geek.zshipu.com/post/react/save01/%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%87%86%E5%A4%87%E7%9A%84-50-%E4%B8%AA-React-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 Apr 2022 22:06:02 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/%E4%BD%A0%E5%BF%85%E9%A1%BB%E5%87%86%E5%A4%87%E7%9A%84-50-%E4%B8%AA-React-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</guid>
      <description>截至今天，Github 上有大约 1000 名贡献者。Virtual DOM 和可重用组件等独特功能吸引了前端开发人员的注意。尽管只是 MVC（模型-视图-控制器）中的“视图”库，但它与 Angular、Meteor、Vue 等成熟的框架竞争激烈。查看下面的图表，它显示了流行的 JS 框架的趋势： React面试</description>
    </item>
    
    <item>
      <title>React 初学者： 教程：React 简介 五</title>
      <link>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E6%95%99%E7%A8%8BReact-%E7%AE%80%E4%BB%8B-%E4%BA%94/</link>
      <pubDate>Fri, 22 Apr 2022 21:42:11 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E6%95%99%E7%A8%8BReact-%E7%AE%80%E4%BB%8B-%E4%BA%94/</guid>
      <description>什么是React？ React 是一个用于构建用户界面的声明式、高效且灵活的 JavaScript 库。它使您可以从称为“组件”的小而孤立的代码组成复杂的 UI。 React 有几种不同类型的组件，但我们将从React.Component子类开始： class ShoppingList extends React.Component { render() { return ( &amp;lt;div className=&amp;quot;shopping-list&amp;quot;&amp;gt; &amp;lt;h1&amp;gt;Shopping List for {this.props.name}&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Instagram&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;WhatsApp&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Oculus&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ); } } // Example usage: &amp;lt;ShoppingList name=&amp;quot;Mark&amp;quot; /&amp;gt; 我们很快就会谈到有趣</description>
    </item>
    
    <item>
      <title>React 初学者： JSX 简介 四</title>
      <link>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-JSX-%E7%AE%80%E4%BB%8B-%E5%9B%9B/</link>
      <pubDate>Fri, 22 Apr 2022 15:31:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-JSX-%E7%AE%80%E4%BB%8B-%E5%9B%9B/</guid>
      <description>React 是一个用于构建用户界面的声明性、高效和灵活的 JavaScript 库。但不是使用常规的 JavaScript，React 代码应该用一种叫做 JSX 的东西来编写。 让我们看一个示例 JSX 代码： 上面的代码片段有点像 HTML，它也使用了类似 JavaScript 的变量，但既不是 HTML 也不是 JavaScript，它是 JSX。JSX 基本上是常规</description>
    </item>
    
    <item>
      <title>React 初学者： 学习 ReactJS 之前必须了解的 5 大技能 三</title>
      <link>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%AD%A6%E4%B9%A0-ReactJS-%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84-5-%E5%A4%A7%E6%8A%80%E8%83%BD-%E4%B8%89/</link>
      <pubDate>Thu, 21 Apr 2022 14:25:43 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%AD%A6%E4%B9%A0-ReactJS-%E4%B9%8B%E5%89%8D%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84-5-%E5%A4%A7%E6%8A%80%E8%83%BD-%E4%B8%89/</guid>
      <description>在进入 React 之前，你对 JavaScript 有足够的了解吗？ 你知道如何使用 map() 方法在 javascript 或 ReactJS 中循环遍历数组吗？ 如果你在学习 React 并且遇到上述这些问题，那么你肯定在学习过程中犯了错误。毫无疑问，ReactJS 是前端开发者中最受欢迎的库，并且它的受欢迎程度与日俱增。在 ReactJS 上运行的网站看起来很漂亮，大多数开发初学者也被</description>
    </item>
    
    <item>
      <title>React 初学者： 如何学习 ReactJS 二</title>
      <link>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0-ReactJS-%E4%BA%8C/</link>
      <pubDate>Thu, 21 Apr 2022 14:21:52 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0-ReactJS-%E4%BA%8C/</guid>
      <description>每个前端开发人员和 Web 开发人员都知道在多个地方编写相同的代码是多么令人沮丧和痛苦。如果他们需要在多个页面上添加一个按钮，他们将被迫编写大量代码。即使在制作经常更改的组件时，使用其他框架的开发人员也面临着返工大多数代码的挑战。开发人员想要一个框架或库，允许他们分解复杂的组件并重用代码</description>
    </item>
    
    <item>
      <title>React 初学者： 创建新的 React 应用 一</title>
      <link>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-React-%E5%BA%94%E7%94%A8-%E4%B8%80/</link>
      <pubDate>Thu, 21 Apr 2022 14:10:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React-%E5%88%9D%E5%AD%A6%E8%80%85-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%9A%84-React-%E5%BA%94%E7%94%A8-%E4%B8%80/</guid>
      <description>使用集成的工具链，以实现最佳的用户和开发人员体验。 本页将介绍一些流行的 React 工具链，它们有助于完成如下任务： 扩展文件和组件的规模。 使用来自 npm 的第三方库。 尽早发现常见错误。 在开发中实时编辑 CSS 和 JS。 优化生产输出。 本页推荐的工具链无需配置即可开始使用。 你可能不需要工具链 如果你没有碰到上述</description>
    </item>
    
    <item>
      <title>深入理解Go的GC回收机制</title>
      <link>https://geek.zshipu.com/post/go/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E7%9A%84GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 23 Mar 2022 21:50:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Go%E7%9A%84GC%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description>GC：Garbage Collection（垃圾回收是编程语言中提供的自动的内存管理机制，自动释放不需要的内存对象，让出存储器资源。）GC过程中无需程序员手动执行，GC机制在现代很多编程语言都支持，GC能力的性能与优劣也是不同语言之间对比度指标之一。 关于Golang的GC在演进过程</description>
    </item>
    
    <item>
      <title>起步：如何为您的Next.js项目构建可扩展的架构</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/%E5%A6%82%E4%BD%95%E4%B8%BA%E6%82%A8%E7%9A%84Next.js%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 22 Mar 2022 18:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/%E5%A6%82%E4%BD%95%E4%B8%BA%E6%82%A8%E7%9A%84Next.js%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%8F%AF%E6%89%A9%E5%B1%95%E7%9A%84%E6%9E%B6%E6%9E%84/</guid>
      <description>什么是Next.js？ &amp;ldquo;Next.js为您提供了最佳的开发人员体验，其中包含生产所需的所有功能：混合静态和服务器渲染，TypeScript支持，智能捆绑，路由预取等。无需配置。 正如他们上面所说的那样，Next.js是一个多合一的全栈现代应用程序构建解决方案。它包括对T</description>
    </item>
    
    <item>
      <title>DDD实战：20 总结（二）：分布式架构关键设计10问</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9820-%E6%80%BB%E7%BB%93%E4%BA%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A110%E9%97%AE/</link>
      <pubDate>Tue, 22 Mar 2022 17:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9820-%E6%80%BB%E7%BB%93%E4%BA%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A110%E9%97%AE/</guid>
      <description>前面我们重点讲述了领域建模、微服务设计和前端设计方法，它们组合在一起就可以形成中台建设的整体解决方案。而中台大多基于分布式微服务架构，这种企业级的数字化转型有很多地方值得我们关注和思考。 我们不仅要关注企业商业模式、业务边界以及前中台的融合，还要关注数据技术体系、微服务设计、多活等</description>
    </item>
    
    <item>
      <title>DDD实战：19 总结（一）：微服务设计和拆分要坚持哪些原则</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9819-%E6%80%BB%E7%BB%93%E4%B8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%8B%86%E5%88%86%E8%A6%81%E5%9D%9A%E6%8C%81%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 22 Mar 2022 16:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9819-%E6%80%BB%E7%BB%93%E4%B8%80%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E6%8B%86%E5%88%86%E8%A6%81%E5%9D%9A%E6%8C%81%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99/</guid>
      <description>我们前面已经讲了很多 DDD 的设计方法和实践案例。虽然 DDD 的设计思想和方法很好，但由于企业发展历程以及企业技术和文化的不同，DDD 和微服务的实施策略也会有差异。那么面对这种差异，我们应该如何落地 DDD 和微服务呢？今天我们就来聊聊微服务的设计原则和演进策略。 微服务的演进策略 在从单体向微服务演进</description>
    </item>
    
    <item>
      <title>DDD实战：18 知识点串讲：基于DDD的微服务设计实例</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9818-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2%E5%9F%BA%E4%BA%8EDDD%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Tue, 22 Mar 2022 15:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9818-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%B2%E8%AE%B2%E5%9F%BA%E4%BA%8EDDD%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BE%8B/</guid>
      <description>为了更好地理解 DDD 的设计流程，今天我会用一个项目来带你了解 DDD 的战略设计和战术设计，走一遍从领域建模到微服务设计的全过程，一起掌握 DDD 的主要设计流程和关键点。 项目基本信息 项目的目标是实现在线请假和考勤管理。功能描述如下： 请假人填写请假单提交审批，根据请假人身份、请假类型和请假天数进行校</description>
    </item>
    
    <item>
      <title>DDD实战：17 从后端到前端：微服务后，前端如何设计</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9817-%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%88%B0%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Tue, 22 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9817-%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%88%B0%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%8E%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1/</guid>
      <description>微服务架构通常采用前后端分离的设计方式。作为企业级的中台，在完成单体应用拆分和微服务建设后，前端项目团队会同时面对多个中台微服务项目团队，这时候的前端人员就犹如维修电工一样了。 面对如此多的微服务暴露出来的 API 服务，如何进行正确的连接和拼装，才能保证不出错？这显然不是一件很容易的事情</description>
    </item>
    
    <item>
      <title>DDD实战：16 视图：如何实现服务和数据在微服务各层的协作</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9816-%E8%A7%86%E5%9B%BE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%84%E5%B1%82%E7%9A%84%E5%8D%8F%E4%BD%9C/</link>
      <pubDate>Tue, 22 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9816-%E8%A7%86%E5%9B%BE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%90%84%E5%B1%82%E7%9A%84%E5%8D%8F%E4%BD%9C/</guid>
      <description>在 DDD 分层架构和微服务代码模型里，我们根据领域对象的属性和依赖关系，将领域对象进行分层，定义了与之对应的代码对象和代码目录结构。分层架构确定了微服务的总体架构，微服务内的主要对象有服务和实体等，它们一起协作完成业务逻辑。 那在运行过程中，这些服务和实体在微服务各层是如何协作的呢？今天</description>
    </item>
    
    <item>
      <title>DDD实战：15 边界：微服务的各种边界在架构演进中的作用</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9815-%E8%BE%B9%E7%95%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%84%E7%A7%8D%E8%BE%B9%E7%95%8C%E5%9C%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Sun, 20 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9815-%E8%BE%B9%E7%95%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%84%E7%A7%8D%E8%BE%B9%E7%95%8C%E5%9C%A8%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>前几讲我们已经介绍过了，在用 DDD 进行微服务设计时，我们可以通过事件风暴来确定领域模型边界，划定微服务边界，定义业务和系统运行边界，从而保证微服务的单一职责和随需而变的架构演进能力。 那重点落到边界的时候，总结一下就是，微服务的设计要涉及到逻辑边界、物理边界和代码边界等等。 那么这些边界</description>
    </item>
    
    <item>
      <title>DDD实战：‎使用事件风暴和域驱动设计对反应式系统进行建模‎</title>
      <link>https://geek.zshipu.com/post/DDDxx/%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E5%92%8C%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AF%B9%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Sun, 20 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E5%92%8C%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AF%B9%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8C%E5%BB%BA%E6%A8%A1/</guid>
      <description>一个成功的事件风暴会议——以及一个成功的软件项目——需要同等的艺术、知识和技术技能。此外，对便笺进行更改比对生产代码进行更改要便宜得多。通过编写代码来了解您的系统是理解和完善所涉及的业务流程的一种非常昂贵的方法。‎ ‎本文中的任何内容都不需要技术专业知识或以前使用反应式事件驱动系统</description>
    </item>
    
    <item>
      <title>DDD实战：14 代码模型（下）：如何保证领域模型与代码模型的一致性</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9814-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Sat, 19 Mar 2022 15:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9814-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>在 [第 12 讲] 中，我们了解了如何用事件风暴来构建领域模型，在构建领域模型的过程中，我们会提取出很多的领域对象，比如聚合、实体、命令和领域事件等。到了 [第 13 讲]，我们又根据 DDD 分层架构模型，建立了标准的微服务代码模型，为代码对象定义好了分层和目录结构。 那要想完成微服务的设计和落地，这之</description>
    </item>
    
    <item>
      <title>DDD实战：13 代码模型（上）：如何使用DDD设计微服务代码模型</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9813-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DDD%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 19 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9813-%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8DDD%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E6%A8%A1%E5%9E%8B/</guid>
      <description>上一讲我们完成了领域模型的设计，接下来我们就要开始微服务的设计和落地了。那微服务落地时首先要确定的就是微服务的代码结构，也就是我今天要讲的微服务代码模型。 只有建立了标准的微服务代码模型和代码规范后，我们才可以将领域对象所对应的代码对象放在合适的软件包的目录结构中。标准的代码模型可</description>
    </item>
    
    <item>
      <title>DDD实战：12 领域建模：如何用事件风暴构建领域模型</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9812-%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E6%9E%84%E5%BB%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 19 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9812-%E9%A2%86%E5%9F%9F%E5%BB%BA%E6%A8%A1%E5%A6%82%E4%BD%95%E7%94%A8%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4%E6%9E%84%E5%BB%BA%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/</guid>
      <description>还记得我在 [第 01 讲] 中说过，微服务设计为什么要选择 DDD 吗？其中有一个非常重要的原因，就是采用 DDD 方法建立的领域模型，可以清晰地划分微服务的逻辑边界和物理边界。可以说，在 DDD 的实践中，好的领域模型直接关乎微服务的设计水平。因此，我认为 DDD 的战略设计是比战术设计更为重要的，也正是这个原因，我</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：13 JavaScript 启动性能瓶颈分析与解决方案</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript13-JavaScript-%E5%90%AF%E5%8A%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-/</link>
      <pubDate>Tue, 15 Mar 2022 15:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript13-JavaScript-%E5%90%AF%E5%8A%A8%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-/</guid>
      <description>JavaScript Start-up Performance|JavaScript 启动性能瓶颈分析与解决方案 Chrome 插件 Console Importer 推荐：Easily import JS and CSS resources from Chrome console. （可以在浏览器控制台安装 loadsh、moment、jQuery 等库，在控制台直接验证、使用这些库。） 参考资料： v8 官方文档 图解 Google V8 浏览器工作原理与实践 V8、Chrome、Node.js【知乎专栏】 JavaScript 引擎 V8</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：12 在 V8 引擎里 5 个优化代码的技巧</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript12-%E5%9C%A8-V8-%E5%BC%95%E6%93%8E%E9%87%8C-5-%E4%B8%AA%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Tue, 15 Mar 2022 14:24:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript12-%E5%9C%A8-V8-%E5%BC%95%E6%93%8E%E9%87%8C-5-%E4%B8%AA%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7/</guid>
      <description>对象属性的顺序: 在实例化你的对象属性的时候一定要使用相同的顺序，这样隐藏类和随后的优化代码才能共享； 动态属性: 在对象实例化之后再添加属性会强制使得隐藏类变化，并且会减慢为旧隐藏类所优化的代码的执行。所以，要在对象的构造函数中完成所有属性的分配； 方法: 重复执行相同的方法会运行的比不</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：11 13 个 JavaScript 性能提升技巧</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript11-13-%E4%B8%AA-JavaScript-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%8A%80%E5%B7%A7-/</link>
      <pubDate>Tue, 15 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript11-13-%E4%B8%AA-JavaScript-%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%8A%80%E5%B7%A7-/</guid>
      <description>Daniel Clifford 在 Google I/O2012 上做了一个精彩的演讲 “Breaking the JavaScript Speed Limit with V8”。在演讲中，他深入解释了 13 个简单的代码优化方法，可以让你的 JavaScript 代码在 Chrome V8 引擎编译 / 运行时更加快速。在演讲中，他介绍了怎么优化，并解释了原因。下面简明的列出了 13 个 JavaScript 性能提升技巧： 在构造函数里初始化所有对象的成员 (所以这些</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：10 机器码、字节码</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript10-%E6%9C%BA%E5%99%A8%E7%A0%81%E5%AD%97%E8%8A%82%E7%A0%81/</link>
      <pubDate>Tue, 15 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript10-%E6%9C%BA%E5%99%A8%E7%A0%81%E5%AD%97%E8%8A%82%E7%A0%81/</guid>
      <description>1、字节码 早期的 V8 为了提升代码的执行速度，直接将 JavaScript 源代码编译成了没有优化的二进制机器代码，如果某一段二进制代码执行频率过高，那么 V8 会将其标记为热点代码，热点代码会被优化编译器优化，优化后的机器代码执行效率更高。 随着移动设备的普及，V8 团队逐渐发现将 JavaScript 源码直接编译成二进制代码存在两</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：Javascript 与 V8</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript09-Javascript-%E4%B8%8E-V8/</link>
      <pubDate>Mon, 14 Mar 2022 23:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript09-Javascript-%E4%B8%8E-V8/</guid>
      <description>9.1、一等公民的定义 在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。如果某个编程语言的函数，可以和这个语言的数据类型做一样的事情，我们就把这个语言中的函数称为一等公民。 例如，字符串在几乎所有编程语言中都是一等公民，字符串可以做为函数参数，字符串可以</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：08 V8 是怎么执行一段 JavaScript 代码的</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript08-V8-%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84/</link>
      <pubDate>Mon, 14 Mar 2022 22:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript08-V8-%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84/</guid>
      <description>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，「这是 JavaScript 执行速度过慢的一个主要原因」。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计，这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。 另外，V8 也是早于其他虚拟机引入了惰性编译、内联缓存</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：07 解释执行和编译执行区别</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript07-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 14 Mar 2022 20:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript07-%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%8C%BA%E5%88%AB/</guid>
      <description>V8 本质上是一个虚拟机，因为计算机只能识别二进制指令，所以要让计算机执行一段高级语言通常有两种手段： 解释执行 需要先将输入的源代码通过解析器编译成中间代码，之后直接使用解释器解释执行中间代码，然后直接输出结果。具体流程如下图所示： 编译执行 采用这种方式时，也需要先将源代码转换为中间代码</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：V8 引擎的内部结构</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript06-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 14 Mar 2022 19:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript06-V8-%E5%BC%95%E6%93%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84/</guid>
      <description>V8 是一个非常复杂的项目，有超过 100 万行 C++ 代码。它由许多子模块构成，其中这 4 个模块是最重要的： Parse 负责将 JavaScript 源码转换为 Abstract Syntax Tree (AST)。确切的说，在 Parser 将 JavaScript 源码转换为 AST 前，还有一个叫 Scanner 的过程，具体流程如下： Ignition 即解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：05 什么是 V8</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript05-%E4%BB%80%E4%B9%88%E6%98%AF-V8/</link>
      <pubDate>Mon, 14 Mar 2022 18:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript05-%E4%BB%80%E4%B9%88%E6%98%AF-V8/</guid>
      <description>V8 是由 Google 开发的开源 JavaScript 引擎，是 JavaScript 虚拟机的一种，模拟实际计算机各种功能来实现代码的编译和执行。我们可以简单地把 JavaScript 虚拟机理解成是一个翻译程序，将人类能够理解的 编程语言 JavaScript，翻译成机器能够理解的机器语言。目前主要用在 Chrome 浏览器和 Node.js 中。如下图所示： 图中中间的「黑盒」就是 JavaScript 引擎</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：04 什么是 D8</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript04-%E4%BB%80%E4%B9%88%E6%98%AF-D8/</link>
      <pubDate>Mon, 14 Mar 2022 17:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript04-%E4%BB%80%E4%B9%88%E6%98%AF-D8/</guid>
      <description>D8 是一个非常有用的调试工具，你可以把它看成是 debug for V8 的缩写。我们可以使用 d8 来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优化的二进制代码、垃圾回收的状态，还可以使用 d8 提供的私有 API 查看一些内部信息。 V8 源码编译出来的可执行程序名为 d8。d8 作为 V8 引擎在命令行中可以使</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：03 热门 JavaScript 的引擎有哪些</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript03-%E7%83%AD%E9%97%A8-JavaScript-%E7%9A%84%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 14 Mar 2022 16:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript03-%E7%83%AD%E9%97%A8-JavaScript-%E7%9A%84%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>V8 (Google)，用 C++ 编写，开放源代码，由 Google 丹麦开发，是 Google Chrome 的一部分，也用于 Node.js。 JavaScriptCore (Apple)，开放源代码，用于 webkit 型浏览器，如 Safari ，2008 年实现了编译器和字节码解释器，升级为了 SquirrelFish。苹果内部代号为 “Nitro” 的 JavaScript 引擎也是基于 JavaScriptCore 引擎的。 Rhin</description>
    </item>
    
    <item>
      <title>DDD实战：10 DDD、中台和微服务：它们是如何协作的</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9810-DDD%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%83%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%8D%8F%E4%BD%9C%E7%9A%84/</link>
      <pubDate>Mon, 14 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9810-DDD%E4%B8%AD%E5%8F%B0%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%83%E4%BB%AC%E6%98%AF%E5%A6%82%E4%BD%95%E5%8D%8F%E4%BD%9C%E7%9A%84/</guid>
      <description>DDD 和微服务来源于西方，而中台诞生于中国的阿里巴巴。DDD 在二十多年前提出后一直默默前行，中台和微服务的理念近几年才出现，提出后就非常火爆。这三者看似风马牛不相及，实则缘分匪浅。中台是抽象出来的业务模型，微服务是业务模型的系统实现，DDD 作为方法论可以同时指导中台业务建模和微服务建</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：02 为什么需要 JavaScript 引擎</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript02-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-JavaScript-%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 14 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript02-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-JavaScript-%E5%BC%95%E6%93%8E/</guid>
      <description>我们写的 JavaScript 代码直接交给浏览器或者 Node 执行时，底层的 CPU 是不认识的，也没法执行。CPU 只认识自己的指令集，指令集对应的是汇编代码。写汇编代码是一件很痛苦的事情。并且不同类型的 CPU 的指令集是不一样的，那就意味着需要给每一种 CPU 重写汇编代码。 JavaScript 引擎可以将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等) 对应的汇编</description>
    </item>
    
    <item>
      <title>DDD实战：09 中台：数字转型后到底应该共享什么</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9809-%E4%B8%AD%E5%8F%B0%E6%95%B0%E5%AD%97%E8%BD%AC%E5%9E%8B%E5%90%8E%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%85%B1%E4%BA%AB%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 14 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9809-%E4%B8%AD%E5%8F%B0%E6%95%B0%E5%AD%97%E8%BD%AC%E5%9E%8B%E5%90%8E%E5%88%B0%E5%BA%95%E5%BA%94%E8%AF%A5%E5%85%B1%E4%BA%AB%E4%BB%80%E4%B9%88/</guid>
      <description>在上一讲中我们了解了分层架构的设计思想，并提到了这种设计思想对中台建设十分有利，那么今天我就来讲一讲中台。 中台是数字化转型的一个热门话题。继阿里提出中台概念后，很多人又提出了各种各样的中台。今天我们主要讨论业务中台和数据中台。作为企业数字化中台转型的整体，我也会顺带聊一聊前台和后</description>
    </item>
    
    <item>
      <title>让你更懂 JavaScript：JavaScript 的基本特性和设计思想</title>
      <link>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript01-JavaScript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Mon, 14 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/%E8%AE%A9%E4%BD%A0%E6%9B%B4%E6%87%82-JavaScript01-JavaScript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      <description>JavaScript 的语言设计，借鉴了很多语言的特性，比如: C 语言的基本语法、Java 的类型系统和内存管理、Scheme 的函数作为一等公民，还有 Self 基于原型（prototype）的继承机制。 JavaScript 是一门非常优秀的语言，特别是「原型继承机制」和「函数是一等公民」这两个设计。 JavaScript 也有很多的先天不足，例如：使用</description>
    </item>
    
    <item>
      <title>DDD实战：08 微服务架构模型：几种常见模型的对比和分析</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9808-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94%E5%92%8C%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 12 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9808-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94%E5%92%8C%E5%88%86%E6%9E%90/</guid>
      <description>在上一讲中我重点介绍了 DDD 分层架构，同时我也提到了微服务架构模型其实还有好多种，不知道你注意到了没？这些架构模型在我们的实际应用中都具有很高的借鉴价值。 那么今天我们就把 DDD 分层架构（详情介绍如有遗忘可回看 [第 07 讲] ）、整洁架构、六边形架构这三种架构模型放到一起，对比分析，看看如何利用</description>
    </item>
    
    <item>
      <title>DDD实战：07 DDD分层架构：有效降低层与层之间的依赖</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9807-DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%9C%89%E6%95%88%E9%99%8D%E4%BD%8E%E5%B1%82%E4%B8%8E%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/</link>
      <pubDate>Fri, 11 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9807-DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%9C%89%E6%95%88%E9%99%8D%E4%BD%8E%E5%B1%82%E4%B8%8E%E5%B1%82%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/</guid>
      <description>微服务架构模型有好多种，例如整洁架构、CQRS 和六边形架构等等。每种架构模式虽然提出的时代和背景不同，但其核心理念都是为了设计出“高内聚低耦合”的架构，轻松实现架构演进。而 DDD 分层架构的出现，使架构边界变得越来越清晰，它在微服务架构模型中，占有非常重要的位置。 那 DDD 分层架构到底长什么</description>
    </item>
    
    <item>
      <title>DDD实战：06 领域事件：解耦微服务的关键</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9806-%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E8%A7%A3%E8%80%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E9%94%AE/</link>
      <pubDate>Thu, 10 Mar 2022 13:27:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9806-%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6%E8%A7%A3%E8%80%A6%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%85%B3%E9%94%AE/</guid>
      <description>在事件风暴（Event Storming）时，我们发现除了命令和操作等业务行为以外，还有一种非常重要的事件，这种事件发生后通常会导致进一步的业务操作，在 DDD 中这种事件被称为领域事件。 这只是最简单的定义，并不能让我们真正理解它。那到底什么是领域事件？领域事件的技术实现机制是怎样的？这一</description>
    </item>
    
    <item>
      <title>DDD实战：05 聚合和聚合根：怎样设计聚合</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9805-%E8%81%9A%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E6%A0%B9%E6%80%8E%E6%A0%B7%E8%AE%BE%E8%AE%A1%E8%81%9A%E5%90%88/</link>
      <pubDate>Thu, 10 Mar 2022 13:26:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9805-%E8%81%9A%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E6%A0%B9%E6%80%8E%E6%A0%B7%E8%AE%BE%E8%AE%A1%E8%81%9A%E5%90%88/</guid>
      <description>我们先回顾下上一讲，在事件风暴中，我们会根据一些业务操作和行为找出实体（Entity）或值对象（ValueObject），进而将业务关联紧密的实体和值对象进行组合，构成聚合，再根据业务语义将多个聚合划定到同一个限界上下文（Bounded Context）中，并在限界上下文内完成领域</description>
    </item>
    
    <item>
      <title>DDD实战：04 实体和值对象：从领域模型的基础单元看系统设计</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9804-%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%8E%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8D%95%E5%85%83%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 10 Mar 2022 13:25:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9804-%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%8E%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E5%8D%95%E5%85%83%E7%9C%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
      <description>这两个概念都是领域模型中的领域对象。它们在领域模型中起什么作用，战术设计时如何将它们映射到代码和数据模型中去？就是我们这一讲重点要关注的问题。 另外，在战略设计向战术设计过渡的这个过程中，理解和区分实体和值对象在不同阶段的形态是很重要的，毕竟阶段不同，它们的形态也会发生变化，这与我</description>
    </item>
    
    <item>
      <title>DDD实战： 03 限界上下文：定义领域边界的利器</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9803-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AE%9A%E4%B9%89%E9%A2%86%E5%9F%9F%E8%BE%B9%E7%95%8C%E7%9A%84%E5%88%A9%E5%99%A8/</link>
      <pubDate>Thu, 10 Mar 2022 13:24:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9803-%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%AE%9A%E4%B9%89%E9%A2%86%E5%9F%9F%E8%BE%B9%E7%95%8C%E7%9A%84%E5%88%A9%E5%99%A8/</guid>
      <description>在 DDD 领域建模和系统建设过程中，有很多的参与者，包括领域专家、产品经理、项目经理、架构师、开发经理和测试经理等。 对同样的领域知识，不同的参与角色可能会有不同的理解，那大家交流起来就会有障碍，怎么办呢？因此，在 DDD 中就出现了“通用语言”和“限界上下文”这两个重要的概念。 什么是通用语言？</description>
    </item>
    
    <item>
      <title>DDD实战：02 领域、子域、核心域、通用域和支撑域</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9802-%E9%A2%86%E5%9F%9F%E5%AD%90%E5%9F%9F%E6%A0%B8%E5%BF%83%E5%9F%9F%E9%80%9A%E7%94%A8%E5%9F%9F%E5%92%8C%E6%94%AF%E6%92%91%E5%9F%9F/</link>
      <pubDate>Thu, 10 Mar 2022 13:23:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9802-%E9%A2%86%E5%9F%9F%E5%AD%90%E5%9F%9F%E6%A0%B8%E5%BF%83%E5%9F%9F%E9%80%9A%E7%94%A8%E5%9F%9F%E5%92%8C%E6%94%AF%E6%92%91%E5%9F%9F/</guid>
      <description>DDD 的知识体系提出了很多的名词，像：领域、子域、核心域、通用域、支撑域、限界上下文、聚合、聚合根、实体、值对象等等，非常多。这些名词，都是关键概念，但它们实在有些晦涩难懂，可能导致你还没开始实践 DDD 就打起了退堂鼓。因此，在基础篇中，我希望能带着你一起做好实践前的准备工作。 除此之外，我</description>
    </item>
    
    <item>
      <title>DDD实战：答疑：有关3个典型问题的讲解</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%98%E7%AD%94%E7%96%91%E6%9C%89%E5%85%B33%E4%B8%AA%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Thu, 10 Mar 2022 13:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%98%E7%AD%94%E7%96%91%E6%9C%89%E5%85%B33%E4%B8%AA%E5%85%B8%E5%9E%8B%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%B2%E8%A7%A3/</guid>
      <description>截至今天这一讲，我们的基础篇和进阶篇的内容就结束了。在这个过程中，我一直有关注大家提的问题。那在实战篇正式开始之前啊，我想针对 3 个比较典型的问题，做一个讲解，希望你也能同步思考，调动自己已学过的内容，这对我们后面实战篇的学习也是有一定帮助的。 问题 1：有关于领域可以划分为核心域、通</description>
    </item>
    
    <item>
      <title>DDD实战：01 领域驱动设计：微服务设计为什么要选择DDD</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9801-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9DDD/</link>
      <pubDate>Thu, 10 Mar 2022 12:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9801-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%80%89%E6%8B%A9DDD/</guid>
      <description>我们知道，微服务设计过程中往往会面临边界如何划定的问题，我经常看到项目团队为微服务到底应该拆多小而争得面红耳赤。不同的人会根据自己对微服务的理解而拆分出不同的微服务，于是大家各执一词，谁也说服不了谁，都觉得自己很有道理。 那在实际落地过程中，我也确实见过不少项目在面临这种微服务设计</description>
    </item>
    
    <item>
      <title>DDD实战：00 开篇词</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9800-%E5%BC%80%E7%AF%87%E8%AF%8D/</link>
      <pubDate>Thu, 10 Mar 2022 11:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD%E5%AE%9E%E6%88%9800-%E5%BC%80%E7%AF%87%E8%AF%8D/</guid>
      <description>目前热衷于采用领域驱动设计（DDD）实现中台业务建模，专注基于 DDD 的微服务设计和开发等。另外，我也正在深入探索传统企业中台数字化转型的技术和方法体系。很高兴在这个专栏和你见面！ 说起 DDD 的实践，那就不得不提微服务了。2015 年，我刚开始接触微服务，那时候和别人去介绍微服务的设计理念，接</description>
    </item>
    
    <item>
      <title>基于 DDD 的微服务设计和开发实战</title>
      <link>https://geek.zshipu.com/post/DDDxx/%E5%9F%BA%E4%BA%8E-DDD-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</link>
      <pubDate>Thu, 10 Mar 2022 10:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/%E5%9F%BA%E4%BA%8E-DDD-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</guid>
      <description>DDD 分层架构视图 DDD 分层架构包括：展现层、应用层、领域层和基础层。 DDD 分层架构各层职能如下： 展现层 展现层负责向用户显示信息和解释用户指令。 应用层 应用层是很薄的一层，主要面向用户用例操作，协调和指挥领域对象来完成业务逻辑。应用层也是与其他系统的应用层进行交互的必要渠道。应用层服务尽量简单</description>
    </item>
    
    <item>
      <title>当中台遇上 DDD，我们该如何设计微服务</title>
      <link>https://geek.zshipu.com/post/DDDxx/%E5%BD%93%E4%B8%AD%E5%8F%B0%E9%81%87%E4%B8%8A-DDD%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Thu, 10 Mar 2022 10:21:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/%E5%BD%93%E4%B8%AD%E5%8F%B0%E9%81%87%E4%B8%8A-DDD%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>“设计原则千万条，高内聚低耦合第一条，架构设计不规范，开发运维两行泪！”。 在分布式架构下，单体应用被拆分为多个微服务，为了保证微服务的单一职责和合理拆分，“高内聚、松耦合”是最宝贵的设计原则。 通俗点讲，高内聚就是把相关的行为聚集在一起，把不相关的行为放在别处，如果你要修改某个服务</description>
    </item>
    
    <item>
      <title>DDD&#43;微服务大型案例：Uber如何从复杂的RPC微服务转向面向业务领域的微服务架构DOMA</title>
      <link>https://geek.zshipu.com/post/DDDxx/DDD&#43;%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%A7%E5%9E%8B%E6%A1%88%E4%BE%8BUber%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%8D%E6%9D%82%E7%9A%84RPC%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84DOMA/</link>
      <pubDate>Thu, 10 Mar 2022 09:20:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDxx/DDD&#43;%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%A7%E5%9E%8B%E6%A1%88%E4%BE%8BUber%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A4%8D%E6%9D%82%E7%9A%84RPC%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BD%AC%E5%90%91%E9%9D%A2%E5%90%91%E4%B8%9A%E5%8A%A1%E9%A2%86%E5%9F%9F%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84DOMA/</guid>
      <description>Uber从单体到微服务转变 在Uber，我们采用了微服务架构，因为我们（大约在2012年至2013年）拥有两个整体服务，并且遇到了微服务解决的许多运营问题。 可用性风险。单一代码库中的单个回归可以使整个系统（在这种情况下，是整个Uber）瘫痪。 风险高昂的部署。由于频繁需要回滚，因此执</description>
    </item>
    
    <item>
      <title>MySql规范</title>
      <link>https://geek.zshipu.com/post/mysql/Mysql%E8%A7%84%E8%8C%83/</link>
      <pubDate>Wed, 09 Mar 2022 20:38:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/mysql/Mysql%E8%A7%84%E8%8C%83/</guid>
      <description>【强制】： ① 存储引擎必须使用 InnoDB 解读： InnoDB 支持事物、行级锁、并发性能更好，CPU 及内存缓存页优化使得资源利用率更高。 【强制】：②每张表必须设置一个主键 ID，且这个主键 ID 使用自增主键（在满足需要的情况下尽量短），除非在分库分表环境下 解读： 由于 InnoDB 组织数据的方式决定了需要有一个主键，而且若</description>
    </item>
    
    <item>
      <title>领域驱动设计 全局观-事件风暴落地过程</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%85%A8%E5%B1%80%E8%A7%82-%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4/</link>
      <pubDate>Mon, 07 Mar 2022 14:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E5%85%A8%E5%B1%80%E8%A7%82-%E4%BA%8B%E4%BB%B6%E9%A3%8E%E6%9A%B4/</guid>
      <description>强调您可以自己研究的重要领域驱动设计术语 强调通过本次讨论出现的重要泛在语言术语 我想专注于最终目标。在这一点上，我们正试图实现一个有效的上下文映射，我们可以快速制作原型 我们的第一个领域事件：&amp;rdquo;咖啡已购买&amp;rdquo; 团队要求 考虑一个将发生在他业务核心的事件。希望以客户为</description>
    </item>
    
    <item>
      <title>积分领域 DDD 实践</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E7%A7%AF%E5%88%86%E9%A2%86%E5%9F%9F-DDD-%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 07 Mar 2022 11:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E7%A7%AF%E5%88%86%E9%A2%86%E5%9F%9F-DDD-%E5%AE%9E%E8%B7%B5/</guid>
      <description>前言 原有用户业务线上，属于大熔炉模式，所有和用户相关的业务逻辑都放在用户工程下，用户账号，用户会员，用户积分，活动等等在各个业务逻辑中都有互相掺杂，在面对业务快速发展的新零售电商行业显得力不从心。在进行业务迭代，新需求开发，让整个用户系统伤筋动骨。 一、为什么要使用 DDD 1、贫血症引起</description>
    </item>
    
    <item>
      <title>Go的干净模板，领域驱动设计，清洁架构，Gin和GORM</title>
      <link>https://geek.zshipu.com/post/go/Go%E7%9A%84%E5%B9%B2%E5%87%80%E6%A0%B7%E6%9D%BF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%B4%81%E6%9E%B6%E6%9E%84Gin%E5%92%8CGORM/</link>
      <pubDate>Mon, 07 Mar 2022 08:55:38 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E7%9A%84%E5%B9%B2%E5%87%80%E6%A0%B7%E6%9D%BF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B8%85%E6%B4%81%E6%9E%B6%E6%9E%84Gin%E5%92%8CGORM/</guid>
      <description>GitHub Repo： https://github.com/resotto/goilerplate Goilerplate Go的干净样板，领域驱动设计，清洁架构，Gin和GORM。 什么是Goilerplate？ 使用清洁架构的好例子。 Go，Domain-Driven Design，Clean Architecture，Gin和GORM的火箭入门指南。 谁是Goilerplate的主要用户？ 各</description>
    </item>
    
    <item>
      <title>DDD021-有界上下文</title>
      <link>https://geek.zshipu.com/post/DDD/DDD021-%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Sun, 06 Mar 2022 23:23:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD021-%E6%9C%89%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>有界上下文是域驱动设计中的中心模式。这是DDD战略设计部分的重点，该部分是关于处理大型模型和团队的。DDD通过将它们划分为不同的有界上下文并明确它们的相互关系来处理大型模型。 DDD是关于基于底层域模型设计软件的。模型充当无处不在的语言，以帮助软件开发人员和领域专家之间的通信。它还</description>
    </item>
    
    <item>
      <title>DDD020-域驱动设计入门建模过程</title>
      <link>https://geek.zshipu.com/post/DDD/DDD020-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Sun, 06 Mar 2022 23:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD020-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B/</guid>
      <description>此过程为您提供了学习和实际应用领域驱动设计（DDD）各个方面的分步指南 - 从围绕组织的业务模型进行定位到编写领域模型。 使用此过程将指导您完成使用DDD思维方式设计软件系统的每个基本步骤，因此您可以专注于业务挑战，而不会同时学习DDD而不知所措。 一旦你经历了这个过程的几次迭代，你将拥</description>
    </item>
    
    <item>
      <title>人工智能领域推荐文集</title>
      <link>https://geek.zshipu.com/post/tlg/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%A2%86%E5%9F%9F%E6%8E%A8%E8%8D%90%E6%96%87%E9%9B%86/</link>
      <pubDate>Wed, 02 Mar 2022 11:57:29 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E9%A2%86%E5%9F%9F%E6%8E%A8%E8%8D%90%E6%96%87%E9%9B%86/</guid>
      <description>美团搜索中查询改写技术的探索与实践 端智能在大众点评搜索重排序的应用实践 美团 Flink 大作业部署与状态稳定性优化实践 赵鑫：强化学习在京东广告序列推荐中的应用 58 技术 | 深度学习排序在 58 招聘搜索场景的演进 【通知!!】2022 AIQ 全面开放注册 OPPO 唐黎：零代码技能平台技术实践探索！ 丁香园 | 电商搜索的语义</description>
    </item>
    
    <item>
      <title>Next.js学习系列：资源、metadata和 CSS 4</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-4/</link>
      <pubDate>Mon, 28 Feb 2022 10:04:19 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-4/</guid>
      <description>元素 如果我们想修改页面的元数据（如 HTML 标记），该怎么办？&amp;lt;title&amp;gt; &amp;lt;title&amp;gt;是 HTML 标记的一部分，因此让我们深入了解如何在 Next.js 页面中修改标记。&amp;lt;head&amp;gt;&amp;lt;head&amp;gt; 在编辑器中打开并找到以下行：pages/index.js Create Next App 请注</description>
    </item>
    
    <item>
      <title>Next.js学习系列：资源、metadata和 CSS 3</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-3/</link>
      <pubDate>Mon, 28 Feb 2022 09:52:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-3/</guid>
      <description>资产 Next.js可以在顶级public目录下提供静态资产，如图像。内部文件可以从应用程序的根目录引用，类似于pages。public 该目录还可用于 、Google 站点验证和任何其他静态资产。查看静态文件服务文档以了解更多信息。publicrobots.txt 下载您的个人资料图片 首</description>
    </item>
    
    <item>
      <title>Next.js学习系列：资源、metadata和 CSS 2</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-2/</link>
      <pubDate>Mon, 28 Feb 2022 09:12:49 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS-2/</guid>
      <description>下载入门代码（可选） 如果您不打算继续上一课，可以在下面下载、安装和运行本课程的入门代码。这将设置一个目录，使其与上一课的结果相同。nextjs-blog 同样，如果您刚刚完成上一课，则不需要这样做。 npx create-next-app nextjs-blog &amp;ndash;use-npm &amp;ndash;example &amp;ldquo;https://github.com/vercel/next-learn/tree/master/basics/assets-metadata-css-starter&amp;quot; 然后按照命令输出中的说明（进入目录并启动开发服务器）进行操作。cd</description>
    </item>
    
    <item>
      <title>Next.js学习系列：资源、metadata和 CSS</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS/</link>
      <pubDate>Mon, 28 Feb 2022 09:07:03 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E8%B5%84%E6%BA%90metadata%E5%92%8C-CSS/</guid>
      <description>我们添加的第二个页面当前没有样式。让我们添加一些 CSS 来设置页面样式。 Next.js内置了对 CSS 和 Sass 的支持。在本课程中，我们将使用 CSS。 本 节 课 还将 讨论 Next.js 如何处理静态资产（如图像）和页面metadata（如标记）。&amp;lt;title&amp;gt; 您将在本课中学到什么 在本课中，您将学习： 如何将</description>
    </item>
    
    <item>
      <title>Next.js学习系列：在页面之间导航4</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA4/</link>
      <pubDate>Fri, 25 Feb 2022 16:21:47 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA4/</guid>
      <description>客户端导航 &amp;quot;链接&amp;ldquo;组件支持在同一 Next.js 应用中的两个页面之间进行客户端导航。 客户端导航意味着_使用JavaScript_进行页面转换，这比浏览器完成的默认导航更快。 以下是验证它的简单方法： 使用浏览器的开发人员工具将 的 CSS 属性更改为 。background&amp;lt;htm</description>
    </item>
    
    <item>
      <title>Next.js学习系列：在页面之间导航3</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA3/</link>
      <pubDate>Fri, 25 Feb 2022 15:45:29 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA3/</guid>
      <description>链接组件 在网站上的页面之间链接时，请使用 HTML 标记。&amp;lt;a&amp;gt; 在&amp;rdquo;Next.js&amp;rdquo;中，使用&amp;rdquo;来自下一个组件/链接&amp;ldquo;来包装标记。 允许您执行客户端导航到应用程序中的其他页面。Link&amp;lt;a&amp;gt;&amp;lt;Link&amp;gt; 用&amp;lt</description>
    </item>
    
    <item>
      <title>Next.js学习系列：在页面之间导航2</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA2/</link>
      <pubDate>Fri, 25 Feb 2022 15:40:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA2/</guid>
      <description>如果要继续上一课，可以跳过此页面。单击下面的按钮转到下一页。 下载入门代码（可选） 如果您不打算继续上一课，可以在下面下载、安装和运行本课程的入门代码。这将设置一个目录，使其与上一课的结果相同。nextjs-blog 同样，如果您刚刚完成上一课，则不需要这样做。 npx create-next-app nextjs-blog &amp;ndash;use-npm &amp;ndash;example &amp;ldquo;https://github.com/vercel/next-learn/tree/master/basics/navigate-between-pages-starter&amp;quot; 然后按照命令</description>
    </item>
    
    <item>
      <title>Next.js学习系列：在页面之间导航</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA1/</link>
      <pubDate>Fri, 25 Feb 2022 15:38:11 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA1/</guid>
      <description>到目前为止，我们创建的Next.js应用只有一个页面。网站和Web应用程序通常具有许多不同的页面。 让我们探讨一下如何向应用程序添加更多页面。 您将在本课中学到什么 在本课中，您将： 使用集成文件系统路由创建新页面。 了解如何使用链接组件在页面之间启用客户端导航。 了解对代码拆分和预取的内置</description>
    </item>
    
    <item>
      <title>Next.js学习系列：在页面之间导航</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA/</link>
      <pubDate>Fri, 25 Feb 2022 15:33:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%AF%BC%E8%88%AA/</guid>
      <description>到目前为止，我们创建的Next.js应用只有一个页面。网站和Web应用程序通常具有许多不同的页面。 让我们探讨一下如何向应用程序添加更多页面。 您将在本课中学到什么 在本课中，您将： 使用集成文件系统路由创建新页面。 了解如何使用链接组件在页面之间启用客户端导航。 了解对代码拆分和预取的内置</description>
    </item>
    
    <item>
      <title>Next.js学习系列：创建Next.js应用4</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A84/</link>
      <pubDate>Fri, 25 Feb 2022 15:26:03 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A84/</guid>
      <description>编辑页面 让我们尝试编辑初学者页面。 确保 Next.js 开发服务器仍在运行。 使用文本编辑器打开。pages/index.js 找到标签下显示&amp;ldquo;欢迎加入&amp;rdquo;的文本，并将其更改为&amp;ldquo;学习&amp;rdquo;。&amp;lt;h1&amp;gt; 保存文件。 保存文件后，浏览器会自动使用新文本更新</description>
    </item>
    
    <item>
      <title>Next.js学习系列：创建Next.js应用3</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A83/</link>
      <pubDate>Fri, 25 Feb 2022 15:22:36 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A83/</guid>
      <description>欢迎来到 Next.js 当您访问 http://localhost:3000 时，您应该会看到这样的页面。这是初学者模板页面，其中显示了有关Next.js的一些有用信息。 可获得帮助：如果您遇到困难，可以在GitHub讨论中联系社区。 让我们尝试接下来编辑此页面！</description>
    </item>
    
    <item>
      <title>Next.js学习系列：创建Next.js应用2</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A82/</link>
      <pubDate>Fri, 25 Feb 2022 15:19:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A82/</guid>
      <description>设置 首先，让我们确保您的开发环境已准备就绪。 如果您没有安装 Node.js，请从此处安装它。您需要 Node.js版本 10.13 或更高版本。 在本教程中，你将使用自己的文本编辑器和终端应用。 如果您使用的是 Windows，我们建议您下载 Git for Windows 并使用随附的 Git Bash，它支持本教程中特定于 UNIX 的命令。</description>
    </item>
    
    <item>
      <title>Next.js学习系列：创建Next.js应用</title>
      <link>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A8/</link>
      <pubDate>Fri, 25 Feb 2022 15:12:33 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/nextjs/nextjsbase/Next.js%E5%AD%A6%E4%B9%A0%E7%B3%BB%E5%88%97%E5%88%9B%E5%BB%BANext.js%E5%BA%94%E7%94%A8/</guid>
      <description>要使用 React 从头开始构建一个完整的 Web 应用程序，您需要考虑许多重要的细节： 代码必须使用像webpack这样的捆绑器捆绑在一起，并使用像Babel这样的编译器进行转换。 您需要执行生产优化，例如代码拆分。 您可能希望静态预呈现某些页面以提高性能和 SEO。您可能还希望使用服务器端呈现或客户端呈</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 手机游戏</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F-/</link>
      <pubDate>Wed, 16 Feb 2022 16:43:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E6%89%8B%E6%9C%BA%E6%B8%B8%E6%88%8F-/</guid>
      <description>多人社交 平衡 - 一个带球的逻辑谜题，你能找到有缺陷的球吗？谷歌播放 ChaseWhisplyProject - Chase Whisply是一个FPS。你必须寻找，找到并杀死生活在你周围的鬼魂。 ClonesOnline - ClonesOnline是一款在线多人安卓棋盘游戏。 Colorphun - ColorPhun是一款基于简单色彩的Android游戏。 黎明前最黑暗 - 适用于A</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - PC - 大型游戏</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E5%A4%A7%E5%9E%8B%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 16 Feb 2022 16:19:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E5%A4%A7%E5%9E%8B%E6%B8%B8%E6%88%8F/</guid>
      <description>大型多人在线角色扮演 《永恒之地 - 永恒之地》是一款免费的多人在线角色扮演游戏，由Radu Privantu于2002年创建。现在就开始玩吧！ FreeSO - 重新實現《The Sims Online》。现在就开始玩吧！ 侠盗猎车手 - 侠盗猎车手V的在线合作修改，现在就开始玩吧！ Meridian 59 - 第一款3D MMORPG，于1</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - PC - 休闲类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E4%BC%91%E9%97%B2%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 16:00:30 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E4%BC%91%E9%97%B2%E7%B1%BB/</guid>
      <description>AssaultCube - Wouter van Oortmerssen的FPS完全转换，称为Cube。 AssaultCube Reloaded - AssaultCube Reloaded。 BZFlag - 跨平台，C++的3D坦克FPS。射击，躲闪和夺取旗帜。 城堡 - 黑暗幻想场景中的FPS。包括作为奖励 DOOM E1M1 级别在现代技术中完成的。 欺骗者 - 在这个以世界尽头为背景的哲学射击游戏中，向墙壁，天花板和</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - PC - 联机类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E8%81%94%E6%9C%BA%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:53:13 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E8%81%94%E6%9C%BA%E7%B1%BB/</guid>
      <description>Alieanum - My Ludum Dare 33 entry.有点像子弹地狱射手。 比尔万特 - 只需点击啤酒！ Bitfighter - 多人太空格斗街机游戏。现在就开始玩吧！ Boenken - 2人游戏，是足球和台球的混合体 Bombermaaan - Bombermaaan是经典炸弹人游戏的克隆。 C-Dogs SDL - 经典 DOS 游戏的头顶射击端口。 混沌投射物 - 带有RPG元素的2D运行和枪支动作游戏。 Clonepoint</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - PC - 动作类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E5%8A%A8%E4%BD%9C%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:52:26 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-PC-%E5%8A%A8%E4%BD%9C%E7%B1%BB/</guid>
      <description>Oolite - Oolite是一部基于Elite的开放世界太空歌剧 OpenTomb - 开源古墓丽影1-5引擎重制版。</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  其他类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%85%B6%E4%BB%96%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:02:29 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%85%B6%E4%BB%96%E7%B1%BB/</guid>
      <description>野兽 - 向1984年ASCII游戏&amp;rdquo;BEAST&amp;rdquo;致敬，由Dan Baker，Alan Brown，Mark Hamilton和Derrick Shadel用node编写。你必须在可推的方块之间压扁小ASCII野兽，但要注意你不要被它们吃掉。 binb - 竞技，多人，实时，猜歌</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  策略类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AD%96%E7%95%A5%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:02:02 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AD%96%E7%95%A5%E7%B1%BB/</guid>
      <description>远古野兽 - 物化和控制野兽，以击败你的对手！现在就开始玩吧！ 篮球GM - 单人篮球管理模拟游戏。现在就开始玩吧！ 命令与征服 - 流行RTS的克隆。现在就开始玩吧！ Freeciv-web - 一款在HTML5中实现的回合制策略游戏。现在就开始玩吧！ Galaxy of Drones Online - 一款开源的多人太空战略游戏。现在就开始玩吧！ Hexa Battle - 一款回合</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  沙盒类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B2%99%E7%9B%92%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:01:27 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B2%99%E7%9B%92%E7%B1%BB/</guid>
      <description>3d.城市 - 3d城市建设者游戏。现在就开始玩吧！ Blk Game - 多人 Javascript/WebGL 体素世界游戏演示。现在就开始玩吧！ Cube Engine - 完全用HTML5编写的3D引擎，没有OpenGL。现在就开始玩吧！ Project Cube - 基于使用HTML5制作的Minecraft的体素游戏。现在就开始玩吧！</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  角色扮演类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:01:02 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94%E7%B1%BB/</guid>
      <description>Diablo JS - html5 canvas 和 javascript 上的 Isometric minimal-code style game。现在就开始玩吧！ FGMK - 用于JSON编写的JRPG游戏的Javascript引擎，带有PyQt Ui。现在就开始玩吧！ Roguish - 用JavaScript创建的RPG/类似Rogue的游戏。现在就开始玩吧！ 变化的空间 - 随机生成的动作RPG。现在就开始玩吧！</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  竞速类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AB%9E%E9%80%9F%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 14:00:23 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AB%9E%E9%80%9F%E7%B1%BB/</guid>
      <description>HexGL - Thibaut Despoulain使用HTML5，Javascript和WebGL的未来主义HTML5赛车游戏。现在就开始玩吧！ 触发拉力赛在线版 - 快速街机拉力赛。现在就开始玩吧！</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  益智类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%9B%8A%E6%99%BA%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 13:52:09 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%9B%8A%E6%99%BA%E7%B1%BB/</guid>
      <description>.buk - .buk是一个立方体滚动益智游戏。现在就开始玩吧！ 0hh0 - Q42的0hh1的配套游戏。现在就开始玩吧！ 0hh1 - Q42的可爱小逻辑游戏。现在就开始玩吧！ 2048 - 滑动添加游戏 现在玩吧！ 暗室 - 用JavaScript编写的极简主义文本冒险游戏。现在就开始玩吧！ 字谜 - 字谜的文字游戏和API。现在就</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 -  指定攻击类</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%8C%87%E5%AE%9A%E6%94%BB%E5%87%BB%E7%B1%BB/</link>
      <pubDate>Wed, 16 Feb 2022 13:51:38 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%8C%87%E5%AE%9A%E6%94%BB%E5%87%BB%E7%B1%BB/</guid>
      <description>阴谋点击器 - 死亡射线游戏的阴谋点击器 粒子点击器 - 令人上瘾的增量游戏，教玩家高能粒子物理学的历史。现在就开始玩吧！ 群模拟器 - 从只有几只幼虫和一小堆肉开始，建立一个由数万亿只巨大的外星虫子组成的无情群体。现在就开始玩吧！ 点按点按冒险 - 浏览器任务的扩展。现在就开始玩吧！ 房子 - 你在一个奇</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 - 平台游戏</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 16 Feb 2022 13:50:46 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%B9%B3%E5%8F%B0%E6%B8%B8%E6%88%8F/</guid>
      <description>Chromacore - 2D音乐平台游戏，设置在一个黑暗，黑白的世界中，通过成功的游戏玩法逐渐变得更加丰富多彩和快乐。 Emberwind - 独立平台游戏Emberwind的HTML5移植版。现在就开始玩吧！ OpenLara - 经典古墓丽影开源引擎。 PixelPlatformer - 简单的平台游戏，展示了实体游戏引擎的强大功能。 平台 - 使用Phaser游戏引擎制作的</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 - 大型多人在线角色扮演</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%A7%E5%9E%8B%E5%A4%9A%E4%BA%BA%E5%9C%A8%E7%BA%BF%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94/</link>
      <pubDate>Wed, 16 Feb 2022 13:49:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%A4%A7%E5%9E%8B%E5%A4%9A%E4%BA%BA%E5%9C%A8%E7%BA%BF%E8%A7%92%E8%89%B2%E6%89%AE%E6%BC%94/</guid>
      <description>BrowserQuest - HTML5/JavaScript 多人游戏实验。现在就开始玩吧！ Mudlet - 一个跨平台，开源和超快速的MUD（纯文本MMORPG）客户端，在Lua中编写脚本。 The Tale （俄語：Сказка） - 俄羅斯多人 ZPG 沙盒。现在就开始玩吧！</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 - 第一人称射击</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E5%B0%84%E5%87%BB/</link>
      <pubDate>Wed, 16 Feb 2022 13:49:29 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E5%B0%84%E5%87%BB/</guid>
      <description>BananaBread - 将立方体2 / Sauerbraten 3D游戏引擎/第一人称射击游戏移植到Web，使用Emscripten将C++和OpenGL编译为JavaScript和WebGL。现在就开始玩吧！ QuakeJS - QuakeJS是在Emscripten的帮助下将ioquake3移植到JavaScript。现在就开始玩吧！</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 - 棋盘桌游</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%A3%8B%E7%9B%98%E6%A1%8C%E6%B8%B8/</link>
      <pubDate>Wed, 16 Feb 2022 13:48:01 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%A3%8B%E7%9B%98%E6%A1%8C%E6%B8%B8/</guid>
      <description>3D Hartwing国际象棋套装 - 在HTML / CSS / JS中完成的3D国际象棋游戏。现在就开始玩吧！ Android： Netrunner - 一款双人生活卡牌游戏（LCG），以反乌托邦的赛博朋克未来为背景，用Clojure和Clojurescript编写。现在就开始玩吧！ c4 - 连接四个游戏，与AI，在HTML</description>
    </item>
    
    <item>
      <title>Github高星开源游戏 - 基于浏览器 - 小创意游戏</title>
      <link>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%B0%8F%E5%88%9B%E6%84%8F%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 16 Feb 2022 13:45:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/github/Github%E9%AB%98%E6%98%9F%E5%BC%80%E6%BA%90%E6%B8%B8%E6%88%8F-%E5%9F%BA%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8-%E5%B0%8F%E5%88%9B%E6%84%8F%E6%B8%B8%E6%88%8F/</guid>
      <description>Alge&amp;rsquo;s Escapade - HTML5，JavaScript，GameJs街机游戏，您可以在其中控制藻类。现在就开始玩吧！ 外星人入侵 - 移动HTML5游戏开发的演示游戏。现在就开始玩吧！ 岚 - 岚是街机游戏《暴风雨》的克隆版。现在就开始玩吧！ 小行星 - 纯JavaScript小行星。现在就开始玩吧！ Avabranch - GitHub Game Off 2012</description>
    </item>
    
    <item>
      <title>Web3.0 - 构建 Web3 数据应用的下一个体系结构</title>
      <link>https://geek.zshipu.com/post/web/Web3.0-%E6%9E%84%E5%BB%BA-Web3-%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
      <pubDate>Wed, 16 Feb 2022 11:46:59 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/Web3.0-%E6%9E%84%E5%BB%BA-Web3-%E6%95%B0%E6%8D%AE%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid>
      <description>Web3 数据架构 Web3 和 Web2 应用程序之间的主要区别在于它们的数据体系结构。Web3 应用程序依赖于以用户为中心的（&amp;rdquo;自主权&amp;rdquo;或&amp;rdquo;主权&amp;rdquo;）数据存储体系结构。在此模型中，应用程序数据托管在分散的网络上，与每个单独的用户一起存储，并由应用程序客户端写入</description>
    </item>
    
    <item>
      <title>技术架构图</title>
      <link>https://geek.zshipu.com/post/tlg/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/</link>
      <pubDate>Wed, 16 Feb 2022 11:38:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Web3.0 - 定义web3</title>
      <link>https://geek.zshipu.com/post/web/Web3.0-%E5%AE%9A%E4%B9%89web3/</link>
      <pubDate>Mon, 14 Feb 2022 15:54:27 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/Web3.0-%E5%AE%9A%E4%B9%89web3/</guid>
      <description>在成为传统的全栈开发人员大约10年后，我于2021年4月过渡到web3。在深入研究所有这些新技术和想法时，我想知道的第一件事是&amp;rdquo;什么是web3堆栈？ 在构建传统的Web或移动应用程序时，我经常依靠少数构建块来完成工作。 API/应用程序服务器（REST 或 GraphQL） 身</description>
    </item>
    
    <item>
      <title>ReactJS-10个在2022年成为React.js开发人员的最佳网站</title>
      <link>https://geek.zshipu.com/post/react/save01/10%E4%B8%AA%E5%9C%A82022%E5%B9%B4%E6%88%90%E4%B8%BAReact.js%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BD%91%E7%AB%99/</link>
      <pubDate>Sun, 05 Dec 2021 22:04:18 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/10%E4%B8%AA%E5%9C%A82022%E5%B9%B4%E6%88%90%E4%B8%BAReact.js%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%9A%84%E6%9C%80%E4%BD%B3%E7%BD%91%E7%AB%99/</guid>
      <description>如果您想成为一名 React 开发人员，或者只是想学习 React.js完成前端任务，并寻找在 2022 年学习 React 的最佳网站，那么您来对地方了。 早些时候，我已经分享了最好的React.js课程，书籍和完整的React.js开发人员路线图，今天，我将分享最好的网站和在线平台，以便在2022年学习React</description>
    </item>
    
    <item>
      <title>Android 4.x 支持HTTPS请求</title>
      <link>https://geek.zshipu.com/post/android/Android-4.x-%E6%94%AF%E6%8C%81HTTPS%E8%AF%B7%E6%B1%82/</link>
      <pubDate>Wed, 03 Nov 2021 10:10:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/android/Android-4.x-%E6%94%AF%E6%8C%81HTTPS%E8%AF%B7%E6%B1%82/</guid>
      <description>定义 SSLSocketFactoryCompat，在创建 Socket 的时候如果是 4.x 的设备则启用 TLSv1.2 import android.os.Build; import java.io.IOException; import java.net.InetAddress; import java.net.Socket; import java.security.KeyManagementException; import java.security.NoSuchAlgorithmException; import javax.net.ssl.SSLContext; import javax.net.ssl.SSLSocket; import javax.net.ssl.SSLSocketFactory; public class SSLSocketFactoryCompat extends SSLSocketFactory{ private static final String[] TLS_V12_ONLY = {&amp;quot;TLSv1.2&amp;quot;}; private final SSLSocketFactory delegate; public SSLSocketFactoryCompat() throws KeyManagementException, NoSuchAlgorithmException { SSLContext sc = SSLContext.getInstance(&amp;quot;TLS&amp;quot;); sc.init(null, null, null); delegate = sc.getSocketFactory(); } public SSLSocketFactoryCompat(SSLSocketFactory delegate) { if (delegate == null) { throw new NullPointerException(); } this.delegate = delegate; } @Override public String[] getDefaultCipherSuites() { return delegate.getDefaultCipherSuites(); } @Override public String[] getSupportedCipherSuites() { return delegate.getSupportedCipherSuites(); } private Socket enableTls12(Socket socket) { if (Build.VERSION.SDK_INT &amp;gt;= 16 &amp;amp;&amp;amp; Build.VERSION.SDK_INT &amp;lt; 20)</description>
    </item>
    
    <item>
      <title>Nifi-Apache Nifi-Apache nifi 第一篇</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-Apache-nifi-%E7%AC%AC%E4%B8%80%E7%AF%87-/</link>
      <pubDate>Sat, 30 Oct 2021 13:01:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-Apache-nifi-%E7%AC%AC%E4%B8%80%E7%AF%87-/</guid>
      <description>1、什么是 Apache NiFi？ 简单地说，NiFi 是为了自动化系统之间的数据流。虽然*数据流这种形式很容易理解*，但我们在此使用它来表示系统之间的自动化和不同系统之间数据的流转。企业拥有多个系统，其中一些系统创建了数据，部分系统消耗了数据，那么问题就出现了。出现的问题和解决方案已经广泛讨论</description>
    </item>
    
    <item>
      <title>Nifi-Apache Nifi-基础指南大全</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Sat, 30 Oct 2021 13:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-%E5%9F%BA%E7%A1%80%E6%8C%87%E5%8D%97%E5%A4%A7%E5%85%A8/</guid>
      <description>介绍 Apache NiFi 是基于基于流量编程概念的数据流系统。它支持数据路由、转换和系统调停逻辑的强大且可扩展的定向图形。NiFi 拥有基于 Web 的用户界面，用于设计、控制、反馈和监控数据流。它在服务质量的几个方面具有高度可配置性，例如耐损性与保证交付、低延迟与高吞吐量以及基于优先级的排队。NiFi 为接</description>
    </item>
    
    <item>
      <title>Nifi-Apache Nifi-系统管理大全</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%A4%A7%E5%85%A8/</link>
      <pubDate>Sat, 30 Oct 2021 12:01:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/Nifi-Apache-Nifi-%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E5%A4%A7%E5%85%A8/</guid>
      <description>系统要求 Apache NiFi 可以在笔记本电脑这样简单的东西上运行，但它也可以聚类到许多企业级服务器上。因此，所需的硬件和内存数量将取决于所涉及的数据流的规模和性质。数据存储在磁盘上，而 NiFi 正在处理它。因此，NiFi 需要为其各种存储库分配足够的磁盘空间，特别是内容存储库、流文件存储库和出处存储库（请</description>
    </item>
    
    <item>
      <title>WebRTC Weekly 一周技术 &amp; 产品总结 21-10-31</title>
      <link>https://geek.zshipu.com/post/webrtc/WebRTC-Weekly-%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF-%E4%BA%A7%E5%93%81%E6%80%BB%E7%BB%93-21-10-31/</link>
      <pubDate>Sat, 30 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/webrtc/WebRTC-Weekly-%E4%B8%80%E5%91%A8%E6%8A%80%E6%9C%AF-%E4%BA%A7%E5%93%81%E6%80%BB%E7%BB%93-21-10-31/</guid>
      <description>两年后 Skype Web 版本现在也能在 Firefox 上使用了 Skype 作为 VOIP 鼻祖级别的公司，被微软收购之后反而走向了下坡路， 很多人可能已经忘记了 Skype。微软的 Teams 推出之后， 由于跟 Office 套件的捆绑策略迅速抢占了大量的企业办公协同市场， 就在人们以为微软会放弃 Skype 之后， Skype 终于让他的 web 版本，支持了 firefox。前一段时间甚</description>
    </item>
    
    <item>
      <title>Metabase教程系列-各种可视化元素基本运用</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E5%90%84%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%83%E7%B4%A0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</link>
      <pubDate>Tue, 26 Oct 2021 10:12:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E5%90%84%E7%A7%8D%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%83%E7%B4%A0%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%94%A8/</guid>
      <description>数字 数字选项用于显示单个数字，漂亮又大。数字选项包括： 添加字符前缀或后缀（因此您可以做一些事情，如把一个货币符号在前面或一个百分比在年底），） 设置要包含的十进制位置数，以及 将结果乘以数字（如要将十进制乘以 100，使其看起来像百分比）。如果你想*除*以一个数字，那么只需乘以小数（例</description>
    </item>
    
    <item>
      <title>Metabase教程系列-Metabase基本认识和初级分析</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-Metabase%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E7%BA%A7%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 25 Oct 2021 10:12:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-Metabase%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86%E5%92%8C%E5%88%9D%E7%BA%A7%E5%88%86%E6%9E%90/</guid>
      <description>Metabase介绍及基础使用 Metabase概述 Metabase是基于一个java语言开发的一款开源的数据分析工具，主要通过给公司人员提问题的方式（ps:相对于Metabase中的Question）对数据进行根据自己的需求进行提炼。帮助你把数据库中的数据更好的,多样化的呈现给更</description>
    </item>
    
    <item>
      <title>BI-可视化-Metabase与CBoard差异化分析说明</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-Metabase%E4%B8%8ECBoard%E5%B7%AE%E5%BC%82%E5%8C%96%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E/</link>
      <pubDate>Mon, 25 Oct 2021 10:11:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-Metabase%E4%B8%8ECBoard%E5%B7%AE%E5%BC%82%E5%8C%96%E5%88%86%E6%9E%90%E8%AF%B4%E6%98%8E/</guid>
      <description>这里的CBoard是在原生态CBoard基础上进行二次开发之后的BI工具，以下内容将其称为Mydata。 相似点 1.可以下载查询出的数据。 2.底层均采用java开发。 3.可视化拖拉拽查询方式。 4.均支持二次开发。 5.支持在图表上方进行数值筛选。 6.均支持自定义表达式，Metabas</description>
    </item>
    
    <item>
      <title>BI-可视化-superset、metabase、redash三个开源BI工具的个人使用心得及分析</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-supersetmetabaseredash%E4%B8%89%E4%B8%AA%E5%BC%80%E6%BA%90BI%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%8F%8A%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 25 Oct 2021 10:10:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/BI-%E5%8F%AF%E8%A7%86%E5%8C%96-supersetmetabaseredash%E4%B8%89%E4%B8%AA%E5%BC%80%E6%BA%90BI%E5%B7%A5%E5%85%B7%E7%9A%84%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%E5%8F%8A%E5%88%86%E6%9E%90/</guid>
      <description>数据可视化也是大数据领域里极为关键的一环，通过计算引擎算出来的数据往往需要以合适又美观的图表形式展示给产品经理和决策者，一开始笔者的部门用的是SpringBoot+ECharts的经典组合来做可视化的，确实功能很强也很灵活，但后来随着统计需求越来越多，每来一个新需求都要写大量的重</description>
    </item>
    
    <item>
      <title>BI-ETL-在10分钟内掌握Apache Airflow</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-%E5%9C%A810%E5%88%86%E9%92%9F%E5%86%85%E6%8E%8C%E6%8F%A1Apache-Airflow/</link>
      <pubDate>Sun, 24 Oct 2021 19:44:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-%E5%9C%A810%E5%88%86%E9%92%9F%E5%86%85%E6%8E%8C%E6%8F%A1Apache-Airflow/</guid>
      <description>介绍 一个pache 气流是用于协调复杂工作流和数据处理管道的开源工具。它是一个平台，以编程方式安排和监控预定工作的工作流程。 Apache 气流使您的工作流程简单、井然有序、系统化，因此可以根据要求轻松编写和安排时间。 让我们从基础知识开始。 **我们所说的工作流程是什么意思？ 工作流程可以是您的简单</description>
    </item>
    
    <item>
      <title>BI-ETL-开始使用Apache Airflow</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B-101-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Apache-Airflow/</link>
      <pubDate>Sun, 24 Oct 2021 19:41:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B-101-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Apache-Airflow/</guid>
      <description>概述 了解Apache Airflow及其部件的需求 我们将创建我们的第一个 DAG 获得现场板球得分使用Apache Airflow 介绍 工作自动化在任何行业都发挥着关键作用，是实现功能效率的最快方法之一。但是，我们中的许多人不知道如何自动化一些任务，并结束在手动做同样的事情一次又一次的循环。 我们大多数人必</description>
    </item>
    
    <item>
      <title>BI-ETL-Apache Airflow简介：5分钟内开始</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-Apache-Airflow%E7%AE%80%E4%BB%8B5%E5%88%86%E9%92%9F%E5%86%85%E5%BC%80%E5%A7%8B/</link>
      <pubDate>Sun, 24 Oct 2021 19:40:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-ETL-Apache-Airflow%E7%AE%80%E4%BB%8B5%E5%88%86%E9%92%9F%E5%86%85%E5%BC%80%E5%A7%8B/</guid>
      <description>如果你在大数据工作，你很可能听说过Apache Airflow。它于 2014 年在Airbnb启动开源项目，以帮助公司处理其批量数据管道。自那时起，它已成为数据工程中最受欢迎的开源工作流管理平台之一。 Apache Airflow是用 Python 书写的，它具有灵活性和稳健性。其强大且设备齐全的用户界面简化了工作流</description>
    </item>
    
    <item>
      <title>BI-数据仓-初学者数据仓库教程：学习基本概念</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E4%BB%93-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 24 Oct 2021 19:30:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E4%BB%93-%E5%88%9D%E5%AD%A6%E8%80%85%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>数据仓库教程摘要 数据仓库是软件工具的集合，帮助分析大量不同的数据。目标是从数据中获取有利可图的见解。本课程涵盖数据市场、数据湖、舍马斯等高级主题。 我应该知道些什么？ 教程专为几乎没有或根本没有数据仓库体验的初学者设计。虽然对数据库和SQL的基本理解是一个优势。 数据仓库课程教学大纲 介</description>
    </item>
    
    <item>
      <title>BI-数据湖-什么是数据湖 它是建筑-数据湖教程</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B9%96-%E5%AE%83%E6%98%AF%E5%BB%BA%E7%AD%91-%E6%95%B0%E6%8D%AE%E6%B9%96%E6%95%99%E7%A8%8B/</link>
      <pubDate>Sun, 24 Oct 2021 19:20:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E6%B9%96-%E5%AE%83%E6%98%AF%E5%BB%BA%E7%AD%91-%E6%95%B0%E6%8D%AE%E6%B9%96%E6%95%99%E7%A8%8B/</guid>
      <description>什么是数据湖？ 数据湖是一个存储库，可以存储大量的结构化、半结构化和非结构化数据。它是以本地格式存储每种类型数据的地方，对帐户大小或文件没有固定限制。它提供高数据量，以提高分析性能和本地集成。 数据湖就像一个大容器，非常类似于真正的湖泊和河流。就像在一个湖中，你有多个支流进来，一个数</description>
    </item>
    
    <item>
      <title>BI-数据湖-一文看懂数据湖：概念、特征、架构与案例</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%95%B0%E6%8D%AE%E6%B9%96%E6%A6%82%E5%BF%B5%E7%89%B9%E5%BE%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Sun, 24 Oct 2021 19:10:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-%E6%95%B0%E6%8D%AE%E6%B9%96-%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E6%95%B0%E6%8D%AE%E6%B9%96%E6%A6%82%E5%BF%B5%E7%89%B9%E5%BE%81%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A1%88%E4%BE%8B/</guid>
      <description>什么是数据湖； 数据湖的基本特征； 数据湖基本架构； 各厂商的数据湖解决方案； 典型的数据湖应用场景； 数据湖建设的基本过程； 总结。 一、什么是数据湖 数据湖是目前比较热的一个概念，许多企业都在构建或者计划构建自己的数据湖。但是在计划构建数据湖之前，搞清楚什么是数据湖，明确一个数据湖项目的基本</description>
    </item>
    
    <item>
      <title>BI-MongoDB-中台MongoDB应用</title>
      <link>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-MongoDB-%E4%B8%AD%E5%8F%B0MongoDB%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 24 Oct 2021 19:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%A4%A7%E6%95%B0%E6%8D%AE/BI-MongoDB-%E4%B8%AD%E5%8F%B0MongoDB%E5%BA%94%E7%94%A8/</guid>
      <description>目前数据仓库与大数据 不足 数据中台 以打通部门或数据孤岛的统一数据平台为基础，构建统一数据资产体系，并以API服务方式为全渠道业务 分析+应用，提供即时交付能力的企业级数据架构 金融行业 ](https://img202 技术需求 技术产品 关系型数据库 数据仓库 大数据 NOSQL与非结构数据 MongoDb存储的优势，多模数据库</description>
    </item>
    
    <item>
      <title>Metabase教程系列-设置电子邮件</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E8%AE%BE%E7%BD%AE%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</link>
      <pubDate>Sun, 24 Oct 2021 18:11:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E8%AE%BE%E7%BD%AE%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</guid>
      <description>一旦您将数据库连接到 Metabase，您就会想要配置一个电子邮件帐户，以便向组织的用户发送系统通知。Metabase 使用电子邮件重置密码，将新用户放到船上，并在发生某些事情时通知您。 配置您的电子邮件帐户 要使 Metabase 向组织用户发送消息，您需要设置一个电子邮件帐户，以便通过*SMTP（*简</description>
    </item>
    
    <item>
      <title>Metabase教程系列-获取有关问题的警报</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E8%8E%B7%E5%8F%96%E6%9C%89%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%AD%A6%E6%8A%A5/</link>
      <pubDate>Sun, 24 Oct 2021 18:10:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E8%8E%B7%E5%8F%96%E6%9C%89%E5%85%B3%E9%97%AE%E9%A2%98%E7%9A%84%E8%AD%A6%E6%8A%A5/</guid>
      <description>无论您是跟踪收入、用户还是负面评论，您经常会想提醒某些事情。Metabase 有几个不同类型的警报，您可以设置，您可以选择通过电子邮件或 Slack 收到通知。 获取警报 要开始使用警报，您团队中作为管理员的人员需要确保这一点电子邮件集成首先设置。 警报类型 在元基地中，您可以收到三种注意事项： 当时间</description>
    </item>
    
    <item>
      <title>Metabase教程系列-7 个您可能不知道的方便的元基础功能</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-7-%E4%B8%AA%E6%82%A8%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%96%B9%E4%BE%BF%E7%9A%84%E5%85%83%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Sun, 24 Oct 2021 13:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-7-%E4%B8%AA%E6%82%A8%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%96%B9%E4%BE%BF%E7%9A%84%E5%85%83%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD/</guid>
      <description>Metabase 的界面试图远离您的方式，以帮助将您的数据带到最前沿。这种悠闲的方法意味着有时功能可能需要时间来发现，因此我们整理了一些您可能尚未利用的功能列表。 1. 警报：当指标达到某个数字时，会收到通知 有些人错过了问题右下角的菜单（图1）： *图1。*单击问题右下角的铃来设置警报。 他们不点击铃声，</description>
    </item>
    
    <item>
      <title>Metabase教程系列-基本设置</title>
      <link>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Wed, 20 Oct 2021 18:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/bi/%E5%8F%AF%E8%A7%86%E5%8C%96/Metabase%E6%95%99%E7%A8%8B%E7%B3%BB%E5%88%97-%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE/</guid>
      <description>一、写在前面 概述：Metabase可以帮助你把数据库中的数据更好的呈现给更多人，数据分析人员通过建立一个”查询“（Metabase中定义为Question）来提炼数据，再通过仪表盘（Dashboards）来组合展示给公司成员 优点：1.开源免费 2.工具轻量、安装依赖的环境简单、配置</description>
    </item>
    
    <item>
      <title>重构实战 - 领域驱动设计战略建模在重构业务系统时的应用</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%87%8D%E6%9E%84%E5%AE%9E%E6%88%98-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5%E5%BB%BA%E6%A8%A1%E5%9C%A8%E9%87%8D%E6%9E%84%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Thu, 14 Oct 2021 15:50:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%87%8D%E6%9E%84%E5%AE%9E%E6%88%98-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%88%98%E7%95%A5%E5%BB%BA%E6%A8%A1%E5%9C%A8%E9%87%8D%E6%9E%84%E4%B8%9A%E5%8A%A1%E7%B3%BB%E7%BB%9F%E6%97%B6%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>转摘：https://www.pianshen.com/article/17311939527/ 领域驱动设计战略建模在重构业务系统时的应用 学习领域驱动设计相关的知识有一段时间了，但是一直苦恼于其中的一些概念无法理解透彻，导致无法落地实现甚至生根发芽。机缘巧合，不久前的工作内容中，</description>
    </item>
    
    <item>
      <title>阿里技术专家详解DDD系列 第五讲 - 聊聊如何避免写流水账代码</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 14 Oct 2021 15:49:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%94%E8%AE%B2-%E8%81%8A%E8%81%8A%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%99%E6%B5%81%E6%B0%B4%E8%B4%A6%E4%BB%A3%E7%A0%81/</guid>
      <description>转摘：https://zhuanlan.zhihu.com/p/366395817 在过去一年里我们团队做了大量的老系统重构和迁移，其中有大量的代码属于流水账代码，通常能看到是开发在对外的API接口里直接写业务逻辑代码，或者在一个服务里大量的堆接口，导致业务逻辑实际无法收敛，接口复</description>
    </item>
    
    <item>
      <title>什么是DDD领域驱动设计的战略设计</title>
      <link>https://geek.zshipu.com/post/DDDali/%E4%BB%80%E4%B9%88%E6%98%AFDDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 14 Oct 2021 15:48:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E4%BB%80%E4%B9%88%E6%98%AFDDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1/</guid>
      <description>转摘：https://www.jdon.com/52189 它也称为战略建模，它是DDD的支柱，其主要目标是与整个项目团队（领域专家和技术团队）一起定义有界上下文，统一的无所不在语言和上下文映射。 要清楚地了解战略项目是什么，您需要掌握我所谈到的每个概念。 有界上下文/界定上下文 有界上</description>
    </item>
    
    <item>
      <title>谈谈代码：DDD从入门到完全入门</title>
      <link>https://geek.zshipu.com/post/DDDali/%E8%B0%88%E8%B0%88%E4%BB%A3%E7%A0%81DDD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 14 Oct 2021 15:47:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E8%B0%88%E8%B0%88%E4%BB%A3%E7%A0%81DDD%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%8C%E5%85%A8%E5%85%A5%E9%97%A8/</guid>
      <description>转摘：https://www.jianshu.com/p/0f24360d47f3 1.什么是DDD 先看下万能的维基百科：Domain-driven design (DDD) is the concept that the structure and language of software code (class names, class methods, class variables) should match the business domain. For example, if a software processes loan applications, it might have classes such as LoanApplication and Customer, and methods such as AcceptOffer and Withdraw. 这边将其称为了一个概念。在我看来DDD</description>
    </item>
    
    <item>
      <title>谈谈代码：降低复杂度，从放弃三层架构到DDD入门</title>
      <link>https://geek.zshipu.com/post/DDDali/%E8%B0%88%E8%B0%88%E4%BB%A3%E7%A0%81%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%8E%E6%94%BE%E5%BC%83%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%88%B0DDD%E5%85%A5%E9%97%A8/</link>
      <pubDate>Thu, 14 Oct 2021 15:46:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E8%B0%88%E8%B0%88%E4%BB%A3%E7%A0%81%E9%99%8D%E4%BD%8E%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BB%8E%E6%94%BE%E5%BC%83%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%88%B0DDD%E5%85%A5%E9%97%A8/</guid>
      <description>转摘：https://www.jianshu.com/p/738d16723f81 1.前言 最近我发现团队某项目的复杂度越来越高（典型的三层架构），具体表现为： 代码可读性较差：各个服务之间调用复杂，流程不清晰 修改某服务业务代码导致大量无关服务的测试用例失败，单个功能开发者很难迅速定</description>
    </item>
    
    <item>
      <title>阿里技术专家详解DDD系列 第四讲 - 领域层设计规范</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E9%A2%86%E5%9F%9F%E5%B1%82%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Thu, 14 Oct 2021 15:45:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E9%A2%86%E5%9F%9F%E5%B1%82%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>转摘：https://zhuanlan.zhihu.com/p/356518017 在一个DDD架构设计中，领域层的设计合理性会直接影响整个架构的代码结构以及应用层、基础设施层的设计。但是领域层设计又是有挑战的任务，特别是在一个业务逻辑相对复杂应用中，每一个业务规则是应该放在Ent</description>
    </item>
    
    <item>
      <title>阿里技术专家详解DDD系列 第三讲 - Repository模式</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%89%E8%AE%B2-Repository%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 14 Oct 2021 15:44:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%89%E8%AE%B2-Repository%E6%A8%A1%E5%BC%8F/</guid>
      <description>转摘：https://zhuanlan.zhihu.com/p/348706530 在讲Repository之前其实应该先讲Entity（实体）、Aggregate Root（聚合根）、BoundedContext（限界上下文）等概念。但在实际写的过程中，发现单纯讲Entity相关的</description>
    </item>
    
    <item>
      <title>阿里技术专家详解DDD系列 第二讲 - 应用架构</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 14 Oct 2021 15:43:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84/</guid>
      <description>转摘：https://zhuanlan.zhihu.com/p/343388831 架构这个词源于英文里的“Architecture“，源头是土木工程里的“建筑”和“结构”，而架构里的”架“同时又包含了”架子“（scaffolding）的含义，意指能快速搭建起来的固定结构。而今天的</description>
    </item>
    
    <item>
      <title>阿里技术专家详解 DDD 系列 第一讲- Domain Primitive</title>
      <link>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E8%AE%B2-Domain-Primitive/</link>
      <pubDate>Thu, 14 Oct 2021 15:42:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDali/%E9%98%BF%E9%87%8C%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6%E8%AF%A6%E8%A7%A3DDD%E7%B3%BB%E5%88%97-%E7%AC%AC%E4%B8%80%E8%AE%B2-Domain-Primitive/</guid>
      <description>转摘：https://zhuanlan.zhihu.com/p/340911587 导读 对于一个架构师来说，在软件开发中如何降低系统复杂度是一个永恒的挑战，无论是 94 年 GoF 的 Design Patterns ， 99 年的 Martin Fowler 的 Refactoring ， 02 年的 P of EAA ，还是 03 年的 Enterprise Integration Patterns ，都是通过一系列的设计模式或范例来降低一些常见的复杂度。 但是</description>
    </item>
    
    <item>
      <title>交易中心实战-领域驱动设计系列5</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E4%BA%A4%E6%98%93%E4%B8%AD%E5%BF%83%E5%AE%9E%E6%88%98-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%975/</link>
      <pubDate>Mon, 11 Oct 2021 13:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E4%BA%A4%E6%98%93%E4%B8%AD%E5%BF%83%E5%AE%9E%E6%88%98-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%975/</guid>
      <description>一、DDD的基本概念和设计流程 1、DDD的概念 DDD: Domain Driven Design Eric Evans:《领域驱动设计：软件核心复杂性应对之道》里面一段话： ​ DDD先对业务领域进行分析，建立领域模型，根据领域模型驱动代码设计 2、使用DDD的原因和好处 最重要的一点是，DDD是类似于微服务中台落地的指导思想，这也是DD</description>
    </item>
    
    <item>
      <title>结合电商支付业务-领域驱动设计系列4</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E7%BB%93%E5%90%88%E7%94%B5%E5%95%86%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%974/</link>
      <pubDate>Sun, 10 Oct 2021 10:18:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E7%BB%93%E5%90%88%E7%94%B5%E5%95%86%E6%94%AF%E4%BB%98%E4%B8%9A%E5%8A%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%974/</guid>
      <description>2004 年，软件大师 Eric Evans 的不朽著作《领域驱动设计：软件核心复杂性应对之道》面世，从书名可以看出，这是一本应对软件系统越来越复杂的方法论的图书。然而，在当时，中国的软件业才刚刚起步，软件系统还没有那么复杂，即使维护了几年，软件退化了，不好维护了，推倒重新开发就好了。因此，在过去的那么多年</description>
    </item>
    
    <item>
      <title>六边形架构-领域驱动设计系列3</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%973/</link>
      <pubDate>Fri, 08 Oct 2021 20:17:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%973/</guid>
      <description>为什么叫六边形？ 六*边形建筑*的名称来自此建筑通常描述的方式： 我们将回到为什么六边形在本文的后面使用。这种模式还属于*端口和适配器*（这更好地解释了它背后的中心思想）和*洋葱结构*（因为它是如何分层的）。 在下面，我们将仔细看看&amp;rdquo;洋葱&amp;rdquo;。我们将从核心 （领域模</description>
    </item>
    
    <item>
      <title>战术领域驱动设计-领域驱动设计系列2</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E6%88%98%E6%9C%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%972/</link>
      <pubDate>Fri, 08 Oct 2021 20:16:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E6%88%98%E6%9C%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%972/</guid>
      <description>与战略领领域驱动设计相比，战术设计更加实际，更接近实际代码。战略设计涉及抽象整体，而战术设计则涉及类和模块。战术设计的目的是将领域模型细化到可以转换为工作代码的阶段。 设计是一个迭代的过程，因此将战略设计与战术设计相结合是有意义的。你从战略设计开始，然后是战术设计。最大的领领域模型</description>
    </item>
    
    <item>
      <title>战略领域驱动设计-领域驱动设计系列1</title>
      <link>https://geek.zshipu.com/post/DDDzl/%E6%88%98%E7%95%A5%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%971/</link>
      <pubDate>Fri, 08 Oct 2021 20:15:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDzl/%E6%88%98%E7%95%A5%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%B3%BB%E5%88%971/</guid>
      <description>​ 自*Eric Evans*于 2003 年出版关于该主题的书以来，*领域驱动设计*（DDD） 一直存在。几年前，当我加入一个存在数据一致性问题的项目时，我自己也接触到了 DDD。重复显示在数据库中，一些信息根本没有保存，可以随时随地遇到乐观的锁定错误。我们通过使用战术领域驱动设计的构建基块来解</description>
    </item>
    
    <item>
      <title>005 用户中心领域梳理</title>
      <link>https://geek.zshipu.com/post/DDDsz/005-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A2%86%E5%9F%9F%E6%A2%B3%E7%90%86/</link>
      <pubDate>Fri, 08 Oct 2021 20:14:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDsz/005-%E7%94%A8%E6%88%B7%E4%B8%AD%E5%BF%83%E9%A2%86%E5%9F%9F%E6%A2%B3%E7%90%86/</guid>
      <description>梳理 整体事件 流程 四色作色 领域划分 上下文及领域边界</description>
    </item>
    
    <item>
      <title>004 领域驱动设计落地</title>
      <link>https://geek.zshipu.com/post/DDDsz/004-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%90%BD%E5%9C%B0/</link>
      <pubDate>Fri, 08 Oct 2021 19:23:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDsz/004-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E8%90%BD%E5%9C%B0/</guid>
      <description>域建模是困难的。教学和学习域建模更加困难。因此，我的目标是帮助您学习这个巨大的主题，让您对领域驱动的意义有一个坚实的基本理解。概念概念和挖掘示例是本系列的意义。人们经常直接潜入开发带有代码的业务线应用程序 （LoB），但在实施可能导致灾难之前不知道 DDD 真正代表什么。从历史上看，单体建</description>
    </item>
    
    <item>
      <title>003 订单中心领域梳理</title>
      <link>https://geek.zshipu.com/post/DDDsz/003-%E8%AE%A2%E5%8D%95%E4%B8%AD%E5%BF%83%E9%A2%86%E5%9F%9F%E6%A2%B3%E7%90%86/</link>
      <pubDate>Wed, 06 Oct 2021 23:25:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDsz/003-%E8%AE%A2%E5%8D%95%E4%B8%AD%E5%BF%83%E9%A2%86%E5%9F%9F%E6%A2%B3%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>002 根据DDD进行重构系统</title>
      <link>https://geek.zshipu.com/post/DDDsz/002-%E6%A0%B9%E6%8D%AEDDD%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%9E%84%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 06 Oct 2021 23:24:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDsz/002-%E6%A0%B9%E6%8D%AEDDD%E8%BF%9B%E8%A1%8C%E9%87%8D%E6%9E%84%E7%B3%BB%E7%BB%9F/</guid>
      <description>进行模块划分 业务逻辑入手 handler层 部分业务逻辑下沉到微服务-沉淀为领域service handler层 部分业务逻辑整合到应用服务模块 Mapper Mapper 已使用tkmybatis Model model 新增自身逻辑（校验、等），划分到 领域model model 北向 ， 面向数据库 message 南向 ，面向业务层 领域发现 那领域模型是怎么一步一</description>
    </item>
    
    <item>
      <title>001 搭建工具提升DDD开发效率</title>
      <link>https://geek.zshipu.com/post/DDDsz/001-%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%8F%90%E5%8D%87DDD%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/</link>
      <pubDate>Wed, 06 Oct 2021 23:23:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDDsz/001-%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%8F%90%E5%8D%87DDD%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/</guid>
      <description>为什么启动DDD 传统开发模式 传统开发模式下，我们的应用架构往往以数据为中心。 在这种架构风格中，代码结构比较，开发人员拿到业务需求后，一般的开发流程就是：建表、按照业务流程写服务，服务操作数据库表数据，使其返回结果。这种模式最大的好处就是：学习门槛低、上手速度快，长久以来被大家所使</description>
    </item>
    
    <item>
      <title>DDD019-学习笔记</title>
      <link>https://geek.zshipu.com/post/DDD/DDD019-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 06 Oct 2021 23:22:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD019-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>DDD是什么 领域驱动设计(Domain Driven Design) 是一种从系统分析到软件建模的一套方法论。以领域为核心驱动力的设计体系。 为什么需要DDD 面向对象设计，数据行为绑定，告别贫血模型 优先考虑领域模型，而不是切割数据和行为 准确传达业务规则 代码即设计 DDD的一些概念 战略设计：限界上下文、上下文映射</description>
    </item>
    
    <item>
      <title>2021十大热门数据处理类职位</title>
      <link>https://geek.zshipu.com/post/machinelearning/2021%E5%8D%81%E5%A4%A7%E7%83%AD%E9%97%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B1%BB%E8%81%8C%E4%BD%8D/</link>
      <pubDate>Wed, 06 Oct 2021 21:15:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/machinelearning/2021%E5%8D%81%E5%A4%A7%E7%83%AD%E9%97%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B1%BB%E8%81%8C%E4%BD%8D/</guid>
      <description>**•**分析翻译：成为一名优秀的分析翻译需要技术知识和一定的业务理解。分析翻译可以根据业务目标充分确定机器学习计划的优先级。在担任这一职务时，应聘者必须与其他企业的人建立关系并管理相关项目。 **•**数据架构师：数据架构师负责阐明新的数据收集，确保准确的数据质量，消除数据冗余，</description>
    </item>
    
    <item>
      <title>使用 HTML &#43;CSS 的骨架屏幕加载动画</title>
      <link>https://geek.zshipu.com/post/css/%E4%BD%BF%E7%94%A8-HTML-&#43;CSS-%E7%9A%84%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B9%95%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Wed, 06 Oct 2021 19:48:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/css/%E4%BD%BF%E7%94%A8-HTML-&#43;CSS-%E7%9A%84%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%B9%95%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB/</guid>
      <description>预加载 使用 HTML 和 CSS 为骨架屏幕加载动画覆盖图像 在本文中，我展示了如何使用 HTML CSS 和 JavaScript 创建骷髅屏幕加载动画。我在个人资料卡上创建了此动画。 您将看到各种网站，在那里你可以看到骷髅加载动画之前加载任何元素。毫无疑问，它提高了网站的质量和美感很多。您需要有一个关于 HTML 和 CSS 的基本想法才能做到这一点。</description>
    </item>
    
    <item>
      <title>DDD.1 - 专业知识</title>
      <link>https://geek.zshipu.com/post/DDD/DDD.1-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Wed, 06 Oct 2021 10:41:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD.1-%E4%B8%93%E4%B8%9A%E7%9F%A5%E8%AF%86/</guid>
      <description>开发人员和领域专家协作，讨论域专家的知识，将其提炼成所有，而且仅与项目相关的知识。 目标是最终建立一个模型，说明应用程序应该做什么，应该怎么做，以及技术实施应该是什么。 知识的塑造不是一次性完成，就像瀑布方法一样。虽然在项目开始时确实应该更加密集，但它必须是一个持续和反复的过程，当开</description>
    </item>
    
    <item>
      <title>DDD018-领领域驱动设计基础概念</title>
      <link>https://geek.zshipu.com/post/DDD/DDD018-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 06 Oct 2021 09:41:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD018-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
      <description>领域驱动设计是程序员Eric Evans在 2004 年在他的著作《领域驱动设计：解决软件核心的复杂性》中引入的概念。 这是一种通过自上而下的方法查看软件来构建软件设计的方法。在详细讨论主题之前，让我们尝试集中一些光，并了解在此上下文中领域的含义。 ​ 什么是领域？ 软件开发中使用的&amp;rdquo;领</description>
    </item>
    
    <item>
      <title>DDD017-领域驱动设计它是什么何使用它</title>
      <link>https://geek.zshipu.com/post/DDD/DDD017-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%83%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83/</link>
      <pubDate>Wed, 06 Oct 2021 09:11:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD017-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%83%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83/</guid>
      <description>什么是领域？ 要定义，我们首先应该确定我们在此背景下（以及一般发展中）的含义。通用字典的定义是：&amp;rdquo;知识或活动领领域&amp;rdquo;。从这一点深入研究，在软件工程领领域通常是指应用程序打算应用的主题区领域。换句话说，在应用开发过程中，是&amp;rdquo;应用逻辑围绕的知识和活动</description>
    </item>
    
    <item>
      <title>DDD016-在开发软件中应用领域驱动设计</title>
      <link>https://geek.zshipu.com/post/DDD/DDD016-%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%BA%94%E7%94%A8%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 04 Oct 2021 14:11:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD016-%E5%9C%A8%E5%BC%80%E5%8F%91%E8%BD%AF%E4%BB%B6%E4%B8%AD%E5%BA%94%E7%94%A8%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>领域驱动设计 （DDD）是开发代码库结构与业务领域结构非常匹配的软件的概念。 有关 DDD 的更多信息，您可以在此处找到它 我花了很多时间来理解和应用它到日常任务， 所以这篇文章是我的分享所有我所知道的关于 Ddd 。 规则 该规则规定，外圈中声明的某些&amp;gt;内圈不得在代码中提及。 &amp;mdash;干净的建筑</description>
    </item>
    
    <item>
      <title>Java 开发 架构模式 清洁架构</title>
      <link>https://geek.zshipu.com/post/java/Java-%E5%BC%80%E5%8F%91-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E6%B8%85%E6%B4%81%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 02 Oct 2021 11:33:33 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/Java-%E5%BC%80%E5%8F%91-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E6%B8%85%E6%B4%81%E6%9E%B6%E6%9E%84/</guid>
      <description>虽然这些架构的细节都有些不同，但它们非常相似。它们都有相同的目标，即解耦。它们都通过将软件划分为层来实现这种分离。每个层至少有一层用于业务规则，另一层用于接口。 这些架构中的每一个都产生以下系统： 独立于框架。架构并不依赖于一些充满功能的软件库的存在。这允许您使用工具等框架，而不必将</description>
    </item>
    
    <item>
      <title>Java 开发 架构模式 从分层架构、洋葱架构到六边形架构</title>
      <link>https://geek.zshipu.com/post/java/Java-%E5%BC%80%E5%8F%91-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E5%88%B0%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 02 Oct 2021 11:22:22 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/Java-%E5%BC%80%E5%8F%91-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F-%E4%BB%8E%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E5%88%B0%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</guid>
      <description>经典分层 分层是打破复杂软件系统的最广为人知的技术之一。它已被推广到许多流行的书籍，如马丁·福勒*的企业应用架构模式*。 图层允许我们在不知道任何较低级别层的详细信息的情况下在较低级别层之上构建软件。在理想世界中，我们甚至可以用不同的实现替换低层。虽然层数可能有所不同，但我们在实践中</description>
    </item>
    
    <item>
      <title>吴恩达的 CS229的数学基础（线性代数）</title>
      <link>https://geek.zshipu.com/post/machinelearning/%E5%90%B4%E6%81%A9%E8%BE%BE%E7%9A%84-CS229%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Fri, 01 Oct 2021 13:39:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/machinelearning/%E5%90%B4%E6%81%A9%E8%BE%BE%E7%9A%84-CS229%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>机器学习数学基础-01概率统计基础课程</title>
      <link>https://geek.zshipu.com/post/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-01%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AF%BE/</link>
      <pubDate>Fri, 01 Oct 2021 13:39:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-01%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AF%BE/</guid>
      <description>概率基础 概率例子 质地均匀 ，每个面按照古典概率，概率都一样 已知条件，发生的概率 ： 条件概率 条件概率 生活中就不是古典概型 分子 分母 同时除总数 转换成概率公式 例子 AB的概率 ，也就是B的概率 概率相除得到条件概率 例子 贝叶斯公式 利用新的证据修改已有的看法 联合概率 同时除 AB同时发生的概率 链式法则 先x</description>
    </item>
    
    <item>
      <title>关键词库-Go 语言高效分词, 支持英文、中文、日文等</title>
      <link>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-Go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%95%88%E5%88%86%E8%AF%8D-%E6%94%AF%E6%8C%81%E8%8B%B1%E6%96%87%E4%B8%AD%E6%96%87%E6%97%A5%E6%96%87%E7%AD%89/</link>
      <pubDate>Mon, 27 Sep 2021 14:03:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-Go-%E8%AF%AD%E8%A8%80%E9%AB%98%E6%95%88%E5%88%86%E8%AF%8D-%E6%94%AF%E6%8C%81%E8%8B%B1%E6%96%87%E4%B8%AD%E6%96%87%E6%97%A5%E6%96%87%E7%AD%89/</guid>
      <description>Go 语言高效分词, 支持英文、中文、日文等 词典用双数组trie（Double-Array Trie）实现， 分词器算法为基于词频的最短路径加动态规划。 支持普通和搜索引擎两种分词模式，支持用户词典、词性标注，可运行JSON RPC服务。 分词速度单线程9MB/s，goroutines并发42M</description>
    </item>
    
    <item>
      <title>关键词库-本地sqllit存储</title>
      <link>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-%E6%9C%AC%E5%9C%B0sqllite%E5%AD%98%E5%82%A8/</link>
      <pubDate>Mon, 27 Sep 2021 13:03:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-%E6%9C%AC%E5%9C%B0sqllite%E5%AD%98%E5%82%A8/</guid>
      <description>本地存储 package db import ( &amp;quot;database/sql&amp;quot; &amp;quot;fmt&amp;quot; _ &amp;quot;github.com/mattn/go-sqlite3&amp;quot; &amp;quot;log&amp;quot; &amp;quot;os&amp;quot; ) var db *sql.DB var err error func init() { if isExist(&amp;quot;./keybase.db&amp;quot;) { db, err = sql.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;./keybase.db&amp;quot;) if err != nil { log.Fatal(err) } }else{ db, err = sql.Open(&amp;quot;sqlite3&amp;quot;, &amp;quot;./keybase.db&amp;quot;) if err != nil { log.Fatal(err) } sqlStmt := ` create table keywords (id integer PRIMARY KEY autoincrement,keyword text, url text); ` _, err = db.Exec(sqlStmt) if err != nil { log.Printf(&amp;quot;%q: %s\n&amp;quot;, err, sqlStmt) return } } } func isExist(path string)(bool){ _, err := os.Stat(path) if err != nil{ if os.IsExist(err){ return true } if os.IsNotExist(err){ return false } fmt.Println(err) return false } return true } func AddKeyword(keyword,url string) { tx, err := db.Begin() if err != nil { log.Fatal(err) } stmt, err := tx.Prepare(&amp;quot;insert into keywords(keyword, url) values(?, ?)&amp;quot;) if err != nil</description>
    </item>
    
    <item>
      <title>关键词库-Go中使用爬虫框架</title>
      <link>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-Go%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Sun, 26 Sep 2021 20:03:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/crawler/%E5%85%B3%E9%94%AE%E8%AF%8D%E5%BA%93-Go%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%88%AC%E8%99%AB%E6%A1%86%E6%9E%B6/</guid>
      <description>简介 本项目基于golang开发，是一个开放的垂直领域的爬虫框架，框架中将各个功能模块区分开，方便使用者重新实现子模块，进而构建自己垂直方方向的爬虫。 本项目将爬虫的各个功能流程区分成Spider模块（主控），Downloader模块（下载器），PageProcesser模块（页面分</description>
    </item>
    
    <item>
      <title>DDD015-实现领域驱动设计：第四部分</title>
      <link>https://geek.zshipu.com/post/DDD/DDD015-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</link>
      <pubDate>Sat, 25 Sep 2021 13:35:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD015-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/</guid>
      <description>对象映射对象 当两个对象具有相同或相似属性时，自动对象到对象映射是将值从一个对象复制到另一个对象的有用方法。 DTO 和实体类通常具有相同的/类似的属性，您通常需要从实体创建 DTO 对象。 ABP 的对象对象映射系统与自动映射器集成使这些操作比手动映射容易得多。 仅使用自动对象映射进行实体输出 DTO 映射。 不要</description>
    </item>
    
    <item>
      <title>DDD014-实现领域驱动设计：第三部分</title>
      <link>https://geek.zshipu.com/post/DDD/DDD014-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</link>
      <pubDate>Sat, 25 Sep 2021 12:27:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD014-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/</guid>
      <description>需要外部服务的实体中的业务逻辑 当业务逻辑仅使用该实体的属性时，只需在实体方法中实施业务规则就很简单。 如果业务逻辑要求查询数据库或使用应从依赖性注入系统解决的任何外部服务，该怎么办？ 记住：实体不能注入服务！ 实现这种商业逻辑有两种常见方法： 在实体方法上实现业务逻辑，并获取外部依赖作为</description>
    </item>
    
    <item>
      <title>DDD013-实现领域驱动设计：第二部分</title>
      <link>https://geek.zshipu.com/post/DDD/DDD013-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</link>
      <pubDate>Sat, 25 Sep 2021 11:27:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD013-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</guid>
      <description>实现：构建基块 这是本系列的重要组成部分。我们将用实例介绍和解释一些明确的规则。您可以遵循这些规则，并在实施域驱动设计时应用到您的解决方案中。 示例领域 示例将使用 GitHub 使用的一些概念，如问题、存储库、标签和用户，您已经熟悉。 下图显示了一些聚合、聚合根、实体、价值对象及其之间的关系： 问题聚</description>
    </item>
    
    <item>
      <title>DDD012-实现领域驱动设计：第一部分</title>
      <link>https://geek.zshipu.com/post/DDD/DDD012-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link>
      <pubDate>Fri, 24 Sep 2021 23:27:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD012-%E5%AE%9E%E7%8E%B0%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid>
      <description>简单代码！ 踢足球很简单，但踢简单的足球是最难的。- 约翰 · 克鲁伊夫 如果我们把这个著名的名言作为编程，我们可以说： 编写代码非常简单，但编写简单的代码是最 难的事情。 什么是域驱动设计？ 域驱动设计 （DDD） 是将实现与 不断发展的模型连接起来，满足复杂需求的软件开发方法; DDD 适用于复杂的领域和大</description>
    </item>
    
    <item>
      <title>DDD011-子域和边界上下文</title>
      <link>https://geek.zshipu.com/post/DDD/DDD011-%E5%AD%90%E5%9F%9F%E5%92%8C%E8%BE%B9%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</link>
      <pubDate>Fri, 24 Sep 2021 23:22:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD011-%E5%AD%90%E5%9F%9F%E5%92%8C%E8%BE%B9%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</guid>
      <description>这篇文章是一个摘要， 给自己一个关于子域和边界上下文的差异的说明。这些术语通常由域驱动设计从业者使用。曾经有段时间，我把它们混在一起一点点。希望你能发现这个有用。如果你发现任何不准确之处，请告诉我。我仍在改进我的 DDD 实践和知识。 子域 让我们从什么是亚多曼开始。子域位于问题空间中。一个大</description>
    </item>
    
    <item>
      <title>DDD010-领域驱动设计：实体、价值对象以及如何区分它们</title>
      <link>https://geek.zshipu.com/post/DDD/DDD010-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BD%93%E4%BB%B7%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%AE%83%E4%BB%AC/</link>
      <pubDate>Fri, 24 Sep 2021 23:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD010-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E4%BD%93%E4%BB%B7%E5%80%BC%E5%AF%B9%E8%B1%A1%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E5%AE%83%E4%BB%AC/</guid>
      <description>DDD 可分为战略和战术设计，其中战术设计是关于 DDD 的构建基块的。这篇文章将是关于DDD的基本构建基块：*实体和价值对象（VOs）。*实体和 VO 是 DDD 中表示模型的两个构建基块。它们是域驱动设计（服务和域事件除外）的起点。 除了只看实体和VO的定义，我还将为您提供一些如何区分它们的指导。 DDD 的构建</description>
    </item>
    
    <item>
      <title>DDD009-领域驱动设计 （DDD） 的介绍</title>
      <link>https://geek.zshipu.com/post/DDD/DDD009-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD-%E7%9A%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Fri, 24 Sep 2021 22:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD009-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD-%E7%9A%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>DDD 语境中什么是领域？ 知识、影响力或活动领域。用户应用程序的主题区域是软件的域。 我将向您提供 DDD 的概述。这篇文章是关于DDD 的 &amp;ldquo;为什么？我不会深入探讨这里的特定主题。不过，我会指出一些重要术语的定义，就像我刚才对&amp;rdquo;域&amp;rdquo;所做的那样。正如您将意识到共享</description>
    </item>
    
    <item>
      <title>DDD008-第 1 部分：领域驱动设计</title>
      <link>https://geek.zshipu.com/post/DDD/DDD008-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Fri, 24 Sep 2021 20:23:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD008-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>域建模是困难的。教学和学习域建模更加困难。因此，我的目标是帮助您学习这个巨大的主题，让您对领域驱动的意义有一个坚实的基本理解。概念概念和挖掘示例是本系列的意义。人们经常直接潜入开发带有代码的业务线应用程序 （LoB），但在实施可能导致灾难之前不知道 DDD 真正代表什么。从历史上看，单体建</description>
    </item>
    
    <item>
      <title>DDD007-领域动设计入门建模过程</title>
      <link>https://geek.zshipu.com/post/DDD/DDD007-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Fri, 24 Sep 2021 18:23:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD007-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%85%A5%E9%97%A8%E5%BB%BA%E6%A8%A1%E8%BF%87%E7%A8%8B/</guid>
      <description>此过程为您提供了一个分步学习指南，并实际应用了领域驱动设计 （DDD） 的各个方面 - 从围绕组织的业务模式定位到编码域模型。 使用此过程将引导您完成设计具有 DDD 思维的软件系统的每一个基本步骤，这样您就可以专注于业务挑战，而不是同时学习 DDD 而不知所措。 一旦您经历了流程的几次迭代，您将拥有基础 DDD</description>
    </item>
    
    <item>
      <title>DDD006-领域驱动架构图</title>
      <link>https://geek.zshipu.com/post/DDD/DDD006-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%9B%BE/</link>
      <pubDate>Thu, 23 Sep 2021 16:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD006-%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84%E5%9B%BE/</guid>
      <description>领域驱动设计是创建对问题空间的共同理解，通过对话、代码和图表无处不在地加强。DDD 的共享理解增强了协同效应和一致性，提高了可持续交付价值的能力 - 理想情况下，在产品的使用寿命内。正如一个系统的架构，通过图表表达，是一个有利可图的途径，以加强DD的共享模式。 以红色突出显示：其中架构图</description>
    </item>
    
    <item>
      <title>Typora&#43;PicGo自动上传图片到Github图床</title>
      <link>https://geek.zshipu.com/post/typora/Typora&#43;PicGo%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0Github%E5%9B%BE%E5%BA%8A/</link>
      <pubDate>Thu, 23 Sep 2021 15:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/typora/Typora&#43;PicGo%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%88%B0Github%E5%9B%BE%E5%BA%8A/</guid>
      <description>以前用Typora写东西，要插入图片url需要手动用PicGo将图片上传到图床，然后把链接粘贴到Typora中。之前重装系统以后也重装了Typora，虽然用PicGo上传图片的流程已经很简单了，但是今天打开发现插入图片可以直接调用PicGo上传到图床，立马就开始折腾了起来。 Typ</description>
    </item>
    
    <item>
      <title>DDD005-构建域驱动的微服务</title>
      <link>https://geek.zshipu.com/post/DDD/DDD005-%E6%9E%84%E5%BB%BA%E5%9F%9F%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Thu, 23 Sep 2021 11:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD005-%E6%9E%84%E5%BB%BA%E5%9F%9F%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>微服务 - 定义 微服务中的&amp;rdquo;微型&amp;rdquo;一词虽然表示服务的规模，但并不是使应用程序成为微服务的唯一标准。当团队转向基于微服务的架构时，他们的目标是提高其敏捷性 - 自主和频繁地部署功能。很难确定这种建筑风格的简明定义。我喜欢阿德里安·科克克罗夫特的这个简短定义——&amp;rd</description>
    </item>
    
    <item>
      <title>DDD004-域驱动设计初学者指南</title>
      <link>https://geek.zshipu.com/post/DDD/DDD004-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 23 Sep 2021 09:02:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD004-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%88%9D%E5%AD%A6%E8%80%85%E6%8C%87%E5%8D%97/</guid>
      <description>软件应用程序总是围绕构成公司业务的知识和活动领域发展。 域驱动设计是一种软件开发方法，通过将实现与不断发展的模型连接起来来解决复杂的问题：它提供了一套工具，旨在设计和实现具有高业务价值的代码。 需要注意的是，DDD 旨在解决复杂的问题，如果复杂性不足以证明其合理性，则可能过于过分。 DDD 提</description>
    </item>
    
    <item>
      <title>DDD003-域驱动设计：您一直想知道的一切，但不敢问</title>
      <link>https://geek.zshipu.com/post/DDD/DDD003-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%82%A8%E4%B8%80%E7%9B%B4%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87%E4%BD%86%E4%B8%8D%E6%95%A2%E9%97%AE/</link>
      <pubDate>Thu, 23 Sep 2021 08:59:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD003-%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%82%A8%E4%B8%80%E7%9B%B4%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E5%88%87%E4%BD%86%E4%B8%8D%E6%95%A2%E9%97%AE/</guid>
      <description>随着代码基数的增长，其复杂性必然会增加。由于这种情况，它往往变得更加难以保持代码的组织和结构，因为最初的意图，这被称为软件熵。在多次迭代中，如果不执行严格的架构准则，保持良好的关注分离以及正确脱钩类和模块将更具挑战性。 在传统的模型视图控制器 （MVC） 架构中，&amp;rdquo;M&amp;rd</description>
    </item>
    
    <item>
      <title>DDD002-什么是域驱动设计？</title>
      <link>https://geek.zshipu.com/post/DDD/DDD002-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 23 Sep 2021 08:46:32 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD002-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</guid>
      <description>随着代码基数的增长，其复杂性必然会增加。由于这种情况，它往往变得更加难以保持代码的组织和结构，因为最初的意图，这被称为软件熵。在多次迭代中，如果不执行严格的架构准则，保持良好的关注分离以及正确脱钩类和模块将更具挑战性。 在传统的模型视图控制器 （MVC） 架构中，”M”层将掌握所有业务</description>
    </item>
    
    <item>
      <title>DDD001-解释域驱动设计的概念</title>
      <link>https://geek.zshipu.com/post/DDD/DDD001-%E8%A7%A3%E9%87%8A%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 22 Sep 2021 19:20:04 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/DDD/DDD001-%E8%A7%A3%E9%87%8A%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A6%82%E5%BF%B5/</guid>
      <description>使用微服务意味着从松散耦合服务创建应用程序。该应用程序由几个小型服务组成，每个服务代表一个单独的业务目标。它们可以在复杂的应用中结合后单独开发和轻松维护。 微服务是一种架构设计模型，具有特定的边界上下文、配置和依赖性。这些结果来自域驱动设计和 DevOps 的架构原理。域驱动设计是通过代码解决组</description>
    </item>
    
    <item>
      <title>Golang通过http.NewRequest实现模拟请求，添加请求头</title>
      <link>https://geek.zshipu.com/post/go/Golang%E9%80%9A%E8%BF%87http.NewRequest%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B41/</link>
      <pubDate>Wed, 22 Sep 2021 16:45:45 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E9%80%9A%E8%BF%87http.NewRequest%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B41/</guid>
      <description>Golang 通过 http.NewRequest 实现模拟请求，添加请求头和请求参数： func DownloadString(remoteUrl string,queryValues url.Values) (body []byte,err error){ client := &amp;amp;http.Client{}; body = nil; uri,err := url.Parse(remoteUrl); if(err != nil){ return ; } if(queryValues != nil){ values := uri.Query(); if(values != nil){ for k,v := range values { queryValues[k] = v; } } uri.RawQuery = queryValues.Encode(); } reqest, err := http.NewRequest(&amp;quot;GET&amp;quot;,uri.String(),nil); reqest.Header.Add(&amp;quot;Accept&amp;quot;, &amp;quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&amp;quot;); reqest.Header.Add(&amp;quot;Accept-Encoding&amp;quot;, &amp;quot;gzip, deflate&amp;quot;); reqest.Header.Add(&amp;quot;Accept-Language&amp;quot;, &amp;quot;zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3&amp;quot;); reqest.Header.Add(&amp;quot;Connection&amp;quot;, &amp;quot;keep-alive&amp;quot;); reqest.Header.Add(&amp;quot;Host&amp;quot;, uri.Host); reqest.Header.Add(&amp;quot;Referer&amp;quot;, uri.String()); reqest.Header.Add(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0&amp;quot;); response, err := client.Do(reqest) defer response.Body.Close(); if(err != nil){ return ; } if response.StatusCode == 200 { switch response.Header.Get(&amp;quot;Content-Encoding&amp;quot;) { case &amp;quot;gzip&amp;quot;: reader, _ := gzip.NewReader(response.Body) for { buf := make([]byte, 1024) n, err := reader.Read(buf) if err != nil &amp;amp;&amp;amp; err != io.EOF { panic(err)</description>
    </item>
    
    <item>
      <title>Golang通过http.NewRequest实现模拟请求，添加请求头</title>
      <link>https://geek.zshipu.com/post/go/Golang%E9%80%9A%E8%BF%87http.NewRequest%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4/</link>
      <pubDate>Wed, 22 Sep 2021 16:42:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E9%80%9A%E8%BF%87http.NewRequest%E5%AE%9E%E7%8E%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%B7%BB%E5%8A%A0%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid>
      <description>Golang通过http.NewRequest实现模拟请求，添加请求头和请求参数 func DownloadString(remoteUrl string,queryValues url.Values) (body []byte,err error){ 2. client := &amp;amp;http.Client{}; 3. body = nil; 4. uri,err := url.Parse(remoteUrl); 5. if(err != nil){ 6. return ; 7. } 8. if(queryValues != nil){ 9. values := uri.Query(); 10. if(values != nil){ 11. for k,v := range values { 12. queryValues[k] = v; 13. } 14. } 15. uri.RawQuery = queryValues.Encode(); 16. } 17. reqest, err := http.NewRequest(&amp;quot;GET&amp;quot;,uri.String(),nil); 18. reqest.Header.Add(&amp;quot;Accept&amp;quot;, &amp;quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&amp;quot;); 19. reqest.Header.Add(&amp;quot;Accept-Encoding&amp;quot;, &amp;quot;gzip, deflate&amp;quot;); 20. reqest.Header.Add(&amp;quot;Accept-Language&amp;quot;, &amp;quot;zh-cn,zh;q=0.8,en-us;q=0.5,en;q=0.3&amp;quot;); 21. reqest.Header.Add(&amp;quot;Connection&amp;quot;, &amp;quot;keep-alive&amp;quot;); 22. reqest.Header.Add(&amp;quot;Host&amp;quot;, uri.Host); 23. reqest.Header.Add(&amp;quot;Referer&amp;quot;, uri.String()); 24. reqest.Header.Add(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0&amp;quot;); 26. response, err := client.Do(reqest)</description>
    </item>
    
    <item>
      <title>程序员文摘：第四期</title>
      <link>https://geek.zshipu.com/post/tlg/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%96%87%E6%91%98%E7%AC%AC%E5%9B%9B%E6%9C%9F/</link>
      <pubDate>Wed, 22 Sep 2021 15:03:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/%E7%A8%8B%E5%BA%8F%E5%91%98%E6%96%87%E6%91%98%E7%AC%AC%E5%9B%9B%E6%9C%9F/</guid>
      <description>1 - A categorized list of all Java and JVM features since JDK 8 to 17 (https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-17/)：从 Java 8 到 Java 17 一共 194 个 JEP（JDK Enhancement Proposals (http://openj</description>
    </item>
    
    <item>
      <title>2021 真香 7 Javascript 库</title>
      <link>https://geek.zshipu.com/post/javascript/2021-%E7%9C%9F%E9%A6%99-7-Javascript-%E5%BA%93/</link>
      <pubDate>Wed, 10 Mar 2021 14:55:14 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/javascript/2021-%E7%9C%9F%E9%A6%99-7-Javascript-%E5%BA%93/</guid>
      <description>这里有7个真棒JavaScript库来看看。 [](#fullpagejs)fullpagejs.js 此开源库可帮助您创建在上面 GIF 中看到的全屏幕滚动网站。 链接 [](#animejs)animejs.js 动画库之一，动漫.js是灵活和易于使用。它是完美的工具，帮助您添加一些很酷的动画到您的项目。 链接 [](#screenfulljs)screenfulljs.js 如果您还希望有一个全屏功能，我建议使用此库，而不是全屏API，因为它的跨浏览器</description>
    </item>
    
    <item>
      <title>样式中的 Web 组件</title>
      <link>https://geek.zshipu.com/post/web/%E6%A0%B7%E5%BC%8F%E4%B8%AD%E7%9A%84-Web-%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Wed, 10 Mar 2021 11:53:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/%E6%A0%B7%E5%BC%8F%E4%B8%AD%E7%9A%84-Web-%E7%BB%84%E4%BB%B6/</guid>
      <description>Web 组件非常易于样式。您可以以接近零的成本在它们之间共享样式，并且它们仍然可以从外部进行样式设计。它们易于设置和逐步增强。有一大堆使用 Web 组件的框架，如果你进入其中，你自然会知道这一切。但它真的很难理解来自React，Vue，角度等。因此，让我们来谈谈它。 [](#baseline)基</description>
    </item>
    
    <item>
      <title>Python 程序以查找两个列表的交集</title>
      <link>https://geek.zshipu.com/post/python/Python-%E7%A8%8B%E5%BA%8F%E4%BB%A5%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/</link>
      <pubDate>Mon, 08 Mar 2021 10:34:46 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python-%E7%A8%8B%E5%BA%8F%E4%BB%A5%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E9%9B%86/</guid>
      <description>交叉操作意味着，我们必须从列表 1 和列表 2 中接收所有常见元素，并将所有元素存储在另一个第三个列表中。 List1::[1,2,3] List2::[2,3,6] List3::[2,3] 算法 Step 1: input lists. Step 2: first traverse all the elements in the first list and check with the elements in the second list. Step 3: if the elements are matched then store in third list. 示例代码 #Intersection of two lists def intertwolist(A, B): C = [i for i in A if i in B] return C # Driver Code A=list() B=list() n=int(input(&amp;quot;Enter the size of the List ::&amp;quot;)) print(&amp;quot;Enter the Element of first list::&amp;quot;) for i in range(int(n)): k=int(input(&amp;quot;&amp;quot;)) A.append(k) print(&amp;quot;Enter the</description>
    </item>
    
    <item>
      <title>使用Java找到两个链接列表的交叉点</title>
      <link>https://geek.zshipu.com/post/java/%E4%BD%BF%E7%94%A8Java%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E5%8F%89%E7%82%B9/</link>
      <pubDate>Mon, 08 Mar 2021 10:24:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/%E4%BD%BF%E7%94%A8Java%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%A4%E5%8F%89%E7%82%B9/</guid>
      <description>链接列表是一个线性数据结构，其中每个Node有两个块，这样一个块包含Node的值或数据，而另一个块包含下一个字段的地址。 让我们假设我们有一个链接列表，以便每个Node都包含指向列表中其他Node的随机指点。任务是找到两个链接列表相互交集的Node。如果他们不相交，然后返回空或空作</description>
    </item>
    
    <item>
      <title>UX 设计：如何开始（完整指南）</title>
      <link>https://geek.zshipu.com/post/ux/UX-%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</link>
      <pubDate>Fri, 05 Mar 2021 22:14:35 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/ux/UX-%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E5%AE%8C%E6%95%B4%E6%8C%87%E5%8D%97/</guid>
      <description>您是否希望在UX设计中开始，但不知道从哪里开始？这 6 个步骤将帮助您从一个完整的初学者到训练有素的 UX 设计师 （有工作！切通过所有的噪音在线和开始与此视频！在这段视频中，我们的 UX 设计师之一 Amr 分享了分步指南和时间表，包括要参加的关键在线课程、掌握的工具、要加入的社区、我们学到的教训以及您</description>
    </item>
    
    <item>
      <title>Vim 2021： 在 Vim 中添加上下文菜单</title>
      <link>https://geek.zshipu.com/post/linux/Vim-2021-%E5%9C%A8-Vim-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/</link>
      <pubDate>Fri, 05 Mar 2021 09:00:58 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/linux/Vim-2021-%E5%9C%A8-Vim-%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95/</guid>
      <description>当您与光标下的当前单词/行有关时，漂亮的上下文菜单非常有用。它还可以提醒你，当你忘记你的键盘图： [](#setup)设置 在ui扩展插件quickui的帮助下，它可以简单地定义为： Plug &amp;lsquo;skywind3000/vim-quickui&amp;rsquo; &amp;rdquo; define your context menu as a list of (text, command) pairs let g:context_menu_k = [ \ [&amp;rdquo;&amp;amp;Help Keyword\t\ch&amp;rdquo;, &amp;lsquo;echo expand(&amp;rdquo;&amp;rdquo;)&amp;rsquo; ], \ [&amp;rdquo;&amp;amp;Signature\t\cs&amp;rdquo;, &amp;lsquo;echo 101&amp;rsquo;], \ [&amp;lsquo;-&amp;rsquo;], \ [&amp;ldquo;Find in &amp;amp;File\t\cx&amp;rdquo;, &amp;lsquo;exec &amp;ldquo;/&amp;rdquo; . expand(&amp;rdquo;&amp;rdquo;)&amp;rsquo; ], \ [&amp;ldquo;Find in &amp;amp;Project\t\cp&amp;rdquo;, &amp;lsquo;exec &amp;ldquo;vimgrep &amp;rdquo; . expand(&amp;rdquo;&amp;rdquo;) . &amp;ldquo;*&amp;ldquo;&amp;rsquo; ],</description>
    </item>
    
    <item>
      <title>SSH - 配置</title>
      <link>https://geek.zshipu.com/post/linux/SSH-%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Thu, 04 Mar 2021 20:30:08 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/linux/SSH-%E9%85%8D%E7%BD%AE/</guid>
      <description>[](#ssh-commands)SSH命令 生成 ssh-key 运行终端 中的命令，然后重命名您的密钥或键输入，以继续使用通用给定名称，该名称id_rsa用于私钥，id_rsa.pub 用于公共密钥 ssh-keygen -t rsa Enter fullscreen mode Exit fullscreen mode 添加标识 ssh-add /home/user/.ssh/id_rsa Enter fullscreen mode Exit fullscreen mode [](#add-the-identity-to-githu</description>
    </item>
    
    <item>
      <title>10 分钟内学到的东西，这将对您的编程生涯的其余部分有用</title>
      <link>https://geek.zshipu.com/post/news/10-%E5%88%86%E9%92%9F%E5%86%85%E5%AD%A6%E5%88%B0%E7%9A%84%E4%B8%9C%E8%A5%BF%E8%BF%99%E5%B0%86%E5%AF%B9%E6%82%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E7%94%9F%E6%B6%AF%E7%9A%84%E5%85%B6%E4%BD%99%E9%83%A8%E5%88%86%E6%9C%89%E7%94%A8/</link>
      <pubDate>Fri, 26 Feb 2021 18:18:12 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/10-%E5%88%86%E9%92%9F%E5%86%85%E5%AD%A6%E5%88%B0%E7%9A%84%E4%B8%9C%E8%A5%BF%E8%BF%99%E5%B0%86%E5%AF%B9%E6%82%A8%E7%9A%84%E7%BC%96%E7%A8%8B%E7%94%9F%E6%B6%AF%E7%9A%84%E5%85%B6%E4%BD%99%E9%83%A8%E5%88%86%E6%9C%89%E7%94%A8/</guid>
      <description>有一个非常简单的技巧，你可以在短短几分钟内学习，这将是有用的，你的未来作为一个程序员。有一个关键的原因，为什么这一个小把戏是如此重要，是重要的理解 [](#the-10-tab-rule)10 选项卡规则 在编程中，您将遇到问题、错误消息以及程序没有执行您认为应该做的事情的情况。你对这些场景的React将是一个不错的程序员和一</description>
    </item>
    
    <item>
      <title>JUnit 4和5注释每个开发人员应该知道</title>
      <link>https://geek.zshipu.com/post/java/JUnit-4%E5%92%8C5%E6%B3%A8%E9%87%8A%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</link>
      <pubDate>Thu, 25 Feb 2021 20:32:12 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/JUnit-4%E5%92%8C5%E6%B3%A8%E9%87%8A%E6%AF%8F%E4%B8%AA%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</guid>
      <description>[](#a-summary-of-junit-4-amp-5-annotations-with%C2%A0examples)JUnit 4 +5 注释摘要，附有示例 在写这篇文章之前，我只知道一些常用的JUnit 4注释，如 @RunWith @Test @Before @After @BeforeClass @AfterClass 你不得不评论多少次测试？令我吃惊的是，有注释可以做到这一点。 @Ignore(&amp;quot;Reason for ignoring&amp;quot;) @Disabled(&amp;quot;Reason for disabling&amp;quot;) 嗯，事实证明，还有其他一些注释，特别是在JUnit 5，可以帮助编写更好和更有效的测试。 [](#what-to%C2%</description>
    </item>
    
    <item>
      <title>为什么你应该先学习 JavaScript 原理 （不是最热门的框架）</title>
      <link>https://geek.zshipu.com/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%85%88%E5%AD%A6%E4%B9%A0-JavaScript-%E5%8E%9F%E7%90%86-%E4%B8%8D%E6%98%AF%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 25 Feb 2021 20:24:15 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%85%88%E5%AD%A6%E4%B9%A0-JavaScript-%E5%8E%9F%E7%90%86-%E4%B8%8D%E6%98%AF%E6%9C%80%E7%83%AD%E9%97%A8%E7%9A%84%E6%A1%86%E6%9E%B6/</guid>
      <description>[](#no-winners-in-the-crazy-frameworks-race)疯狂框架竞赛中无优胜者 在过去的五年里，我一直在疯狂地追逐JavaScript图书馆和框架之间最热门的比赛。也许在某个时候，我们都问自己，我们应该学习哪个Javascript框架，评估利弊，为什</description>
    </item>
    
    <item>
      <title>网络浏览器引擎概述 ： 初学者</title>
      <link>https://geek.zshipu.com/post/web/%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0-%E5%88%9D%E5%AD%A6%E8%80%85/</link>
      <pubDate>Thu, 25 Feb 2021 20:14:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/web/%E7%BD%91%E7%BB%9C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0-%E5%88%9D%E5%AD%A6%E8%80%85/</guid>
      <description>作为一个人，当你在纸上写一个文档，或者让我们说打印一份报纸时，你会看到标题和它下面故事的某些部分，以及指向另一页上剩余故事的链接。一些头条新闻下面会有完整的故事。您会看到段落中断到一条新线，它们之间有空间。您可以在页面的不同位置看到不同的颜色、图像。您会看到不同的图像大小、不同的</description>
    </item>
    
    <item>
      <title>framework not found</title>
      <link>https://geek.zshipu.com/post/iOS/framework-bot-found/</link>
      <pubDate>Mon, 22 Feb 2021 16:04:55 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/framework-bot-found/</guid>
      <description>问题：在build的时候framework not found 解决： 添加需要的framework 确定framework齐全的情况下，就是系统添加了冗余的framework编译需求，找到require列表删除即可 project.xcodeproj文件---&amp;gt;显示包内容---&amp;gt;proje</description>
    </item>
    
    <item>
      <title>融云iOS无法接受语音视频消息</title>
      <link>https://geek.zshipu.com/post/flutter/rongcloud-cannot-receive-message-ios/</link>
      <pubDate>Wed, 27 Jan 2021 09:03:11 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/rongcloud-cannot-receive-message-ios/</guid>
      <description>安卓（李某测试）拨打 苹果（李朴2），进入对话界面， 弹出键盘，弹出报错,在chat_room.dart文件中 [VERBOSE-2:ui_dart_state.cc(177)] Unhandled Exception: &#39;package:flutter/src/widgets/scroll_controller.dart&#39;: Failed assertion: line 112 pos 12: &#39;_positions.isNotEmpty&#39;: ScrollController not attached to any scroll views. #0 _AssertionError._doThrowNew (dart:core-patch/errors_patch.dart:46:39) #1 _AssertionError._throwNew (dart:core-patch/errors_patch.dart:36:5) #2 ScrollController.position (package:flutter/src/widgets/scroll_controller.dart:112:12) #3 _ChatRoomState.didChangeMetrics (package:polars_app/pages/chat/chat_room.dart:708:27) #4 WidgetsBinding.handleMetricsChanged (package:flutter/src/widgets/binding.dart:571:16) #5 _rootRun (dart:async/zone.dart:1190:13) #6 _CustomZone.run (dart:async/zone.dart:1093:19) #7 _CustomZone.runGuarded (dart:async/zone.dart:997:7) #8 _invoke (dart:ui/hooks.dart:251:10) #9 _updateWindowMetrics (dart:ui/hooks.dart:53:3) 解决：在访问maxScrollExtent属性前一定要判断_scrollCon</description>
    </item>
    
    <item>
      <title>完整的入门vue指南</title>
      <link>https://geek.zshipu.com/post/vue/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A5%E9%97%A8vue%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 25 Jan 2021 22:39:08 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/vue/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A5%E9%97%A8vue%E6%8C%87%E5%8D%97/</guid>
      <description>Vue.js是一个前端框架，针对渐进式集成进行了优化。这意味着您可以拥有一个只集成了几个 Vue 组件的大型应用程序，或者您可以从头开始，在 Vue 生态系统中完全工作。 另一个让 Vue 与众不同的是与很多框架相比，学习曲线较低。如果您了解 HTML、CSS 和 JavaScript，那么您就已经非常接近了，</description>
    </item>
    
    <item>
      <title>完整的入门React指南</title>
      <link>https://geek.zshipu.com/post/react/save01/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A5%E9%97%A8React%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 25 Jan 2021 22:35:34 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A5%E9%97%A8React%E6%8C%87%E5%8D%97/</guid>
      <description>什么是React React 是 Facebook 开发团队在 2013 年构建的 JavaScript 库，用于使用户界面更加模块化（或可重用）且更易于维护。根据 React 的网站，它用于&amp;rdquo;构建管理自身状态的封装组件，然后组合它们以生成复杂的 UIs&amp;rdquo;。 我要在这篇文章中使用很多 Facebook 的例子， 因为他们写 React 摆在首位。 还记得 Facebook 从喜欢转向</description>
    </item>
    
    <item>
      <title>学习React之前，JavaScript 基础知识</title>
      <link>https://geek.zshipu.com/post/react/save01/%E5%AD%A6%E4%B9%A0React%E4%B9%8B%E5%89%8DJavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 25 Jan 2021 22:11:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/%E5%AD%A6%E4%B9%A0React%E4%B9%8B%E5%89%8DJavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>在深入了解 React 之前了解有关 JavaScript 和 Web 开发的所有信息。不幸的是， 我们生活在一个不完美的世界里， 所以在 React 之前对所有 JavaScript 进行大做笑只会让你流血。如果您已经拥有了一些 JavaScript 的经验，那么在 React 之前，您需要学习的只是用于开发 React 应用程序的 JavaScript 功能。关于JavaScript，在学习React之前，你应该对它感到</description>
    </item>
    
    <item>
      <title>React设计模式（第 2 部分）</title>
      <link>https://geek.zshipu.com/post/react/save01/React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC-2-%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 25 Jan 2021 22:04:18 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC-2-%E9%83%A8%E5%88%86/</guid>
      <description>这一次，我们将讨论模式、模式和模式。ContextPresentational and Container ComponentsCompound Components [](#context)上下文 根据React文档： 上下文提供了一种通过组件树传递数据的方法，而无需在每个级别手动传递道具。 简单地说，如果您有一个需要通过多个组件级别的全局状态，可以使用 。例如：如</description>
    </item>
    
    <item>
      <title>React设计模式（第 1 部分）</title>
      <link>https://geek.zshipu.com/post/react/save01/React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC-1-%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 25 Jan 2021 22:00:25 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/react/save01/React%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%AC-1-%E9%83%A8%E5%88%86/</guid>
      <description>注：有些模式侧重于状态管理概念，但我们可以避免和其他第三方状态管理工具，因为它们与本文的主题无关。Redux,Mobx [](#render-props)渲染道具 响应文档比比皆是： 术语&amp;rdquo;呈现道具&amp;rdquo;是指使用其值为函数的 prop 在 React 组件之间共享代码的技术。 简单地说，它</description>
    </item>
    
    <item>
      <title>ssh避免重复输入密码</title>
      <link>https://geek.zshipu.com/post/unix/rsa-add/</link>
      <pubDate>Wed, 20 Jan 2021 11:52:44 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/rsa-add/</guid>
      <description>解决方法：添加私钥 步骤： 切换到文件夹 cd ~/.ssh 添加秘钥 ssh-add id_rsa 查看秘钥 ssh-add -l 测试github仓库连接 git ls-remote -h -- git@github.com:zhangjk4859/jenkins-build-iOS.git 完。 参考：https://superuser.com/questions/988185/how-to-avoid-being-asked-enter-passphrase-for-k</description>
    </item>
    
    <item>
      <title>jenkins安装</title>
      <link>https://geek.zshipu.com/post/unix/jenkins-installation/</link>
      <pubDate>Wed, 20 Jan 2021 10:33:31 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/jenkins-installation/</guid>
      <description>安装 brew install jenkins-lts 启动 brew services start jenkins-lts 停止 brew services stop jenkins-lts 重启 brew services restart jenkins-lts 更新 brew upgrade jenkins-lts 局域网访问配置 homebrew.mxcl.jenkins.plist里面httpListenAddress从127.0.0.1更改为0.0.0.0 两个地方 ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist /usr/local/Cellar/jenkins/版本号/home</description>
    </item>
    
    <item>
      <title>2021 年跨平台应用框架将选什么</title>
      <link>https://geek.zshipu.com/post/framework/2021-%E5%B9%B4%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B0%86%E9%80%89%E4%BB%80%E4%B9%88/</link>
      <pubDate>Sun, 10 Jan 2021 10:50:25 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/framework/2021-%E5%B9%B4%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B0%86%E9%80%89%E4%BB%80%E4%B9%88/</guid>
      <description>在当今具有高度颠覆性且达尔文式移动应用开发世界中，企业不会冒险错过在两个平台上的存在：谷歌Play商店或苹果应用商店。 但是，如果企业使用本机应用，预算通常是个问题。这就是为什么跨平台应用程序开发已成为无与伦比的企业选择，旨在出现在Android以及iOS。 在继续了解 2021 年这一类框架</description>
    </item>
    
    <item>
      <title>libstdc&#43;&#43;缺失问题</title>
      <link>https://geek.zshipu.com/post/iOS/libstdc/</link>
      <pubDate>Thu, 07 Jan 2021 16:04:55 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/libstdc/</guid>
      <description>问题：libstdc++ not found 原因：libstdc++ was deprecated 5 years ago,we should update project to use libc++ 解决：更新工程或者下载库到当前工程，下载地址 https://github.com/zhangjk4859/zhangjk4859.github.io/raw/zjk/files/libstdc--master.zip 下载完成以后执行对应.sh文件即可 参考：1.https://github.com/devdawei/libstdc- 2.https://www.jianshu.com/p/e694782b8740</description>
    </item>
    
    <item>
      <title>Xcode12,iOS14，app启动慢</title>
      <link>https://geek.zshipu.com/post/iOS/slow-app-launch-time-after-updating-to-ios-14-and-xcode-12/</link>
      <pubDate>Thu, 07 Jan 2021 12:38:38 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/slow-app-launch-time-after-updating-to-ios-14-and-xcode-12/</guid>
      <description>问题：启动app会白屏很长一段时间，即使是一个全新的app 解决方案： In the Xcode menu,go to product &amp;gt; scheme &amp;gt; edit scheme open the info tab Uncheck the debug executables checkbox 参考：1. https://stackoverflow.com/questions/63929122/slow-app-launch-time-after-updating-to-ios-14-and-xcode-12 2.https://developer.apple.com/forums/thread/651012</description>
    </item>
    
    <item>
      <title>Mac环境下朗文词典</title>
      <link>https://geek.zshipu.com/post/unix/mac-dictionary/</link>
      <pubDate>Thu, 07 Jan 2021 11:55:31 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/mac-dictionary/</guid>
      <description>原理：原生的dictionary加朗文的词库，词库需要转换，转换过程见参考链接2 参考：1. https://www.zhihu.com/question/21964466 https://kaihao.io/2018/mdict-to-macos-dictionary/ 3.https://www.zhihu.com/question/20428599/answer/223511099</description>
    </item>
    
    <item>
      <title>链表是什么</title>
      <link>https://geek.zshipu.com/post/iOS/what-is-link-list/</link>
      <pubDate>Wed, 06 Jan 2021 00:23:22 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/what-is-link-list/</guid>
      <description>链表了解吗 Linked list is a sequence of links which contains items Link - Each link of a linked list can store a data called an element Next - Each link of a linked list contains a link to the next link called Next LinkedList - A Linked List contains the connection link to the first link called First Linked list can be visualized as a chain of nodes,where every node points to hte next node ![image]( Simple linked list -item navigation is forward only doubly linked list - items can be navigated forward and backward circular linked list - last item contains link of the first element as next and the first element has a link to the last element as previous. 双向链表是什么 同上，节点有前</description>
    </item>
    
    <item>
      <title>hexo给目录分类</title>
      <link>https://geek.zshipu.com/post/unix/hexo-categories/</link>
      <pubDate>Tue, 05 Jan 2021 13:55:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/hexo-categories/</guid>
      <description>创建分类功能 hexo new page categories 打开index文件 /source/categories/index.md 文件添加字段 title: categories date: 2021-01-05 12:19:59 type: &amp;quot;categories&amp;quot; 写文章的时候加上分类标签 title: mac android studio flutter 打包 apk date: 2020-11-16 20:16:07 categories: - unix tags: 添加标签同理 完。 参考：https://www.cnblogs.com/hankleo/p/11606224.html</description>
    </item>
    
    <item>
      <title>flutter中的websocket概念</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-websocket/</link>
      <pubDate>Tue, 05 Jan 2021 11:44:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-websocket/</guid>
      <description>目的：实现客户端与服务端的实时通讯，基于TCP协议 与keep-alive区别：keep-alive机制会连接一小段时间，最终会断开，ws协议不会断开 原理：通过一条特殊的http协议请求进行握手后，服务端支持ws协议，则进行协议升级，利用http创建的tcp连接，实现长连接。 步骤分</description>
    </item>
    
    <item>
      <title>《flutter实战》电子书</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-book/</link>
      <pubDate>Tue, 05 Jan 2021 11:15:43 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-book/</guid>
      <description>国内第一本开源的电子书，也有实体书，特此记录 在线编辑步骤 npm i -g gitbook-cli gitbook install #安装本书构建所要依赖的插件 gitbook serve 来源：https://github.com/flutterchina/flutter-in-action</description>
    </item>
    
    <item>
      <title>flutter网络三方库Flutter-Net</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-dio-net/</link>
      <pubDate>Tue, 05 Jan 2021 10:54:40 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-dio-net/</guid>
      <description>在给app的网络请求添加loading过程中，发现一个封装更加完善的网络三方库，里面有很多值得借鉴的细节，特此记录 优点： 默认自带loading，如果单个请求不想要loading，可以传递参不显示，自己封装的目前全部显示loading 更加友好的控制台json打印 封装了公共参数 响应拦</description>
    </item>
    
    <item>
      <title>flutter中一个好用的三方库loading</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-loading/</link>
      <pubDate>Tue, 05 Jan 2021 10:47:15 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-loading/</guid>
      <description>地址：https://github.com/kokohuang/flutter_easyloading 用法，添加到materialApp的builder属性中 class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: &#39;Flutter EasyLoading&#39;, theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: &#39;Flutter EasyLoading&#39;), builder: EasyLoading.init(), ); } } 接下来在任何地方调用 EasyLoading.show(status: &#39;loading...&#39;); EasyLoading.showProgress(0.3, status: &#39;downloading...&#39;); EasyLoading.showSuccess(&#39;Great Success!&#39;); EasyLoading.showError(&#39;Failed with Error&#39;); EasyLoading.showInfo(&#39;Useful Information.&#39;); EasyLoading.showToast(&#39;Toast&#39;);</description>
    </item>
    
    <item>
      <title>flutter padding组件</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-padding/</link>
      <pubDate>Tue, 05 Jan 2021 10:43:56 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-padding/</guid>
      <description>如果一个组件没有调整内边距的属性，那么可以在它的外层加一层Padding，达到调整位置的效果，效果等同于放到Container里，比Container更轻量级 Padding( padding: EdgeInsets.all(10), child: Text(&#39;这是一段测试文字&#39;), )</description>
    </item>
    
    <item>
      <title>flutter ListTitle组件</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-list-title/</link>
      <pubDate>Tue, 05 Jan 2021 10:34:14 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-list-title/</guid>
      <description>该组件可以用在container和card组件里，默认有大标题和小标题属性，无需再进行text上下排列组合 Card( margin: EdgeInsets.all(10), child: Column( children: &amp;lt;Widget&amp;gt;[ ListTile( title: Text(&amp;quot;张三&amp;quot;,style: TextStyle(fontSize: 28)), subtitle: Text(&amp;quot;董事长&amp;quot;), ), Divider(), ListTile( title: Text(&amp;quot;电话:123456789</description>
    </item>
    
    <item>
      <title>flutter card组件</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-card-widget/</link>
      <pubDate>Tue, 05 Jan 2021 10:27:30 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-card-widget/</guid>
      <description>在开发过程中，Container组件使用多了，会有一些重复的代码，比如矩形边框和圆角，需要额外加decoration,使用card已经默认加上了边框和阴影 Card( margin: EdgeInsets.all(10), child: ... )</description>
    </item>
    
    <item>
      <title>flutter中radio单选使用</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-radio/</link>
      <pubDate>Tue, 05 Jan 2021 10:10:26 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-radio/</guid>
      <description>在一个数组容器里放置两个及其以上radio，当radio的group value和自己value相等时，便是选中状态 int groupValue = 1; _onChange(value){ if(mounted) setState(() { groupValue = value; }); } Row( mainAxisAlignment: MainAxisAlignment.center, children: &amp;lt;Widget&amp;gt;[ Radio( value: 1, groupValue: groupValue, onChanged: (T) =&amp;gt; _onChange(T), ), Radio( value: 2, groupValue: groupValue, onChanged: (T) =&amp;gt; _onChange(T), ), Radio( value: 3, groupValue: groupValue, onChanged: (T) =&amp;gt; _onChange(T), ), ], ) 参考：https://blog.csdn.net/zhangwes</description>
    </item>
    
    <item>
      <title>flutter个别圆角切割</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-only-border/</link>
      <pubDate>Tue, 05 Jan 2021 10:06:41 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-only-border/</guid>
      <description>取用圆角类的only属性，左上，右上，左下，右下，此处圆角半径也是一个类 BorderRadius.only( topLeft: Radius.circular(8.w), topRight: Radius.circular(8.w), ) 全部圆角则取all BorderRadius.all( Radius.circular(8.w) )</description>
    </item>
    
    <item>
      <title>flutter随机颜色生成</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-random-color/</link>
      <pubDate>Tue, 05 Jan 2021 10:00:03 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-random-color/</guid>
      <description>在listview或gridview中，用index去获颜色，挨个取一遍 Colors.primaries[index % Colors.primaries.length]</description>
    </item>
    
    <item>
      <title>flutter模型生成</title>
      <link>https://geek.zshipu.com/post/flutter/generate-gdart-file/</link>
      <pubDate>Fri, 25 Dec 2020 13:17:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/generate-gdart-file/</guid>
      <description>首先自己写好模型类模板代码 import &#39;package:json_annotation/json_annotation.dart&#39;; part &#39;buy_record_data.g.dart&#39;; ///标志class需要实现json序列化功能 @JsonSerializable() class BuyRecordData { ///属性 List&amp;lt;BuyRecordEntity&amp;gt; entities; /// 构造函数 BuyRecordData(this.entities); /// 这个函数在.g.dart中，命名就是类名+FromJson /// 直接写就行 报错也没关系 生成.g.dart文件之后就好了 factory BuyRecordData.fromJson(Map&amp;lt;String, dynamic&amp;gt; json) =&amp;gt; _$BuyRecordDataFromJson(json); Map&amp;lt;String, dynamic&amp;gt; toJson() =&amp;gt; _$BuyRecordDataToJson(this); } 然后在终端运行，生成.g.</description>
    </item>
    
    <item>
      <title>flutter渲染原理要点</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-render-theory/</link>
      <pubDate>Wed, 02 Dec 2020 23:35:58 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-render-theory/</guid>
      <description>渲染过程会生成三棵树 widget树 element树 render object树 提高buid效率，在build方法中尽量少做事，层级越简单越好 setState方法尽量下放到底层节点 尽量减少重绘区域，使用repaint boundry 减少离屏渲染 比如save layer，clip path， 减少透明度使用，因为每</description>
    </item>
    
    <item>
      <title>dart枚举</title>
      <link>https://geek.zshipu.com/post/flutter/dart-enum/</link>
      <pubDate>Wed, 02 Dec 2020 08:03:53 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/dart-enum/</guid>
      <description>enum MediaType { movie, //0 shortVideo, //1 other, //2 } var videoType = MediaType.values[0]; // videoType == movie 定义枚举和OC差别不大，取值的时候不可以直接和int比较，需要从枚举数组中根据index拿出来，比OC多了一步</description>
    </item>
    
    <item>
      <title>flutter组件</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-components/</link>
      <pubDate>Fri, 27 Nov 2020 11:14:54 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-components/</guid>
      <description>sliverList A sliver that places multiple box children in a linear array along the main axis. Each child is forced to have the SliverConstraints.crossAxisExtent in the cross axis but determines its own main axis extent. SliverList determines its scroll offset by &amp;ldquo;dead reckoning&amp;rdquo; because children outside the visible part of the sliver are not materialized, which means SliverList cannot learn their main axis extent.Instead,newly materialized children are placed adjacent to existing children.</description>
    </item>
    
    <item>
      <title>flutter actionSheet使用方法</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-action-sheet/</link>
      <pubDate>Thu, 26 Nov 2020 18:51:55 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-action-sheet/</guid>
      <description>//函数 _showCupertinoActionSheet() async{ var result = await showCupertinoModalPopup( context: context, builder: (context) { return CupertinoActionSheet( title: Text(&#39;标题&#39;), message: Text(&#39;内容&#39;), actions: &amp;lt;Widget&amp;gt;[ CupertinoActionSheetAction( child: Text( &#39;标题一&#39;, style: TextStyle( color: Color(0xFF00C599) ), ), onPressed: () { Navigator.of(context).pop(&#39;delete&#39;); }, isDefaultAction: true, ), CupertinoActionSheetAction( child: Text(&#39;标题二&#39;), onPressed: () { Navigator.of(context).pop(&#39;not delete&#39;); }, isDestructiveAction: true, ), ], cancelButton: CupertinoActionSheetAction( child: Text( &#39;取消&#39;, style: TextStyle( color: Colors.white ), ), onPressed: () { Navigator.of(context).pop(&#39;cancel&#39;); }, ), ); }); print(&#39;$result&#39;); } 总结：在showCupertinoModalPo</description>
    </item>
    
    <item>
      <title>无法打开&#34;xxx&#34;,因为无法确认开发者的身份</title>
      <link>https://geek.zshipu.com/post/unix/cannot-open-app-on-mac/</link>
      <pubDate>Wed, 25 Nov 2020 23:55:41 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/cannot-open-app-on-mac/</guid>
      <description>处理方法 加权限,同意任何来源 sudo spctl --master-disable //用完还原 sudo spctl --master-enable 按住command键，鼠标右键菜单选择打开app，出现窗口会出现打开按钮，正常情况下不会出现 参考：https://huajiakeji.com/macos/2019-07/2793.html 完。</description>
    </item>
    
    <item>
      <title>fijkplayer播放期间屏幕熄灭处理</title>
      <link>https://geek.zshipu.com/post/flutter/fijkplayer-off/</link>
      <pubDate>Wed, 25 Nov 2020 23:49:43 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/fijkplayer-off/</guid>
      <description>两种方案 1.借用第三方插件，让当前页面保持常量，别的页面跟随系统 wakelock: ^0.1.4+2 Wakelock.enable(); Wakelock.disable(); 2.调用fijkplayer自身的常量参数 二选一 await player.setOption(FijkOption.hostCategory, &amp;quot;request-screen-on&amp;quot;, 1); FijkPlugin.keepScreenOn ; 参考：https://www.jianshu.com/p/8750de450850 https://fijkplayer.befovy.com/docs/zh/host-option.html#gsc.tab=0</description>
    </item>
    
    <item>
      <title>pubspec.lock坑</title>
      <link>https://geek.zshipu.com/post/flutter/pubspec-error/</link>
      <pubDate>Wed, 25 Nov 2020 09:27:09 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/pubspec-error/</guid>
      <description>昨天以为pubspec.lock文件和cocoapods的profile.lock文件性质一样，可以生成，所以删除，结果遇见了编译报错，即使在执行了 flutter pub get 命令重新生成后，经过一番研究和队友协助，找到是这个问题，把老的恢复回来工程编译正常，下面是报错的关键字 Execution failed for task &#39;:app:processDebugManifest&#39;. &amp;gt; Manifest merger failed : Attribute provider...</description>
    </item>
    
    <item>
      <title>flutter启动页</title>
      <link>https://geek.zshipu.com/post/flutter/splash-page/</link>
      <pubDate>Tue, 24 Nov 2020 14:09:04 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/splash-page/</guid>
      <description>在main.dart文件的materialAPP.home属性返回一个UI，这个UI就是启动页，启动页的scanffold的body，返回一张图片 in main.dart return MaterialApp( home: SplashPage(), ); in SplashPage @override Widget build(BuildContext context) { return Scaffold( body: Container( child: Image.asset( &#39;assets/images/launch_image.png&#39;, fit: BoxFit.fill, width: double.infinity, height: double.infinity, ), ), ); }</description>
    </item>
    
    <item>
      <title>flutter工程注意事项</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-tips/</link>
      <pubDate>Tue, 24 Nov 2020 11:50:49 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-tips/</guid>
      <description>在工程文件夹内，git管理，忽略pubspec.lock文件 ，运行 flutter pub get /ios文件夹里，忽略Pods文件夹，Podfile.lock文件，*.xcworkspace文件,运行 pod install</description>
    </item>
    
    <item>
      <title>enter passphrase for key询问解决</title>
      <link>https://geek.zshipu.com/post/unix/ssh-issue/</link>
      <pubDate>Tue, 24 Nov 2020 11:47:58 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/ssh-issue/</guid>
      <description>ssh-add ~/.ssh/id_rsa ssh添加id_rsa文件即可</description>
    </item>
    
    <item>
      <title>zsh的挽救</title>
      <link>https://geek.zshipu.com/post/unix/zsh-problem/</link>
      <pubDate>Mon, 23 Nov 2020 18:36:03 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/zsh-problem/</guid>
      <description>今天配置环境变量的时候，因为失误不小心让zsh整个失效了， zsh: command not found:xxx 补救办法，在命令行输入 PATH=/bin:/usr/bin:/usr/local/bin:${PATH} 恢复正常 失误的地方在于配置flutter时路径少输入一个$符号，在$HOME/.zshrc文件中 //正确 export PATH=&amp;quot;$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin&amp;quot; //错误 export PATH=&amp;quot;PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin&amp;quot; //注意 PATH_TO_FLUTTER_GIT_DIRECTORY 是需要输入全路径的，/User/xxx/xxx,不是~符号！</description>
    </item>
    
    <item>
      <title>LRU cache implementation</title>
      <link>https://geek.zshipu.com/post/arithmetic/lru-cache/</link>
      <pubDate>Fri, 20 Nov 2020 23:39:09 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/arithmetic/lru-cache/</guid>
      <description>LRU cache stand for Least Recently Used Cache,which evict least recently used entry.As Cache purpose is to provide fast and efficient way of retrieving data, it need to meet certain requirement. Some of the Requirement are fixed size:cache need to have some bounds to limit memory usages. Fast Access:Cache Inert and lookup operation should be fast, preferably O(1) time Replacement of Entry in case,Memory Limit is reached:A cache shoule have efficient algorithm to evict when memory is full. In case of LRU cache we evict least recently used entry so we have to keep track of recently used entries, entries which have not been used from long time and which have been used recently, plus lookup and insertion operation should be fast enough . When we think about O(1) lookup, obvious data structure comes in our mind is HashMap.HashMap provide</description>
    </item>
    
    <item>
      <title>flutter中list view加一个header view</title>
      <link>https://geek.zshipu.com/post/flutter/listview-headerview/</link>
      <pubDate>Fri, 20 Nov 2020 23:24:35 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/listview-headerview/</guid>
      <description>body: CustomScrollView( slivers: &amp;lt;Widget&amp;gt;[ SliverGrid.count( //具体的配置 ), //列表 SliverFixedExtentList( delegate: SliverChildBuilderDelegate( (context, index) =&amp;gt; ConversationListItem( delegate: this, conversation: conList[index] ), childCount: conList.length, ), itemExtent: 100, ), ], ), 解析：大的容器叫做custom scroll view,子控件叫做slivers，是一个数组，在数组里面从上到下排布sliver控件，有sliver grid，有sliver fixed extent list 效果大概长这样</description>
    </item>
    
    <item>
      <title>flutter按钮点击事件传给delegate</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-btn-delegate/</link>
      <pubDate>Thu, 19 Nov 2020 22:43:34 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-btn-delegate/</guid>
      <description>在ios中，通常用block或者代理去实现，在flutter中，外部实现一个方法，把这个方法传给按钮，按钮内部用callback接受，ontap方法调用即可，实现如下 import &#39;package:flutter/cupertino.dart&#39;; import &#39;package:flutter/material.dart&#39;; //定义函数类型 typedef StringValue = void Function(String); class ImageBtn extends StatelessWidget { //作为属性 StringValue callback; ImageBtn({Key key,this.callback}) : super(key: key); @override Widget build(BuildContext context) { return new GestureDetector( onTap: () { print(&#39;MyButton was tappedq!&#39;); //调用 this.callback(&amp;quot;testString&amp;quot;); }, child: ...</description>
    </item>
    
    <item>
      <title>flutter控件从上到下居中排列</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-expanded/</link>
      <pubDate>Thu, 19 Nov 2020 22:30:23 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-expanded/</guid>
      <description>Column( children: &amp;lt;Widget&amp;gt;[ Expanded(child: Image.asset(&#39;assets/images/$imageName.png&#39;) ), Text( this.model.title, style: TextStyle( fontSize: 15, color: Colors.white, ), ), ], ), 注解： - column是一个垂直的容器，子控件放在children里面 - 要想让图片居中，需要放在expanded容器里面,官方定义：expanded is a widget that expands a child of a row,column,or flex so that the child fills the available space. -</description>
    </item>
    
    <item>
      <title>flutter判断页面是否在屏幕上</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-page-is-current/</link>
      <pubDate>Thu, 19 Nov 2020 22:18:51 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-page-is-current/</guid>
      <description>ModalRoute.of(context).isCurrent 解析：由于页面的组合都是由路由管理的，所以把当前的context传给路由，让路由去判断是否在最顶端，这个路由叫做模态路由</description>
    </item>
    
    <item>
      <title>图片引发的思考</title>
      <link>https://geek.zshipu.com/post/arithmetic/babylon/</link>
      <pubDate>Wed, 18 Nov 2020 22:48:43 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/arithmetic/babylon/</guid>
      <description>在博客中看到这张有趣的图片，自己加了点扩展 自动证明了 - (a+b)^2 = a^2 + 2ab + b^2 - (a-b)^2 = a^2 - 2ab + b^2</description>
    </item>
    
    <item>
      <title>flutter tabcontroller监听点击调用两次</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-tabbar-click-bug/</link>
      <pubDate>Wed, 18 Nov 2020 16:14:48 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-tabbar-click-bug/</guid>
      <description>原因：点击本身出发一次监听，随之产生的动画效果再次出发监听，如果是滑动，仅触发一次监听 解决：看下点击的索引和动画值对不对，过滤掉点击的listen，只显示动画的listen _tabController.addListener(() { if(_tabController.index == _tabController.animation.value){ int index = _tabController.index; print(&amp;quot;====================当前点击了$index==</description>
    </item>
    
    <item>
      <title>flutter延迟执行方法</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-thread-delay/</link>
      <pubDate>Wed, 18 Nov 2020 12:21:12 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-thread-delay/</guid>
      <description>延迟加载 //延迟1秒加载 Future.delayed(Duration(seconds: 1), (){ //do sth }); 使用场景： &amp;gt; 同时执行toast和导航栏页面切换，会导致卡顿，可用延迟其中一个方法，避免同时执行</description>
    </item>
    
    <item>
      <title>flutter渐变处理</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-gradient/</link>
      <pubDate>Wed, 18 Nov 2020 12:20:54 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-gradient/</guid>
      <description>线性渐变 开始位置 结束位置 开始结束点 颜色 LinearGradient( //渐变位置 begin: Alignment.topLeft, //左上 end: Alignment.bottomRight, //右下 stops: [0.0, 1.0], //[渐变起始点, 渐变结束点] //渐变颜色[始点颜色, 结束颜色] colors: [Color.fromRGBO(253, 1, 129, 1), Color.fromRGBO(206, 21, 240, 1)] )</description>
    </item>
    
    <item>
      <title>flutter基础知识</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-layout/</link>
      <pubDate>Tue, 17 Nov 2020 17:38:24 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-layout/</guid>
      <description>基本上由widget组成，widget有stateless和stateful两种，常用的基础widget有 - container：矩形元素，可以设置背景边框阴影 - row，column：让子控件水平和垂直布局，flex布局原理 - stack：可以堆砌widget，用上下左右来定位 - te</description>
    </item>
    
    <item>
      <title>mac android studio flutter 打包 apk</title>
      <link>https://geek.zshipu.com/post/unix/build-apk/</link>
      <pubDate>Mon, 16 Nov 2020 20:16:07 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/build-apk/</guid>
      <description>Create a keystore keytool -genkey -v -keystore ~/key.jks -keyalg RSA -keysize 2048 -validity 10000 -alias key /android文件夹下生成属性文件关联秘钥 key.properties storePassword=&amp;lt;password from previous step&amp;gt; keyPassword=&amp;lt;password from previous step&amp;gt; keyAlias=key storeFile=&amp;lt;location of the key store file, such as /Users/&amp;lt;user name&amp;gt;/key.jks&amp;gt; /android/app/build.gradle文件里增加load代码 def keystoreProperties = new Properties() def keystorePropertiesFile = rootProject.file(&#39;key.properties&#39;) if (keystorePropertiesFile.exists()) { keystoreProperties.load(new FileInputStream(keystorePropertiesFile)) } android { ... } 在buildTypes之前增加签名配置代码 signingConfigs { release { keyAlias keystoreProperties[&#39;keyAlias&#39;]</description>
    </item>
    
    <item>
      <title>寻找下一个数</title>
      <link>https://geek.zshipu.com/post/arithmetic/find-next-numnber/</link>
      <pubDate>Sun, 15 Nov 2020 23:03:38 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/arithmetic/find-next-numnber/</guid>
      <description>寻找下一个数字，例如输入345，输出354 &amp;gt;思路：从最右边位和上一位对比，如果大，就往前移，移动完，尾数排序，从大到小，保证次大 -代码 //字符串逆序 NSString *reverseStr(NSString *str){ NSMutableString *string=[[NSMutableString alloc] init]; for(int i=0;i&amp;lt;str.length;i++){ [string appendString:[str substringWithRange:NSMakeRange(str.length-1-i, 1)]]; } return string; } //字符串分成数组 NSMutableArray *separateStringToArray(NSString *str){ NSMutableArray *marr = [NSMutableArray array]; for (NSInteger i = 0; i &amp;lt; str.length; i++) { [marr addObject:[str substringWithRange:NSMakeRange(i, 1)]]; } return marr; } NSString *findNextLargerNum(NSString *oriNum){ NSMutableString *finalStr = [NSMutableString string]; NSMutableArray *marr =</description>
    </item>
    
    <item>
      <title>字典取值为空崩溃问题</title>
      <link>https://geek.zshipu.com/post/iOS/dic-nil/</link>
      <pubDate>Fri, 13 Nov 2020 10:24:39 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/dic-nil/</guid>
      <description>今天后台报错 [_NSPlaceholderData initWithBase64Encoding:]: nil string argument Foundation -[NSData(NSData) base64Encoding] 经过检查问题发生在字典取出值没有判空就传递给方法使用，细节也要注意，养成良好的编码习惯 NSString *urlstr = dic[@&amp;quot;imgBase64&amp;quot;]; NSData *data = [[NSData alloc] initWithBase64Encoding:urlstr]; 正确的代码 id obj = dic[@&amp;quot;imgBase64&amp;quot;]; if (obj &amp;amp;&amp;amp; [obj isKindOfClass:[NSString class]]) { NSString *urlstr = (NSString *)obj; NSData *data = [[NSData alloc] initWithBase64Encoding:urlstr]; }</description>
    </item>
    
    <item>
      <title>flutter和ffmpeg的资源</title>
      <link>https://geek.zshipu.com/post/flutter/fluter-source/</link>
      <pubDate>Thu, 12 Nov 2020 21:31:18 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/fluter-source/</guid>
      <description>咸鱼flutter技术文章集合：https://www.yuque.com/xytech/flutter 关于ffmpeg一位老师的博客：https://blog.csdn.net/leixiaohua1020 b站老师视频相关https://yinwenjie.blog.csdn.</description>
    </item>
    
    <item>
      <title>跑flutter工程的坑</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-points/</link>
      <pubDate>Thu, 12 Nov 2020 21:05:29 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-points/</guid>
      <description>下载过来，一定要把pod和workspace删掉重新安装，否则会出现奇奇怪怪的问题，比如目标系统不对应，不适配arm64架构等： The iOS deployment target &amp;lsquo;IPHONEOS_DEPLOYMENT_TARGET&amp;rsquo; is set to 8.0 undefined symbols for architecture arm</description>
    </item>
    
    <item>
      <title>flutter pub get慢</title>
      <link>https://geek.zshipu.com/post/flutter/pub-get-is-slow/</link>
      <pubDate>Thu, 12 Nov 2020 19:30:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/pub-get-is-slow/</guid>
      <description>分析：从开发者仓库网站下载依赖比较慢，网络问题 解决： 更换数据源地址 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 最后翻墙运行 参考：https://www.askmaclean.com/archives/flutter-pub-get-slow.html</description>
    </item>
    
    <item>
      <title>2020-11安装cocoapods问题</title>
      <link>https://geek.zshipu.com/post/iOS/cocoapods/</link>
      <pubDate>Thu, 12 Nov 2020 18:48:08 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/cocoapods/</guid>
      <description>今天安装pods发生无法下载问题， Unable to download data from XXX 切换了镜像源解决 查看镜像源 gem sources -l 删除淘宝镜像源 -r remove sudo gem sources -r https://ruby.taobao.org/ 添加新的镜像源 -a add sudo gem sources -a https://rubygems.org 安装 sudo gem install cocoapods 成功 Successfully installed cocoapods-1.10.0 Parsing documentation for cocoapods-1.10.0 Done installing documentation for cocoapods after 2 seconds 参考：https://blog.csdn.net/li_ph/article/details/438</description>
    </item>
    
    <item>
      <title>catalina系统的zsh配置</title>
      <link>https://geek.zshipu.com/post/unix/zsh/</link>
      <pubDate>Thu, 12 Nov 2020 18:13:26 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/unix/zsh/</guid>
      <description>catalina系统默认的终端是zsh，如果没有找到配置文件，需要自己创建 vim ~/.zshrc 保存运行使之生效 source $HOME/.zshrc 看一下是否成功 echo $PATH 参考：https://stackoverflow.com/questions/10574684/where-to-place-path-variable-asser</description>
    </item>
    
    <item>
      <title>static-lib</title>
      <link>https://geek.zshipu.com/post/iOS/static-lib/</link>
      <pubDate>Thu, 12 Nov 2020 12:35:48 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/iOS/static-lib/</guid>
      <description>static lib a unit of code linked at compile time,which does not change
Dynamic lib a unit of code and/or assets linked at runtime that may change only Apple is allowed to create dynamic libraries for iOS
Software Framework a compiled set of code that accomplished a task,hence,you can actually have a static framework or a dynamic framework,which are typically just the compiled versions of the above.
source：https://stackoverflow.com/questions/15331056/library-static-dynamic-or-framework-project-inside-another-project</description>
    </item>
    
    <item>
      <title>Go规范：Uber Go 语言编码规范</title>
      <link>https://geek.zshipu.com/post/go/Go%E8%A7%84%E8%8C%83Uber-Go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
      <pubDate>Fri, 06 Nov 2020 21:20:59 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E8%A7%84%E8%8C%83Uber-Go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
      <description>[](#uber-goguide-的中文翻译)uber-go/guide 的中文翻译 [](#english)English [](#uber-go-语言编码规范)Uber Go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 Go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 Gopher 圈熟知的 zap、jaeger 等。2018 年年末 Uber</description>
    </item>
    
    <item>
      <title>Go实战：Go语言实战笔记</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%AE%9E%E6%88%98Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 04 Nov 2020 21:20:40 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%AE%9E%E6%88%98Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/</guid>
      <description>[](#go语言实战笔记)Go语言实战笔记 Go语言环境搭建详解 《Go语言实战》笔记(一) | Go包管理 《Go语言实战》笔记(二) Go开发工具 《Go语言实战》笔记(三) | Go Doc 文档 《Go语言实战》笔记(四) | Go 数组 《Go语言实战》笔记(五) | Go 切片 《Go语言实战》笔记(六) | Go Map 《Go</description>
    </item>
    
    <item>
      <title>程序员：读书系列推荐书一</title>
      <link>https://geek.zshipu.com/post/news/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97%E6%8E%A8%E8%8D%90%E4%B9%A6%E4%B8%80/</link>
      <pubDate>Sun, 01 Nov 2020 14:07:47 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%AF%BB%E4%B9%A6%E7%B3%BB%E5%88%97%E6%8E%A8%E8%8D%90%E4%B9%A6%E4%B8%80/</guid>
      <description>语言类 python源码剖析 这本书讲解了python2.5版本的cpython实现，大致分为3个部分，分别讲解了python中基本对象python虚拟机和python的runtime的实现和原理。个人感觉这本书可以帮助你理解python执行时候的行为，为什么代码会有这样的表现，比如</description>
    </item>
    
    <item>
      <title>Go汇总 2：最优秀的Go博客</title>
      <link>https://geek.zshipu.com/post/go/Go%E6%B1%87%E6%80%BB-2%E6%9C%80%E4%BC%98%E7%A7%80%E7%9A%84Go%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sun, 01 Nov 2020 13:58:20 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E6%B1%87%E6%80%BB-2%E6%9C%80%E4%BC%98%E7%A7%80%E7%9A%84Go%E5%8D%9A%E5%AE%A2/</guid>
      <description>[](#go优秀博客)Go优秀博客 [](#周刊类)周刊类 [](#golang-weekly)Golang weekly Golang Weekly https://golangweekly.com/ https://golangweekly.com/issues/254 [](#go夜读)Go夜读 Go 每日阅读和 Go 夜读 &amp;gt; Daily Reading Go and Night Reading Go - Go source reading and offline technical or another articles or discussion on every night. https://github.com/developer-learning/reading-go Go 夜读 https://reading.developerlearning.cn/ Go夜读 at Bilibili https://space.bilibili.com/326749661 [](#个人类)个人类 [](#tony-bai)Tony Bai Tony Bai 一个程序员的心路历程 https://tonybai.com/ 理解Golang包导入 https://tonybai.com/2015/03/09/understanding-import-packages/ &amp;ldquo;实际测试</description>
    </item>
    
    <item>
      <title>Go汇总 1：最全面的go语言学习圣地</title>
      <link>https://geek.zshipu.com/post/go/Go%E6%B1%87%E6%80%BB-1%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%9C%A3%E5%9C%B0/</link>
      <pubDate>Sun, 01 Nov 2020 13:57:03 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E6%B1%87%E6%80%BB-1%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E5%9C%A3%E5%9C%B0/</guid>
      <description>[](#go-general)Go general 怎么学习 Golang？ https://www.zhihu.com/question/23486344 怎么学习 Golang？ - 知乎用户的回答 - 知乎 https://www.zhihu.com/question/23486344/answer/24785991 Project Euler https://projecteuler.net/ 怎么学习 Golang？ - cholerae的回答 - 知乎 https://www.zhihu.com/question/23486344/answer/130837179 The Go Programming Language https://golang.org/doc/ A Tour of Go https://tour.golang.org/welcome/ Go語言聖經（中文版） https://www.gitbook.com/book/wizardforcel/gopl-zh/details https://www.gitbook.com/@wizardforcel 系统学习GO，推荐几本靠谱的书? - 飞雪无情的回答 - 知乎 https://www.zhihu.com/question/30461290/answer/210414739 Go编程语言 https://go-zh.org/doc/ Go指南 https://tour.go-zh.org/welcome/ Go语言圣经 https://www.gitbook.com/book/yar999/gopl-zh/details 然后通</description>
    </item>
    
    <item>
      <title>Monorepo：Monorepo 是什么，为什么大家都在用</title>
      <link>https://geek.zshipu.com/post/framework/MonorepoMonorepo-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E7%94%A8/</link>
      <pubDate>Sun, 01 Nov 2020 12:53:27 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/framework/MonorepoMonorepo-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E7%94%A8/</guid>
      <description>Monorepo 是什么，为什么大家都在用？ Dan Luu 很早很早就写了篇文章，给大家介绍 monorepo 。在我之前那篇推荐 Buck / Bazel 的文章之后就想讲讲 monorepo，结果一直没来得及写。 Monorepo 的概念要和互联网公司里怎样训练新人上手一起讲。很多公司要花超过半个月的时间才能让新人开始动手干活，并不是内部系统要学的东西很多，只是</description>
    </item>
    
    <item>
      <title>Go基础系列：保持模块兼容</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%BF%9D%E6%8C%81%E6%A8%A1%E5%9D%97%E5%85%BC%E5%AE%B9/</link>
      <pubDate>Sun, 01 Nov 2020 11:11:00 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%BF%9D%E6%8C%81%E6%A8%A1%E5%9D%97%E5%85%BC%E5%AE%B9/</guid>
      <description>随着您添加新功能、更改行为和重新考虑模块公共表面的某些部分，模块将随着时间的推移而演变。如Go 模块：v2 和以后，对 v1+ 模块的中断更改必须作为主要版本颠簸的一部分（或采用新的模块路径）发生。 但是，发布新的主要版本对用户来说很难。他们必须找到新版本，学习新的 API，并更改他们的代码。有</description>
    </item>
    
    <item>
      <title>Go基础系列：Go模块v2 和 Beyond</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97Go%E6%A8%A1%E5%9D%97v2-%E5%92%8C-Beyond/</link>
      <pubDate>Sun, 01 Nov 2020 11:10:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97Go%E6%A8%A1%E5%9D%97v2-%E5%92%8C-Beyond/</guid>
      <description>随着成功的项目的成熟和新的要求被添加，过去的功能和设计决策可能会停止意义。开发人员可能希望通过删除已弃用函数、重命名类型或将复杂包拆分为可管理部分来整合他们学到的经验教训。这些类型的更改需要下游用户努力将代码迁移到新的 API，因此不应在不考虑收益大于成本的情况下进行这些更改。 对于</description>
    </item>
    
    <item>
      <title>Go基础系列：发布 Go 模块</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E5%8F%91%E5%B8%83-Go-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 01 Nov 2020 11:08:22 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E5%8F%91%E5%B8%83-Go-%E6%A8%A1%E5%9D%97/</guid>
      <description>请注意：这篇文章涵盖了开发，包括。如果你有兴趣，请参阅去模块：v2和Beyond。v1v2 这篇文章在示例中使用了 Gitmercurialbazaar，和其他人也得到支持。 项目设置 对于此帖子，您需要一个现有项目作为示例。因此，从&amp;rdquo;使用转到模块&amp;rdquo;文章末尾的文件</description>
    </item>
    
    <item>
      <title>Go基础系列：迁移转到模块</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E8%BF%81%E7%A7%BB%E8%BD%AC%E5%88%B0%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 01 Nov 2020 11:05:44 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E8%BF%81%E7%A7%BB%E8%BD%AC%E5%88%B0%E6%A8%A1%E5%9D%97/</guid>
      <description>Go 项目使用各种依赖项管理策略。dep和滑翔等供应商工具很受欢迎，但它们在行为上存在很大差异，而且并不总是很好地协同工作。某些项目将其整个 GOPATH 目录存储在单个 Git 存储库中。其他人只是依赖并期望在 GOPATH 中安装相当新版本的依赖项。go get Go 的模块系统在 Go 1.11 中引入，它提供了命令中内置的官方依赖管理解</description>
    </item>
    
    <item>
      <title>Go基础系列：使用 Go 模块</title>
      <link>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%BD%BF%E7%94%A8-Go-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 01 Nov 2020 11:03:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Go%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%BD%BF%E7%94%A8-Go-%E6%A8%A1%E5%9D%97/</guid>
      <description>Go 1.11 和 1.12 包括对模块的初步支持，Go 的新依赖项管理系统使依赖关系版本信息明确且更易于管理。本文介绍了开始使用模块所需的基本操作。 模块是存储在文件树中的 Go包的集合，其根目录有文件。该文件定义了模块的模块_路径_，这也是用于根目录的导入路径，以及其依赖项_要求_，这是成功生成所需的其</description>
    </item>
    
    <item>
      <title>NPM起步：将私有 NPM 包发布到 Nexus</title>
      <link>https://geek.zshipu.com/post/npm/NPM%E8%B5%B7%E6%AD%A5%E5%B0%86%E7%A7%81%E6%9C%89-NPM-%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0-Nexus/</link>
      <pubDate>Fri, 30 Oct 2020 18:15:02 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/npm/NPM%E8%B5%B7%E6%AD%A5%E5%B0%86%E7%A7%81%E6%9C%89-NPM-%E5%8C%85%E5%8F%91%E5%B8%83%E5%88%B0-Nexus/</guid>
      <description>我们都在项目上工作，这让我们有机会构建可重用的组件。大多数时候，这些组件最终出现在项目的文件夹中。然后，此文件夹被复制粘贴到多个项目中，随着时间的推移，这成为更新的噩梦，因为我们不能轻易地拥有多个版本的组件，并且在多个分支上维护相同的代码库，因为版本是解决这个问题的一种棘手解决方</description>
    </item>
    
    <item>
      <title>Python基础：Python文件打开</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80/</link>
      <pubDate>Sun, 25 Oct 2020 20:23:38 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80/</guid>
      <description>Python文件打开 打开服务器上的文件 假设我们有以下文件，位于与 Python 相同的文件夹中： test. txt Hello! Welcome to demofile.txt This file is for testing purposes. Good Luck! 若要打开文件，请使用内置函数。open() 函数返回一个文件对象，该对象具有读取文件内容的方法：open()read() 例子 f = open(&amp;quot;demofile.txt&amp;quot;, &amp;quot;r&amp;quot;) print(f.read()) 如果文件位于其他位置，则必须指定文件路</description>
    </item>
    
    <item>
      <title>Python基础：Python文件操作</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 25 Oct 2020 20:09:11 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</guid>
      <description>Python文件操作 文件处理是任何 Web 应用程序的重要组成部分。 Python 具有多个用于创建、读取、更新和删除文件的函数。 文件处理 使用 Python 中的文件的关键功能是该函数。open() 函数采用两个参数;_文件名_和_模式_。open() 打开文件有四种不同的方法（模式）： &amp;ldquo;a&amp;rdquo;```- 追加 - 打开文件进行追加，如果文</description>
    </item>
    
    <item>
      <title>Python基础：Python字符串格式</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Sun, 25 Oct 2020 20:05:49 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F/</guid>
      <description>Python字符串格式 若要确保字符串将像预期的那样显示，我们可以使用 方法对结果进行格式设置。format() 字符串格式（） 该方法允许您格式化字符串的选定部分。format() 有时，有些文本部分您无法控制，可能它们来自数据库，或者用户输入？ 若要控制这些值，请添加文本中的占位符（卷曲</description>
    </item>
    
    <item>
      <title>Python基础：Python user input 接收</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-user-input-%E6%8E%A5%E6%94%B6/</link>
      <pubDate>Sun, 25 Oct 2020 20:04:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-user-input-%E6%8E%A5%E6%94%B6/</guid>
      <description>Python user input 接收 user_input Python 允许用户输入。 这意味着我们可以向用户请求输入。 在 Python 3.6 中，该方法与 Python 2.7 方法略有不同。 Python 3.6 使用该方法。input() Python 2.7 使用该方法。raw_input() 下面的示例要求使用用户名，当您输入用户名时，它会在屏幕上打印出来： Python 3.6 username = input(&amp;quot;Enter username:&amp;quot;) print(&amp;quot;Username is: &amp;quot; + username) Python 2.7 username = raw_input(&amp;quot;Enter username:&amp;quot;) print(&amp;quot;Username is: &amp;quot; + username) Python 在函</description>
    </item>
    
    <item>
      <title>Python基础：Python try except</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-try-except/</link>
      <pubDate>Sun, 25 Oct 2020 20:03:01 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-try-except/</guid>
      <description>Python try except 该块允许您测试代码块的错误。try 该块允许您处理错误。except 该块允许您执行代码，而不管 try- 和除块的结果如何。finally 异常处理 当发生错误或我们称之为异常时，Python 通常会停止并生成错误消息。 可以使用 语句处理这些异常：try 例子 块将生成异常，因为未定义：tryx try:</description>
    </item>
    
    <item>
      <title>Python基础：Python pip 包管理器</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-pip-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Sun, 25 Oct 2020 19:49:50 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-pip-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>Python Pip 什么是 PIP？ PIP 是 Python 包的包管理器，或者如果您喜欢，也可以是模块。 注：如果您有 Python 版本 3.4 或更晚，则默认情况下包括 PIP。 什么是Package？ 包包含模块所需的所有文件。 模块是 Python 代码库，您可以在项目中包含。 检查 PIP 是否已安装 将命令行导航到 Python 的脚本目录的位置，然后键入以下内容： 例子 检查</description>
    </item>
    
    <item>
      <title>Python基础：Python Regx 正则表达式</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Regx-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-/</link>
      <pubDate>Sun, 25 Oct 2020 19:47:09 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Regx-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-/</guid>
      <description>Python RegEx RegEx 或正则表达式是组成搜索模式的字符序列。 RegEx 可用于检查字符串是否包含指定的搜索模式。 正则表达式模块 Python 有一个名为 的内置包，可用于使用正则表达式。re 导入模块：re import re Python 中的 RegEx 导入模块后，可以开始使用正则表达式：re 例子 搜索字符串以查看其是否以&amp;rdquo;The&amp;rdquo;开头</description>
    </item>
    
    <item>
      <title>Python基础：Python Json</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Json/</link>
      <pubDate>Sun, 25 Oct 2020 19:44:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Json/</guid>
      <description>Python Json JSON 是一种用于存储和交换数据的语法。 JSON 是文本，使用 JavaScript 对象表示法编写。 Python 中的 Json Python 有一个名为 的内置包，可用于处理 JSON 数据。json 例子 导入 json 模块： import json 解析 Json - 从 Json 转换为 Python 如果您有 JSON 字符串，可以使用 方法分析它。json.loads() 结果将是Python字典。 例子 从 JSON 转换为 Python</description>
    </item>
    
    <item>
      <title>Python基础：Python数学函数</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 25 Oct 2020 19:41:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</guid>
      <description>Python数学函数 Python 有一组内置的数学函数，包括一个广泛的数学模块，允许您对数字执行数学任务。 内置数学函数 和 函数可用于查找可重复值中的最低值或最高值：min()max() 例子 x = min(5, 10, 25) y = max(5, 10, 25) print(x) print(y) 函数返回指定数字的绝对（正）值：abs() 例子 x = abs(-7.25) print(x) 函数将 x 的值返回到 y （x） 的</description>
    </item>
    
    <item>
      <title>Python基础：Python日期时间</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sun, 25 Oct 2020 19:39:52 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4/</guid>
      <description>Python日期时间 Python 日期 Python 中的日期不是它自己的数据类型，但我们可以导入名为的模块，以将日期用作日期对象。datetime 例子 导入日期时间模块并显示当前日期： import datetime x = datetime.datetime.now() print(x) 日期输出 当我们从上面的示例执行代码时，结果将是： 日期包含年、月、日、小时、分钟、秒和微秒。 &amp;lt;font _mstmutation=&amp;quot;1&amp;quot; _msthash=&amp;quot;104507&amp;quot; _msttex</description>
    </item>
    
    <item>
      <title>Python基础：Python 模块</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 25 Oct 2020 19:38:23 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E6%A8%A1%E5%9D%97/</guid>
      <description>Python 模块 什么是模块？ 将模块视为与代码库相同。 包含要在应用程序中包含的一组函数的文件。 创建模块 若要创建模块，只需将要保存的代码保存在文件扩展名的文件中：.py 例子 将此代码保存在名为mymodule.py def greeting(name): print(&amp;quot;Hello, &amp;quot; + name) ## 使用模块 &amp;lt;font _mstmutation=&amp;quot;1&amp;quot; _msthash=&amp;quot;104507&amp;quot; _msttexthash=&amp;quot;17282946</description>
    </item>
    
    <item>
      <title>Python基础：Python 作用域</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E4%BD%9C%E7%94%A8%E5%9F%9F/</link>
      <pubDate>Sun, 25 Oct 2020 19:36:45 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E4%BD%9C%E7%94%A8%E5%9F%9F/</guid>
      <description>Python 作用域 变量仅从创建它的地区内部可用。这称为** 作用域**。 本地 作用域 在函数内创建的变量属于_该函数的_本地 作用域，只能在该函数内使用。 例子 在函数内创建的变量在函数内可用： def myfunc(): x = 300 print(x) myfunc() 函数内函数 如上例所述，该变量在函数之外不可用，但它可用于函数内的任何函数：x 例子 可以从函数中的</description>
    </item>
    
    <item>
      <title>Python基础：Python iterators</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-iterators/</link>
      <pubDate>Sun, 25 Oct 2020 19:33:42 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-iterators/</guid>
      <description>Python iterators Python iterators 活动器是包含可计数值数的对象。 遍历器是可遍历的对象，这意味着您可以遍历所有值。 从技术上讲，在 Python 中，一个数据器是实现引用器协议的对象，它由方法和 组成。__iter__()__next__() 可移动器与可移动 列表、元组、字典和集都是可重复的对象。它们是可重复_的容器_，您可以</description>
    </item>
    
    <item>
      <title>Python基础：Python继承</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Sun, 25 Oct 2020 19:26:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E7%BB%A7%E6%89%BF/</guid>
      <description>Python继承 Python 继承 继承允许我们定义一个类，该类从另一个类继承所有方法和属性。 父类是从继承的类，也称为基类。 子类是从另一个类继承的类，也称为派生类。 创建父类 任何类都可以是父类，因此语法与创建任何其他类相同： 例子 创建名为 的 类，带 和 属性，以及方法：Personfirstnamela</description>
    </item>
    
    <item>
      <title>Python基础：Python类和对象</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 25 Oct 2020 19:25:18 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>Python类和对象 Python 类/对象 Python 是一种面向对象的编程语言。 Python 中的几乎所有内容都是一个对象，其属性和方法。 类就像对象构造函数，或用于创建对象的&amp;rdquo;蓝图&amp;rdquo;。 创建类 若要创建类，请使用 关键字 ：class 例子 创建名为 MyClass 的类，其属性名为 x： class MyClass: x = 5 创建对象 现在，我们可</description>
    </item>
    
    <item>
      <title>Python基础：Python 阵列</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E9%98%B5%E5%88%97/</link>
      <pubDate>Sun, 25 Oct 2020 19:08:45 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E9%98%B5%E5%88%97/</guid>
      <description>Python 阵列 注：Python 没有对数组的内置支持，但可以使用 Python列表。 阵 列 注：本页演示如何使用列表作为 ARRAYS，但是，要使用 Python 中的数组，您必须导入库，如NumPy 库。 数组用于在单个变量中存储多个值： 例子 创建包含车名的数组： cars = [&amp;quot;Ford&amp;quot;, &amp;quot;Volvo&amp;quot;, &amp;quot;BMW&amp;quot;] 什么是阵列？ 数组是一个特殊的变量，一次可以</description>
    </item>
    
    <item>
      <title>Python基础：Python 阵列</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E9%98%B5%E5%88%97_20201025191937-z7p701j.sy/</link>
      <pubDate>Sun, 25 Oct 2020 19:08:45 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E9%98%B5%E5%88%97_20201025191937-z7p701j.sy/</guid>
      <description>Python 阵列 注：Python 没有对数组的内置支持，但可以使用 Python列表。 阵 列 注：本页演示如何使用列表作为 ARRAYS，但是，要使用 Python 中的数组，您必须导入库，如NumPy 库。 数组用于在单个变量中存储多个值： 例子 创建包含车名的数组： cars = [&amp;quot;Ford&amp;quot;, &amp;quot;Volvo&amp;quot;, &amp;quot;BMW&amp;quot;] 什么是阵列？ 数组是一个特殊的变量，一次可以</description>
    </item>
    
    <item>
      <title>Python基础：Python Lambda</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Lambda/</link>
      <pubDate>Sun, 25 Oct 2020 18:56:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Lambda/</guid>
      <description>Python Lambda lambda 函数是一个小的匿名函数。 lambda 函数可以接受任何数量的参数，但只能有一个表达式。 语法 lambda arguments : expression 执行表达式并返回结果： 例子 向 参数 添加 10，并返回结果：a x = lambda a : a + 10 print(x(5)) Lambda 函数可以具有多数个参数： 例子 将参数与参数相乘并返回结果：a b x = lambda a, b : a * b print(x(5, 6)) 例子 总结参数 、和 并返回结果：a</description>
    </item>
    
    <item>
      <title>Python基础：Python Lambda</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Lambda_20201025191937-6f82fwz.sy/</link>
      <pubDate>Sun, 25 Oct 2020 18:56:31 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Lambda_20201025191937-6f82fwz.sy/</guid>
      <description>Python Lambda lambda 函数是一个小的匿名函数。 lambda 函数可以接受任何数量的参数，但只能有一个表达式。 语法 lambda arguments : expression 执行表达式并返回结果： 例子 向 参数 添加 10，并返回结果：a x = lambda a : a + 10 print(x(5)) Lambda 函数可以具有多数个参数： 例子 将参数与参数相乘并返回结果：a b x = lambda a, b : a * b print(x(5, 6)) 例子 总结参数 、和 并返回结果：a</description>
    </item>
    
    <item>
      <title>Python基础：Python函数</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 25 Oct 2020 18:53:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%87%BD%E6%95%B0/</guid>
      <description>Python函数 函数是仅在调用时运行的代码块。 您可以将数据（称为参数）传递到函数中。 因此，函数可以返回数据。 创建函数 在 Python 中，函数使用def 关键字定义： 例子 def my_function(): print(&amp;quot;Hello from a function&amp;quot;) 调用函数 若要调用函数，请使用函数名称后跟括号： 例子 def my_function(): print(&amp;quot;Hello from a function&amp;quot;) **my_function()** 参数 信息可以作为参数传递到函数中。 参数在函数名称之</description>
    </item>
    
    <item>
      <title>Python基础：Python函数</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%87%BD%E6%95%B0_20201025191937-m72qqkh.sy/</link>
      <pubDate>Sun, 25 Oct 2020 18:53:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%87%BD%E6%95%B0_20201025191937-m72qqkh.sy/</guid>
      <description>Python函数 函数是仅在调用时运行的代码块。 您可以将数据（称为参数）传递到函数中。 因此，函数可以返回数据。 创建函数 在 Python 中，函数使用def 关键字定义： 例子 def my_function(): print(&amp;quot;Hello from a function&amp;quot;) 调用函数 若要调用函数，请使用函数名称后跟括号： 例子 def my_function(): print(&amp;quot;Hello from a function&amp;quot;) **my_function()** 参数 信息可以作为参数传递到函数中。 参数在函数名称之</description>
    </item>
    
    <item>
      <title>Python基础：Python for 循环</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-for-%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 25 Oct 2020 18:51:51 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-for-%E5%BE%AA%E7%8E%AF/</guid>
      <description>Python for 循环 Python for 循环 for循环用于在序列（列表、元组、字典、集或字符串）上迭代。 这与其他编程语言中的 for关键字不同，它的工作方式更像其他面向对象的编程语言中的一个引用器方法。 使用for循环，我们可以执行一组语句，一次用于列表、元组、集等中的每一项。 例子 在水果列表中打印每个水果： fruits =</description>
    </item>
    
    <item>
      <title>Python基础：Python for 循环</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-for-%E5%BE%AA%E7%8E%AF_20201025191937-v7dsgtf.sy/</link>
      <pubDate>Sun, 25 Oct 2020 18:51:51 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-for-%E5%BE%AA%E7%8E%AF_20201025191937-v7dsgtf.sy/</guid>
      <description>Python for 循环 Python for 循环 for循环用于在序列（列表、元组、字典、集或字符串）上迭代。 这与其他编程语言中的 for关键字不同，它的工作方式更像其他面向对象的编程语言中的一个引用器方法。 使用for循环，我们可以执行一组语句，一次用于列表、元组、集等中的每一项。 例子 在水果列表中打印每个水果： fruits =</description>
    </item>
    
    <item>
      <title>Python基础：Python 循环</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 25 Oct 2020 18:50:04 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%BE%AA%E7%8E%AF/</guid>
      <description>Python 循环 Python 循环 Python 有两个基元循环命令： while loops for loops while 循环 使用while 循环，我们可以执行一组语句，只要条件为 true。 例子 打印 i 只要 i 小于 6： i = 1 while i &amp;lt; 6: print(i) i += 1 注意：请记住增加 i，否则循环将永远继续。 while 循环需要相关变量准备就绪，在此示例中，我们需要定义一个索引变量i，我们将其设置为 1</description>
    </item>
    
    <item>
      <title>Python基础：Python 循环</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%BE%AA%E7%8E%AF_20201025191937-umw8hbc.sy/</link>
      <pubDate>Sun, 25 Oct 2020 18:50:04 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%BE%AA%E7%8E%AF_20201025191937-umw8hbc.sy/</guid>
      <description>Python 循环 Python 循环 Python 有两个基元循环命令： while loops for loops while 循环 使用while 循环，我们可以执行一组语句，只要条件为 true。 例子 打印 i 只要 i 小于 6： i = 1 while i &amp;lt; 6: print(i) i += 1 注意：请记住增加 i，否则循环将永远继续。 while 循环需要相关变量准备就绪，在此示例中，我们需要定义一个索引变量i，我们将其设置为 1</description>
    </item>
    
    <item>
      <title>Python基础：Python If 语句</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-If-%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 25 Oct 2020 18:48:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-If-%E8%AF%AD%E5%8F%A5/</guid>
      <description>Python If 语句 Python 条件和 If 语句 Python 支持数学中通常的逻辑条件： 等于： a = b 不等于： a ！ = b 小于： &amp;lt; b 小于或等于：&amp;lt;= b 大于：a &amp;gt; b 大于或等于：&amp;gt;= b 这些条件可以通过多种方式使用，最常见的是&amp;rdquo;if 语句&amp;rdquo;和循环。 使用 if 关键字编写&amp;rdquo;if语句&amp;rdqu</description>
    </item>
    
    <item>
      <title>Python基础：Python If 语句</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-If-%E8%AF%AD%E5%8F%A5_20201025191937-ohar3w0.sy/</link>
      <pubDate>Sun, 25 Oct 2020 18:48:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-If-%E8%AF%AD%E5%8F%A5_20201025191937-ohar3w0.sy/</guid>
      <description>Python If 语句 Python 条件和 If 语句 Python 支持数学中通常的逻辑条件： 等于： a = b 不等于： a ！ = b 小于： &amp;lt; b 小于或等于：&amp;lt;= b 大于：a &amp;gt; b 大于或等于：&amp;gt;= b 这些条件可以通过多种方式使用，最常见的是&amp;rdquo;if 语句&amp;rdquo;和循环。 使用 if 关键字编写&amp;rdquo;if语句&amp;rdqu</description>
    </item>
    
    <item>
      <title>Python基础：Python词典</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%8D%E5%85%B8/</link>
      <pubDate>Sun, 25 Oct 2020 17:12:47 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%8D%E5%85%B8/</guid>
      <description>Python词典 字典 字典是无序、可更改和索引的集合。在 Python 字典中，用大括号编写，它们具有键和值。 例子 创建和打印字典： thisdict = { &amp;quot;brand&amp;quot;: &amp;quot;Ford&amp;quot;, &amp;quot;model&amp;quot;: &amp;quot;Mustang&amp;quot;, &amp;quot;year&amp;quot;: 1964 } print(thisdict) 访问项目 您可以通过引用字典的键名称（方括号内）来访问字典的项： 例子 获取&amp;rdquo;模型&amp;rdquo;键的值： x = thisdict[&amp;quot;model&amp;quot;] 还有一种称为方法，该方法将为</description>
    </item>
    
    <item>
      <title>Python基础：Python词典</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%8D%E5%85%B8_20201025191937-e8ryb6l.sy/</link>
      <pubDate>Sun, 25 Oct 2020 17:12:47 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%8D%E5%85%B8_20201025191937-e8ryb6l.sy/</guid>
      <description>Python词典 字典 字典是无序、可更改和索引的集合。在 Python 字典中，用大括号编写，它们具有键和值。 例子 创建和打印字典： thisdict = { &amp;quot;brand&amp;quot;: &amp;quot;Ford&amp;quot;, &amp;quot;model&amp;quot;: &amp;quot;Mustang&amp;quot;, &amp;quot;year&amp;quot;: 1964 } print(thisdict) 访问项目 您可以通过引用字典的键名称（方括号内）来访问字典的项： 例子 获取&amp;rdquo;模型&amp;rdquo;键的值： x = thisdict[&amp;quot;model&amp;quot;] 还有一种称为方法，该方法将为</description>
    </item>
    
    <item>
      <title>Python基础：Python sets</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-sets/</link>
      <pubDate>Sun, 25 Oct 2020 17:10:41 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-sets/</guid>
      <description>Python sets 设置 sets是无序和未编制索引的 sets合。在 Python 中， sets用大括号编写。 例子 创建 sets： thisset = {&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;} print(thisset) 注： sets是无序的，因此您无法确定项目按什么顺序显示。 访问项目 不能通过引用索引或键来访问 sets合中的项。 但是，您可以使用 循环遍历 sets项，或使用 关键字询问 sets合中</description>
    </item>
    
    <item>
      <title>Python基础：Python sets</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-sets_20201025191937-u9sbpd0.sy/</link>
      <pubDate>Sun, 25 Oct 2020 17:10:41 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-sets_20201025191937-u9sbpd0.sy/</guid>
      <description>Python sets 设置 sets是无序和未编制索引的 sets合。在 Python 中， sets用大括号编写。 例子 创建 sets： thisset = {&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;} print(thisset) 注： sets是无序的，因此您无法确定项目按什么顺序显示。 访问项目 不能通过引用索引或键来访问 sets合中的项。 但是，您可以使用 循环遍历 sets项，或使用 关键字询问 sets合中</description>
    </item>
    
    <item>
      <title>Python基础：Python tuples</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-tuples/</link>
      <pubDate>Sun, 25 Oct 2020 16:31:24 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-tuples/</guid>
      <description>Python tuples tuples tuples组是有序且不可更改的集合。在 Python tuples对中，用圆形括号书写。 例子 创建tuples组： thistuple = (&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;) print(thistuple) 访问tuples组项目 您可以通过引用方括号内的索引号来访问tuples组项： 例子 打印tuples组中的第二个项目： thistuple = (&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;) print(thistuple[1]) 负索引 负索引表示从末尾开始，指最后一</description>
    </item>
    
    <item>
      <title>Python基础：Python tuples</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-tuples_20201025191937-mts7beo.sy/</link>
      <pubDate>Sun, 25 Oct 2020 16:31:24 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-tuples_20201025191937-mts7beo.sy/</guid>
      <description>Python tuples tuples tuples组是有序且不可更改的集合。在 Python tuples对中，用圆形括号书写。 例子 创建tuples组： thistuple = (&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;) print(thistuple) 访问tuples组项目 您可以通过引用方括号内的索引号来访问tuples组项： 例子 打印tuples组中的第二个项目： thistuple = (&amp;quot;apple&amp;quot;, &amp;quot;banana&amp;quot;, &amp;quot;cherry&amp;quot;) print(thistuple[1]) 负索引 负索引表示从末尾开始，指最后一</description>
    </item>
    
    <item>
      <title>Python基础：Python列表</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%88%97%E8%A1%A8/</link>
      <pubDate>Sun, 25 Oct 2020 16:28:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%88%97%E8%A1%A8/</guid>
      <description>Python列表 Python 集合（数组） Python 编程语言有四种集合数据类型： 列表是一个有序且可更改的集合。允许重复的成员。 元组是一个有序且不可更改的集合。允许重复的成员。 Set是无序和未编制索引的集合。没有重复的成员。 字典是无序、可更改和索引的集合。没有重复的成员。 选择集合类型时，了解该类型的属</description>
    </item>
    
    <item>
      <title>Python基础：Python列表</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%88%97%E8%A1%A8_20201025191937-bvfiirn.sy/</link>
      <pubDate>Sun, 25 Oct 2020 16:28:55 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%88%97%E8%A1%A8_20201025191937-bvfiirn.sy/</guid>
      <description>Python列表 Python 集合（数组） Python 编程语言有四种集合数据类型： 列表是一个有序且可更改的集合。允许重复的成员。 元组是一个有序且不可更改的集合。允许重复的成员。 Set是无序和未编制索引的集合。没有重复的成员。 字典是无序、可更改和索引的集合。没有重复的成员。 选择集合类型时，了解该类型的属</description>
    </item>
    
    <item>
      <title>Python基础：Python运算符</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Sun, 25 Oct 2020 15:53:03 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Python运算符 Python 运算符 运算符用于对变量和值执行操作。 Python 将运算符分为以下组： 算术运算符 分配运算符 比较运算符 逻辑运算符 标识运算符 会员运算符 位运算符 Python 算术运算符 算术运算符与数值一起使用，以执行常见的数学运算： | Operator | Name | Example | | + | Addition | x + y | | - | Subtraction | x - y | | * | Multiplication | x * y | | / |</description>
    </item>
    
    <item>
      <title>Python基础：Python运算符</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%BF%90%E7%AE%97%E7%AC%A6_20201025191937-ql8wcyv.sy/</link>
      <pubDate>Sun, 25 Oct 2020 15:53:03 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%BF%90%E7%AE%97%E7%AC%A6_20201025191937-ql8wcyv.sy/</guid>
      <description>Python运算符 Python 运算符 运算符用于对变量和值执行操作。 Python 将运算符分为以下组： 算术运算符 分配运算符 比较运算符 逻辑运算符 标识运算符 会员运算符 位运算符 Python 算术运算符 算术运算符与数值一起使用，以执行常见的数学运算： | Operator | Name | Example | | + | Addition | x + y | | - | Subtraction | x - y | | * | Multiplication | x * y | | / |</description>
    </item>
    
    <item>
      <title>Python基础：Python 布尔</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%B8%83%E5%B0%94/</link>
      <pubDate>Sun, 25 Oct 2020 14:44:34 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%B8%83%E5%B0%94/</guid>
      <description>Python 布尔 布尔表示两个值之一： 或 。TrueFalse 布尔值 在编程中，您经常需要知道表达式是 或 。TrueFalse 您可以计算 Python 中的任何表达式，并获取两个答案之一，或 。TrueFalse 比较两个值时，将计算表达式，Python 返回布尔答案： 例子 print(10 &amp;gt; 9) print(10 == 9) print(10 &amp;lt; 9) 在 if 语句中运行条件时，Py</description>
    </item>
    
    <item>
      <title>Python基础：Python 布尔</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%B8%83%E5%B0%94_20201025191937-tqcrvoq.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:44:34 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%B8%83%E5%B0%94_20201025191937-tqcrvoq.sy/</guid>
      <description>Python 布尔 布尔表示两个值之一： 或 。True``False 布尔值 在编程中，您经常需要知道表达式是 或 。True``False 您可以计算 Python 中的任何表达式，并获取两个答案之一，或 。True``False 比较两个值时，将计算表达式，Python 返回布尔答案： 例子 print(10 &amp;gt; 9) print(10 == 9) print(10 &amp;lt; 9) 在 if 语句中运行</description>
    </item>
    
    <item>
      <title>Python基础：Python字符串</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 25 Oct 2020 14:42:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Python字符串 字符串 python 中的字符串文本由单个引号或双引号包围。 &amp;ldquo;你好&amp;rdquo;和&amp;rsquo;你好&amp;rsquo;是一样的。 您可以使用 以下函数显示字符串文本：print() 例子 print(&amp;quot;Hello&amp;quot;) print(&#39;Hello&#39;) 将字符串分配给变量 将字符串分配给变量使用变量名称后跟一个等号和字符串完成： 例子 a = &amp;quot;Hello&amp;quot;</description>
    </item>
    
    <item>
      <title>Python基础：Python字符串</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2_20201025191937-gjvueo0.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:42:57 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%AD%97%E7%AC%A6%E4%B8%B2_20201025191937-gjvueo0.sy/</guid>
      <description>Python字符串 字符串 python 中的字符串文本由单个引号或双引号包围。 &amp;ldquo;你好&amp;rdquo;和&amp;rsquo;你好&amp;rsquo;是一样的。 您可以使用 以下函数显示字符串文本：print() 例子 print(&amp;quot;Hello&amp;quot;) print(&#39;Hello&#39;) 将字符串分配给变量 将字符串分配给变量使用变量名称后跟一个等号和字符串完成： 例子 a = &amp;quot;Hello&amp;quot;</description>
    </item>
    
    <item>
      <title>Python基础：Python强转</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%BC%BA%E8%BD%AC/</link>
      <pubDate>Sun, 25 Oct 2020 14:39:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%BC%BA%E8%BD%AC/</guid>
      <description>Python强转 指定变量类型 有时可能需要为变量指定类型。这可以通过强转完成。Python 是一种面向对象的语言，因此它使用类来定义数据类型，包括其基元类型。 因此，使用构造函数在 python 中强制转换： int（） - 从整数文本、浮数字（通过向下舍入到上一个整数）或字符串文本（提供字符串表示整数）</description>
    </item>
    
    <item>
      <title>Python基础：Python强转</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%BC%BA%E8%BD%AC_20201025191937-jrevwbe.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:39:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%BC%BA%E8%BD%AC_20201025191937-jrevwbe.sy/</guid>
      <description>Python强转 指定变量类型 有时可能需要为变量指定类型。这可以通过强转完成。Python 是一种面向对象的语言，因此它使用类来定义数据类型，包括其基元类型。 因此，使用构造函数在 python 中强制转换： int（） - 从整数文本、浮数字（通过向下舍入到上一个整数）或字符串文本（提供字符串表示整数）</description>
    </item>
    
    <item>
      <title>Python基础：Python Numbers</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Numbers/</link>
      <pubDate>Sun, 25 Oct 2020 14:36:11 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Numbers/</guid>
      <description>Python Numbers Python Numbers Python 中有三种数字类型： * ```float``` * ```complex``` 向数值分配值时，将创建数值类型的变量： ### 例子 x = 1 # int y = 2.8 # float z = 1j # complex &amp;lt;font _mstmutation=&amp;quot;1&amp;quot; _msthash=&amp;quot;103727&amp;quot; _msttexthash=&amp;quot;185478917&amp;quot;&amp;gt;若要验证 Python 中任何对象的类型，请使用 以下函数：&amp;lt;/font&amp;gt;```type()</description>
    </item>
    
    <item>
      <title>Python基础：Python Numbers</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Numbers_20201025191937-6ky7br1.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:36:11 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-Numbers_20201025191937-6ky7br1.sy/</guid>
      <description>Python Numbers Python Numbers Python 中有三种数字类型： int float complex 向数值分配值时，将创建数值类型的变量： 例子 x = 1 # int y = 2.8 # float z = 1j # complex 若要验证 Python 中任何对象的类型，请使用 以下函数：type() 例子 print(type(x)) print(type(y)) print(type(z)) Int int 或整数是长度无限的整数，正数或负数。没有小数。 例子 整数： x = 1 y = 35656222554887711 z = -3255522 print(type(x)) print(type(y)) print(type(z)) Float 浮动或&amp;rdquo;浮</description>
    </item>
    
    <item>
      <title>Python基础：Python数据类型</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sun, 25 Oct 2020 14:34:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Python数据类型 内置数据类型 在编程中，数据类型是一个重要的概念。 变量可以存储不同类型的数据，不同类型的变量可以处理不同的事情。 默认情况下，Python 具有以下内置的数据类型，这些类别： | 文本类型： | str | | 数字类型： | int, ,floatcomplex | | 序列类型： | list, ,tuplerange | | 映射类型： | dict | | 设置类型： | set,frozenset</description>
    </item>
    
    <item>
      <title>Python基础：Python数据类型</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_20201025191937-xyavg30.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:34:10 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_20201025191937-xyavg30.sy/</guid>
      <description>Python数据类型 内置数据类型 在编程中，数据类型是一个重要的概念。 变量可以存储不同类型的数据，不同类型的变量可以处理不同的事情。 默认情况下，Python 具有以下内置的数据类型，这些类别： | 文本类型： | str | | 数字类型： | int, ,floatcomplex`` | | 序列类型： | ``list``&amp;lt;font _mstmutation=&amp;quot;1&amp;quot; _msthash=&amp;quot;752700&amp;quot; _msttexthash=&amp;quot;8580&amp;quot;&amp;gt;, ,&amp;lt;/font&amp;gt;``tuplerange | | 映射类型： | dict | | 设置类型</description>
    </item>
    
    <item>
      <title>Python基础：Python变量</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%8F%98%E9%87%8F/</link>
      <pubDate>Sun, 25 Oct 2020 14:32:32 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%8F%98%E9%87%8F/</guid>
      <description>Python变量 创建变量 变量是用于存储数据值的容器。 与其他编程语言不同，Python 没有声明变量的命令。 变量在您首次为其分配值时创建。 例子 x = 5 y = &amp;quot;John&amp;quot; print(x) print(y) 变量不需要用任何特定类型声明_，_甚至可以在设置后更改类型。 例子 x = 4 # x is of type int x = &amp;quot;Sally&amp;quot; # x is now of type str print(x) 可以使用单引号或双引号</description>
    </item>
    
    <item>
      <title>Python基础：Python变量</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%8F%98%E9%87%8F_20201025191937-xec8pf1.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:32:32 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E5%8F%98%E9%87%8F_20201025191937-xec8pf1.sy/</guid>
      <description>Python变量 创建变量 变量是用于存储数据值的容器。 与其他编程语言不同，Python 没有声明变量的命令。 变量在您首次为其分配值时创建。 例子 x = 5 y = &amp;quot;John&amp;quot; print(x) print(y) 变量不需要用任何特定类型声明_，_甚至可以在设置后更改类型。 例子 x = 4 # x is of type int x = &amp;quot;Sally&amp;quot; # x is now of type str print(x) 可以使用单引号或双引号</description>
    </item>
    
    <item>
      <title>Python基础：Python注释</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Sun, 25 Oct 2020 14:29:22 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%B3%A8%E9%87%8A/</guid>
      <description>Python注释 注释可用于解释 Python 代码。 注释可用于使代码更具可读性。 注释可用于在测试代码时阻止执行。 创建注释 注释以 开头，Python 将忽略它们：# 例子 #This is a comment print(&amp;quot;Hello, World!&amp;quot;) 注释可以放在行的末尾，Python 将忽略行的其余部分： 例子 print(&amp;quot;Hello, World!&amp;quot;) #This is a comment 注释不必是文本来解释代码，它也可以用来防止 Python 执行代</description>
    </item>
    
    <item>
      <title>Python基础：Python注释</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%B3%A8%E9%87%8A_20201025191937-jektmye.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:29:22 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E6%B3%A8%E9%87%8A_20201025191937-jektmye.sy/</guid>
      <description>Python注释 注释可用于解释 Python 代码。 注释可用于使代码更具可读性。 注释可用于在测试代码时阻止执行。 创建注释 注释以 开头，Python 将忽略它们：# 例子 #This is a comment print(&amp;quot;Hello, World!&amp;quot;) 注释可以放在行的末尾，Python 将忽略行的其余部分： 例子 print(&amp;quot;Hello, World!&amp;quot;) #This is a comment 注释不必是文本来解释代码，它也可以用来防止 Python 执行代</description>
    </item>
    
    <item>
      <title>Python基础：Python语法</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 25 Oct 2020 14:27:46 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%AD%E6%B3%95/</guid>
      <description>Python语法 执行 Python 语法 Python 缩进 Python 变量 Python 注释 练习 执行 Python 语法 正如我们在上一页中学到的，Python 语法可以通过直接在命令行中写入来执行： &amp;gt;&amp;gt;&amp;gt; print(&amp;quot;Hello, World!&amp;quot;) Hello, World! 或者，在服务器上创建 python 文件，使用 .py 文件扩展名，并在命令行中运行该文件： C:\Users\_Your Name_&amp;gt;python myfile.py Python 缩进 缩进是指代码行开头的空格。 在其他编程语言中，代码中的缩</description>
    </item>
    
    <item>
      <title>Python基础：Python语法</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%AD%E6%B3%95_20201025191937-jwjl0s6.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:27:46 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python%E8%AF%AD%E6%B3%95_20201025191937-jwjl0s6.sy/</guid>
      <description>Python语法 执行 Python 语法 Python 缩进 Python 变量 Python 注释 练习 执行 Python 语法 正如我们在上一页中学到的，Python 语法可以通过直接在命令行中写入来执行： &amp;gt;&amp;gt;&amp;gt; print(&amp;quot;Hello, World!&amp;quot;) Hello, World! 或者，在服务器上创建 python 文件，使用 .py 文件扩展名，并在命令行中运行该文件： C:\Users\_Your Name_&amp;gt;python myfile.py Python 缩进 缩进是指代码行开头的空格。 在其他编程语言中，代码中的缩</description>
    </item>
    
    <item>
      <title>Python基础：Python 入门</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Sun, 25 Oct 2020 14:25:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%85%A5%E9%97%A8/</guid>
      <description>Python 入门 Python 安装 许多 PC 和 Mac 将安装 python。 要检查是否安装了 Python 在 Windows PC 上，请在开始栏中搜索 Python 或在命令行 （cmd.exe） 上运行以下内容： C:\Users\_Your Name_&amp;gt;python --version 要检查您是否在 Linux 或 Mac 上安装了 python，然后在 linux 上打开命令行或在 Mac 上打开终端并键入： python --version 如果您发现您的计算机上没有安装 python，那么您可</description>
    </item>
    
    <item>
      <title>Python基础：Python 入门</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%85%A5%E9%97%A8_20201025191937-h0sqbmg.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:25:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E5%85%A5%E9%97%A8_20201025191937-h0sqbmg.sy/</guid>
      <description>Python 入门 Python 安装 许多 PC 和 Mac 将安装 python。 要检查是否安装了 Python 在 Windows PC 上，请在开始栏中搜索 Python 或在命令行 （cmd.exe） 上运行以下内容： C:\Users\_Your Name_&amp;gt;python --version 要检查您是否在 Linux 或 Mac 上安装了 python，然后在 linux 上打开命令行或在 Mac 上打开终端并键入： python --version 如果您发现您的计算机上没有安装 python，那么您可</description>
    </item>
    
    <item>
      <title>Python基础：Python 语法</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 25 Oct 2020 14:02:27 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E8%AF%AD%E6%B3%95/</guid>
      <description>[](#python-syntax)Python 语法 与其他编程语言相比，Python 语法 Python 旨在实现可读性，与受数学影响的英语有一些相似之处。 Python 使用新行来完成命令，而不是经常使用分号或括号的其他编程语言。 Python 依靠缩进，使用空格来定义范围;例如循环、函数和类的范围。其他编程语言通常使用大括号来用于此目的。 [](#python-indentations)Python 缩进 在其他编程语言中，代</description>
    </item>
    
    <item>
      <title>Python基础：Python 语法</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E8%AF%AD%E6%B3%95_20201025191937-cmx7x8c.sy/</link>
      <pubDate>Sun, 25 Oct 2020 14:02:27 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80Python-%E8%AF%AD%E6%B3%95_20201025191937-cmx7x8c.sy/</guid>
      <description>[](#python-syntax)Python 语法 与其他编程语言相比，Python 语法 Python 旨在实现可读性，与受数学影响的英语有一些相似之处。 Python 使用新行来完成命令，而不是经常使用分号或括号的其他编程语言。 Python 依靠缩进，使用空格来定义范围;例如循环、函数和类的范围。其他编程语言通常使用大括号来用于此目的。 [](#python-indentations)Python 缩进 在其他编程语言中，代</description>
    </item>
    
    <item>
      <title>Python基础：什么是 Python</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80%E4%BB%80%E4%B9%88%E6%98%AF-Python/</link>
      <pubDate>Sun, 25 Oct 2020 13:50:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80%E4%BB%80%E4%B9%88%E6%98%AF-Python/</guid>
      <description>[](#what-is-python)什么是 Python Python 是一种流行的编程语言。它由吉多·范·罗森于1991年创建。 Python 是一种易于学习、功能强大的编程语言。它有高效的高级数据结构，以及一种简单而有效的面向对象的编程方法。Python 优雅的语法和动态类型，加上其解释性，使其成为大多数平台上许多</description>
    </item>
    
    <item>
      <title>Python基础：什么是 Python</title>
      <link>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80%E4%BB%80%E4%B9%88%E6%98%AF-Python_20201025191937-0lc4hvr.sy/</link>
      <pubDate>Sun, 25 Oct 2020 13:50:05 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/python/Python%E5%9F%BA%E7%A1%80%E4%BB%80%E4%B9%88%E6%98%AF-Python_20201025191937-0lc4hvr.sy/</guid>
      <description>[](#what-is-python)什么是 Python Python 是一种流行的编程语言。它由吉多·范·罗森于1991年创建。 Python 是一种易于学习、功能强大的编程语言。它有高效的高级数据结构，以及一种简单而有效的面向对象的编程方法。Python 优雅的语法和动态类型，加上其解释性，使其成为大多数平台上许多</description>
    </item>
    
    <item>
      <title>机器学习：交互式机器学习体验</title>
      <link>https://geek.zshipu.com/post/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sun, 25 Oct 2020 13:39:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%93%E9%AA%8C/</guid>
      <description>我已经在 GitHub 上🤖了新的交互式机器学习实验项目。 虽然模型可能有点笨（记住，这些只是实验，而不是生产就绪的代码），他们会尽力： 🖌识别在浏览器中绘制的数字或草图 📸检测和识别要显示给相机的对象 🌅对上传的图像进行分类 📝一起写一首莎士比亚诗 ✊🖐✌️玩你在摇滚纸剪刀游戏 等。 我已经训练了_Pyth</description>
    </item>
    
    <item>
      <title>JavaScript基础：为初学者学习 JavaScript 中的数据结构</title>
      <link>https://geek.zshipu.com/post/java/JavaScript%E5%9F%BA%E7%A1%80%E4%B8%BA%E5%88%9D%E5%AD%A6%E8%80%85%E5%AD%A6%E4%B9%A0-JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 25 Oct 2020 13:32:14 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/JavaScript%E5%9F%BA%E7%A1%80%E4%B8%BA%E5%88%9D%E5%AD%A6%E8%80%85%E5%AD%A6%E4%B9%A0-JavaScript-%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>介绍 它是 JavaScript 中学习数据结构的注释。我研究了长途跋涉的Github 存储库的源代码表单。对于JavaScript开发人员和初学者来说，这是一个很好的材料来学习数据结构。 除了Trekhleb的 Github， 我还提到《离开： 乌迪米编程和编码采访》和哈克兰克的视频。本课程使用 Java 实现和解释数据</description>
    </item>
    
    <item>
      <title>MySql Text 类型大小</title>
      <link>https://geek.zshipu.com/post/mysql/MySql-Text-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Wed, 21 Oct 2020 20:38:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/mysql/MySql-Text-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F/</guid>
      <description>| TINYTEXT | 256 bytes | | | TEXT | 65,535 bytes | ~64kb | | MEDIUMTEXT | 16,777,215 bytes | ~16MB | | LONGTEXT | 4,294,967,295 bytes | ~4GB |</description>
    </item>
    
    <item>
      <title>MySql Text 类型大小</title>
      <link>https://geek.zshipu.com/post/mysql/MySql-Text-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F_20201025191937-k26ptu2.sy/</link>
      <pubDate>Wed, 21 Oct 2020 20:38:39 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/mysql/MySql-Text-%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F_20201025191937-k26ptu2.sy/</guid>
      <description>| TINYTEXT | 256 bytes | | | TEXT | 65,535 bytes | ~64kb | | MEDIUMTEXT | 16,777,215 bytes | ~16MB | | LONGTEXT | 4,294,967,295 bytes | ~4GB |</description>
    </item>
    
    <item>
      <title>Java编程：你需要学习多少Java才能找到第一份工作？</title>
      <link>https://geek.zshipu.com/post/java/Java%E7%BC%96%E7%A8%8B%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%A4%9A%E5%B0%91Java%E6%89%8D%E8%83%BD%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Mon, 19 Oct 2020 22:20:45 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/Java%E7%BC%96%E7%A8%8B%E4%BD%A0%E9%9C%80%E8%A6%81%E5%AD%A6%E4%B9%A0%E5%A4%9A%E5%B0%91Java%E6%89%8D%E8%83%BD%E6%89%BE%E5%88%B0%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%B7%A5%E4%BD%9C/</guid>
      <description>潜在的 Java 低年级学生需要了解什么才能获得第一份工作，甚至有资格获得好公司的实习生职位？哪些工具可以帮助Java程序员达到一个新的水平？您应该学习哪些技术，哪些技术最好推迟？ 这些问题没有标准答案，就像没有一个行动计划绝对适合每个人一样。一些公司正在争取开发，不断引进新技术，测试新版本</description>
    </item>
    
    <item>
      <title>高效的DevOps：2021 年要关注的关键 DevOps 原则</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps2021-%E5%B9%B4%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%85%B3%E9%94%AE-DevOps-%E5%8E%9F%E5%88%99/</link>
      <pubDate>Tue, 13 Oct 2020 22:53:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps2021-%E5%B9%B4%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%85%B3%E9%94%AE-DevOps-%E5%8E%9F%E5%88%99/</guid>
      <description>2021 年 8个开发原则 变革需要创新，创新需要进步。这是经过考验的方法，也是构建成功组织的关键。软件行业一次又一次地受到一波挑战性需求的打击，要求达到市场标准。为了跟上不断变化的趋势，组织开始采用新的流程。其中一种方法就是 DevOps。 什么是 DevOps？ DevOps 背后的主要理念是将两个松散连接</description>
    </item>
    
    <item>
      <title>高效的DevOps：2021 年要关注的关键 DevOps 原则</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps2021-%E5%B9%B4%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%85%B3%E9%94%AE-DevOps-%E5%8E%9F%E5%88%99_20201025191937-h39z8na.sy/</link>
      <pubDate>Tue, 13 Oct 2020 22:53:56 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps2021-%E5%B9%B4%E8%A6%81%E5%85%B3%E6%B3%A8%E7%9A%84%E5%85%B3%E9%94%AE-DevOps-%E5%8E%9F%E5%88%99_20201025191937-h39z8na.sy/</guid>
      <description>2021 年 8个开发原则 变革需要创新，创新需要进步。这是经过考验的方法，也是构建成功组织的关键。软件行业一次又一次地受到一波挑战性需求的打击，要求达到市场标准。为了跟上不断变化的趋势，组织开始采用新的流程。其中一种方法就是 DevOps。 什么是 DevOps？ DevOps 背后的主要理念是将两个松散连接</description>
    </item>
    
    <item>
      <title>高效的DevOps：30 多个开源工具，用于构建 DevOps 安全性。第 1 部分</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps30-%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA-DevOps-%E5%AE%89%E5%85%A8%E6%80%A7%E7%AC%AC-1-%E9%83%A8%E5%88%86/</link>
      <pubDate>Tue, 13 Oct 2020 22:50:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps30-%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA-DevOps-%E5%AE%89%E5%85%A8%E6%80%A7%E7%AC%AC-1-%E9%83%A8%E5%88%86/</guid>
      <description>新的安全工具没有时间成为快速增长的实践集的一部分，这使我想将某个检查点设置为工具列表。 实践意味着一组措施可以内置到 SDLC/DevOps 的阶段之一（威胁建模、SAST、DAST、SCA、Docker 图像扫描、Kubernetes 扫描、AWS 审核等）。 1.威胁建模 因此，安全开发生命周期环境中的威胁建模</description>
    </item>
    
    <item>
      <title>高效的DevOps：30 多个开源工具，用于构建 DevOps 安全性。第 1 部分</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps30-%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA-DevOps-%E5%AE%89%E5%85%A8%E6%80%A7%E7%AC%AC-1-%E9%83%A8%E5%88%86_20201025191937-za4nsls.sy/</link>
      <pubDate>Tue, 13 Oct 2020 22:50:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps30-%E5%A4%9A%E4%B8%AA%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E7%94%A8%E4%BA%8E%E6%9E%84%E5%BB%BA-DevOps-%E5%AE%89%E5%85%A8%E6%80%A7%E7%AC%AC-1-%E9%83%A8%E5%88%86_20201025191937-za4nsls.sy/</guid>
      <description>新的安全工具没有时间成为快速增长的实践集的一部分，这使我想将某个检查点设置为工具列表。 实践意味着一组措施可以内置到 SDLC/DevOps 的阶段之一（威胁建模、SAST、DAST、SCA、Docker 图像扫描、Kubernetes 扫描、AWS 审核等）。 ![Image for post](https://miro.medium.com/max/3960/0*RPwsDSA6nOOOkcn3.png) 1.威胁建模 因此，安全开发生命周期环境中的威</description>
    </item>
    
    <item>
      <title>高效的DevOps：业务开发操作的三种方式框架方法</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%A1%86%E6%9E%B6%E6%96%B9%E6%B3%95/</link>
      <pubDate>Tue, 13 Oct 2020 22:45:38 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%A1%86%E6%9E%B6%E6%96%B9%E6%B3%95/</guid>
      <description>在寻求公司以提高 IT 交付服务的敏捷性时，出现了一种名为 DevOps 的 IT 行业趋势。在这里，我们将探讨在 IT 业务中应用树方法框架方法。 什么是 DevOps？ 如前所述，DevOps 是 IT 行业旨在提高 IT 交付服务敏捷性的新趋势。此举强调透明通信、协作以及开发人员软件和 IT 运营之间的集成。 DevOps 认识到开发人员和 IT 操</description>
    </item>
    
    <item>
      <title>高效的DevOps：业务开发操作的三种方式框架方法</title>
      <link>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%A1%86%E6%9E%B6%E6%96%B9%E6%B3%95_20201025191937-u7qj5tb.sy/</link>
      <pubDate>Tue, 13 Oct 2020 22:45:38 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/devops/%E9%AB%98%E6%95%88%E7%9A%84DevOps%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E6%93%8D%E4%BD%9C%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E6%A1%86%E6%9E%B6%E6%96%B9%E6%B3%95_20201025191937-u7qj5tb.sy/</guid>
      <description>在寻求公司以提高 IT 交付服务的敏捷性时，出现了一种名为 DevOps 的 IT 行业趋势。在这里，我们将探讨在 IT 业务中应用树方法框架方法。 什么是 DevOps？ 如前所述，DevOps 是 IT 行业旨在提高 IT 交付服务敏捷性的新趋势。此举强调透明通信、协作以及开发人员软件和 IT 运营之间的集成。 DevOps 认识到开发人员和 IT 操</description>
    </item>
    
    <item>
      <title>Golang实践：使用 Go &#43; 第 2 部分创建 RESTful 服务</title>
      <link>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-Go-&#43;-%E7%AC%AC-2-%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA-RESTful-%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 13 Oct 2020 22:35:06 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-Go-&#43;-%E7%AC%AC-2-%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA-RESTful-%E6%9C%8D%E5%8A%A1/</guid>
      <description>什么是 RESTful 服务？ REST 是一种用于设计 Web 服务的体系结构方法。REST API 是围绕_资源_设计的，资源是客户端可以访问的任何类型的对象、数据或服务。资源具有标识符_，_它是唯一标识该资源的 URI。例如，特定客户订单的 URI 可能是： https://adventure-works.com/orders/1 客户端通过交换资源表示形式_与服务_交互。许多 Web API 使用 JSON（当</description>
    </item>
    
    <item>
      <title>Golang实践：使用 Go&#43; 第 1 部分创建微服务</title>
      <link>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-Go&#43;-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Tue, 13 Oct 2020 22:32:37 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5%E4%BD%BF%E7%94%A8-Go&#43;-%E7%AC%AC-1-%E9%83%A8%E5%88%86%E5%88%9B%E5%BB%BA%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
      <description>来自JavaScript的背景，我一直想学习一种静态类型的编程语言，今年早些时候，我拿起Golang后，阅读了有关语言的评论，Golang得到了谷歌的支持。哦， 当然， 流行的 Devops 工具， 如码头， 库伯内特， Terraform， 是用Golang建造的。在通过 freecodecamp 从这个令人敬畏的教程中选取基础</description>
    </item>
    
    <item>
      <title>Golang实践：Golang的 3 个陷阱</title>
      <link>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5Golang%E7%9A%84-3-%E4%B8%AA%E9%99%B7%E9%98%B1/</link>
      <pubDate>Tue, 13 Oct 2020 22:20:16 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E8%B7%B5Golang%E7%9A%84-3-%E4%B8%AA%E9%99%B7%E9%98%B1/</guid>
      <description>在过去的一年里，我们一直在开发一个复杂的半实时生产系统。我们决定和Golang一起写。我们在 Go 中几乎没有经验，所以正如你想象的那样，这不是一件小事。 快进一年：该系统在生产中运行，并成为CllimaCell产品的主要支柱之一。 精通意味着你有足够的经验来知道你正在使用的平台的陷阱是什</description>
    </item>
    
    <item>
      <title>Golang基础：go语言中的循环</title>
      <link>https://geek.zshipu.com/post/go/Golang%E5%9F%BA%E7%A1%80go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sun, 11 Oct 2020 21:56:25 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E5%9F%BA%E7%A1%80go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/</guid>
      <description>循环允许您重复代码。有不同类型的循环，其中之一是 for 循环。对于Go（golang）中的循环，与 Python 更类似于 C/Java。在 Python 中，语法是 for i in range(1,10): 在 C/Java 中，语法为 for (i = 1; i &amp;lt;= 10; i++) { 但在Golang for i := 1; i &amp;lt;= 10; i++ { 因此，它受到这些语言的启发。 [](#for-loop-explained)For 循环解释 在上面的程序中，它是什么意思？ 首先变量</description>
    </item>
    
    <item>
      <title>Golang实战：细胞吞噬</title>
      <link>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E6%88%98%E7%BB%86%E8%83%9E%E5%90%9E%E5%99%AC/</link>
      <pubDate>Sun, 11 Oct 2020 21:50:17 +0800</pubDate>
      
      <guid>https://geek.zshipu.com/post/go/Golang%E5%AE%9E%E6%88%98%E7%BB%86%E8%83%9E%E5%90%9E%E5%99%AC/</guid>
      <description>细胞吞噬游戏是一_个细胞自动_机， 但这并没有意味着很多， 大多数人。想象一下，一个存在于两种状态的细胞网格：活着或死亡。您看到的&amp;rdquo;动画&amp;rdquo;实际上是连续几代呈现在屏幕上。有四个规则可以帮助决定下一代的状态。维基百科这样描述它们。 任何只有不到两个活邻居的活细胞死亡</description>
    </item>
    
    <item>
      <title>开发日常：nginx ip_hash 作用</title>
      <link>https://geek.zshipu.com/post/linux/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8nginx-ip_hash-%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Sat, 10 Oct 2020 17:41:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/linux/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8nginx-ip_hash-%E4%BD%9C%E7%94%A8/</guid>
      <description>_nginx_负载均衡策略:_ip_hash_、url_hash_xqhys的博客-CS&amp;hellip; 2018年8月18日 上述是一个极简的监听8081端口的的_nginx_服务,其中当请求url 为/Upload/upload时,会走_ip_hash_策略; upstream是_n</description>
    </item>
    
    <item>
      <title>开发日常：nginx ip_hash 作用</title>
      <link>https://geek.zshipu.com/post/linux/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8nginx-ip_hash-%E4%BD%9C%E7%94%A8_20201025191937-qkl1b8w.sy/</link>
      <pubDate>Sat, 10 Oct 2020 17:41:10 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/linux/%E5%BC%80%E5%8F%91%E6%97%A5%E5%B8%B8nginx-ip_hash-%E4%BD%9C%E7%94%A8_20201025191937-qkl1b8w.sy/</guid>
      <description>_nginx_负载均衡策略:_ip_hash_、url_hash_xqhys的博客-CS&amp;hellip; 2018年8月18日 上述是一个极简的监听8081端口的的_nginx_服务,其中当请求url 为/Upload/upload时,会走_ip_hash_策略; upstream是_n</description>
    </item>
    
    <item>
      <title>掘金 2020年10月09日技术热点</title>
      <link>https://geek.zshipu.com/post/news/%E6%8E%98%E9%87%91-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E7%83%AD%E7%82%B9/</link>
      <pubDate>Fri, 09 Oct 2020 22:05:06 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E6%8E%98%E9%87%91-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E7%83%AD%E7%82%B9/</guid>
      <description>[原理02] 权限控制 1天内 掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。掘金的技术文章由稀土上聚集的技&amp;hellip; 面试题 | 链表相交 &amp;amp; 成环 1天内 掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用</description>
    </item>
    
    <item>
      <title>掘金 2020年10月09日技术热点</title>
      <link>https://geek.zshipu.com/post/news/%E6%8E%98%E9%87%91-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E7%83%AD%E7%82%B9_20201025191937-isvga8i.sy/</link>
      <pubDate>Fri, 09 Oct 2020 22:05:06 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E6%8E%98%E9%87%91-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E7%83%AD%E7%82%B9_20201025191937-isvga8i.sy/</guid>
      <description>[原理02] 权限控制 1天内 掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用的 Designer News,和给产品经理用的 Medium。掘金的技术文章由稀土上聚集的技&amp;hellip; 面试题 | 链表相交 &amp;amp; 成环 1天内 掘金是一个帮助开发者成长的社区,是给开发者用的 Hacker News,给设计师用</description>
    </item>
    
    <item>
      <title>CSDN 2020年10月09日热门技术点</title>
      <link>https://geek.zshipu.com/post/news/CSDN-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E7%83%AD%E9%97%A8%E6%8A%80%E6%9C%AF%E7%82%B9/</link>
      <pubDate>Fri, 09 Oct 2020 22:04:21 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/CSDN-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E7%83%AD%E9%97%A8%E6%8A%80%E6%9C%AF%E7%82%B9/</guid>
      <description>【Docker介绍及简单操作】_追梦的博客-CSDN博客 6小时前 一、Docker1、简介Docker 是一个开源的容器引擎,它基于 LXC 容器技术,使用 Go 语言开发源代码托管在 GitHub 上,并遵从 Apache2.0 协议Docker 采用 C/S架构,其&amp;hellip; 全球顶级开源大神们现身 COSCon&amp;rsquo;20-CSDN.NET 11小时前 业界最具影响力的</description>
    </item>
    
    <item>
      <title>CSDN 2020年10月09日热门技术点</title>
      <link>https://geek.zshipu.com/post/news/CSDN-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E7%83%AD%E9%97%A8%E6%8A%80%E6%9C%AF%E7%82%B9_20201025191937-vrv2b68.sy/</link>
      <pubDate>Fri, 09 Oct 2020 22:04:21 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/CSDN-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E7%83%AD%E9%97%A8%E6%8A%80%E6%9C%AF%E7%82%B9_20201025191937-vrv2b68.sy/</guid>
      <description>【Docker介绍及简单操作】_追梦的博客-CSDN博客 6小时前 一、Docker1、简介Docker 是一个开源的容器引擎,它基于 LXC 容器技术,使用 Go 语言开发源代码托管在 GitHub 上,并遵从 Apache2.0 协议Docker 采用 C/S架构,其&amp;hellip; 全球顶级开源大神们现身 COSCon&amp;rsquo;20-CSDN.NET 11小时前 业界最具影响力的</description>
    </item>
    
    <item>
      <title>开源中国 2020年10月09日技术要点</title>
      <link>https://geek.zshipu.com/post/news/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</link>
      <pubDate>Fri, 09 Oct 2020 22:01:48 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</guid>
      <description>QSettings 自定义格式 - OSCHINA 5小时前 转自:http://hi.baidu.com/cyclone/blog/item/1bcb5edfed60d20348540320.html 早就注意到 QSettings 提供了自定义配置文件格式的功能,却一直没怎么看&amp;hellip; PHP 开源工作流引擎 Tpflow V3.2 正式版发布 - OSCHIN&amp;hellip; 1天内 PHP</description>
    </item>
    
    <item>
      <title>开源中国 2020年10月09日技术要点</title>
      <link>https://geek.zshipu.com/post/news/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9_20201025191937-2c9ptao.sy/</link>
      <pubDate>Fri, 09 Oct 2020 22:01:48 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E5%BC%80%E6%BA%90%E4%B8%AD%E5%9B%BD-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9_20201025191937-2c9ptao.sy/</guid>
      <description>QSettings 自定义格式 - OSCHINA 5小时前 转自:http://hi.baidu.com/cyclone/blog/item/1bcb5edfed60d20348540320.html 早就注意到 QSettings 提供了自定义配置文件格式的功能,却一直没怎么看&amp;hellip; PHP 开源工作流引擎 Tpflow V3.2 正式版发布 - OSCHIN&amp;hellip; 1天内 PHP</description>
    </item>
    
    <item>
      <title>思否 2020年10月09日技术要点</title>
      <link>https://geek.zshipu.com/post/news/%E6%80%9D%E5%90%A6-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</link>
      <pubDate>Fri, 09 Oct 2020 22:00:27 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E6%80%9D%E5%90%A6-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9/</guid>
      <description>JavaScript计时器:你需要了解的所有内容_疯狂的技术宅&amp;hellip; 6小时前 作者:Samer Buna翻译:疯狂的技术宅原文:[链接]未经允许严禁转载先从一个面试题开始:JavaScript 面试题:setTimeout 和 setInterval 的源代码是在哪里实现的? (不&amp;hellip; 台达P</description>
    </item>
    
    <item>
      <title>思否 2020年10月09日技术要点</title>
      <link>https://geek.zshipu.com/post/news/%E6%80%9D%E5%90%A6-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9_20201025191937-2euokft.sy/</link>
      <pubDate>Fri, 09 Oct 2020 22:00:27 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/news/%E6%80%9D%E5%90%A6-2020%E5%B9%B410%E6%9C%8809%E6%97%A5%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9_20201025191937-2euokft.sy/</guid>
      <description>JavaScript计时器:你需要了解的所有内容_疯狂的技术宅&amp;hellip; 6小时前 作者:Samer Buna翻译:疯狂的技术宅原文:[链接]未经允许严禁转载先从一个面试题开始:JavaScript 面试题:setTimeout 和 setInterval 的源代码是在哪里实现的? (不&amp;hellip; 台达P</description>
    </item>
    
    <item>
      <title>Java 线程 热点文章 2020年10月09日</title>
      <link>https://geek.zshipu.com/post/java/Java-%E7%BA%BF%E7%A8%8B-%E7%83%AD%E7%82%B9%E6%96%87%E7%AB%A0-2020%E5%B9%B410%E6%9C%8809%E6%97%A5/</link>
      <pubDate>Fri, 09 Oct 2020 21:58:33 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/Java-%E7%BA%BF%E7%A8%8B-%E7%83%AD%E7%82%B9%E6%96%87%E7%AB%A0-2020%E5%B9%B410%E6%9C%8809%E6%97%A5/</guid>
      <description>_Java_多_线程__yucan1234的博客-CSDN博客 11小时前 1.在第二种方法(Runnable)中,ticket输出的顺序并不是54321,这是因为_线程_执行的时机难以预测,ticket–并不是原子操作。 2.在第一种方法中,我们new了3个Thread对&amp;helli</description>
    </item>
    
    <item>
      <title>CSS 热点文章：2020年9月第三周</title>
      <link>https://geek.zshipu.com/post/css/CSS-%E7%83%AD%E7%82%B9%E6%96%87%E7%AB%A02020%E5%B9%B49%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8/</link>
      <pubDate>Sun, 20 Sep 2020 20:41:20 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/css/CSS-%E7%83%AD%E7%82%B9%E6%96%87%E7%AB%A02020%E5%B9%B49%E6%9C%88%E7%AC%AC%E4%B8%89%E5%91%A8/</guid>
      <description>前端之_CSS_篇 - NQ31 - 博客园 1天前 /内部样式/ Title p{ background-color: red; } /外部样式 将_css_代码写在单独的文件中,再进行引用/ /行内样式/ hello world&amp;hellip; CSS-01入门和语法,选择器。_qq_44715164的博客-CSDN博客 2天前 _css_简单介绍CSS:Cascading Style Sheets:层叠样式</description>
    </item>
    
    <item>
      <title>关于我</title>
      <link>https://geek.zshipu.com/about/</link>
      <pubDate>Tue, 10 Mar 2015 00:13:27 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/about/</guid>
      <description>知识铺,一个知识分享，积累，整理的地方。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/markd/dubbo/dubbo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/markd/dubbo/dubbo/</guid>
      <description> dubbo 1. 服务消费方发起请求 当服务的消费方引用了某远程服务，服务的应用方在spring的配置实例如下：
&amp;lt;dubbo:referenceid=&amp;quot;demoService&amp;quot;interface=&amp;quot;com.alibaba.dubbo.demo.DemoService&amp;quot; /&amp;gt;  demoService实例其实是代理工厂生产的代理对象（大家可以参考代理那部分生成的伪代码），在代码中调用demoService.sayHello(“world!”)时，
 1.1 将方法名方法参数传入InvokerInvocationHandler的invoke方 &amp;gt; 对于Object中的方法toString, hashCode, equals直接调用invoker的对应方法, 这里对于Object的方法需要被远程调用吗？调用了是不是报错比默认处理更好呢？？ 远程调用层是以Invocation, Result为中心， 这里根据要调用的方法以及传入的参数构建RpcInvocation对象，作为Invoker的入参
1.2 MockClusterInvoker根据参数提供了三种调用策略
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/markd/k8s/k8s/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/markd/k8s/k8s/</guid>
      <description>一、环境准备 1、设置主机名hostname，管理节点设置主机名为master  # hostnamectl set-hostname master  设置其他节点主机名称时，可将master替换为正确的主机名node1,node2,node3即可。
2、编辑/etc/hosts文件，添加域名分析 cat &amp;lt;&amp;lt;EOF &amp;gt;&amp;gt;/etc/hosts 192.168.56.10 master 192.168.56.11 node1 192.168.56.12 node2 EOF  3.关闭防火墙、selinux和swap。 依次执行以下操作
 # systemctl stop firewalld # systemctl disable firewalld # setenforce 0 # sed -i &amp;quot;s/^SELINUX=enforcing/SELINUX=disabled/g&amp;quot;/etc/selinux/config # swapoff -a # sed -i &#39;s /.* swap.*/#&amp;amp;/&#39;/etc/fstab  4.配置内核参数，将桥接的IPv4流量传递到iptables的链 cat &amp;gt;/etc/sysctl.d/k8s.conf &amp;lt;&amp;lt;EOF net.bridge.bridge-nf-call-ip6tables =1 net.bridge.bridge-nf-call-iptables =1 EOF  5、配置国内yum源 # yum install -y wget # mkdir /etc/yum.repos.d/bak &amp;amp;&amp;amp; mv /etc/yum.repos.d/*.repo /etc/yum.repos.d/bak # wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.cloud.tencent.com/repo/centos7_base.repo # wget -O /etc/yum.repos.d/epel.repo http://mirrors.cloud.tencent.com/repo/epel-7.repo # yum clean all &amp;amp;&amp;amp; yum makecache  　配置国内Kubernetes源
cat &amp;lt;&amp;lt;EOF &amp;gt;/etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/ enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg EOF   配置 docker 源 # wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo  二、软件安装  注：在所有节点上进行如下操作
1、安装docker # yum install -y docker-ce # systemctl enable docker &amp;amp;&amp;amp; systemctl start docker # docker --version  docker服务为容器运行提供计算资源，是所有容器运行的基本平台。
2、安装kubeadm、kubelet、kubectl # yum install -y kubelet kubeadm kubectl # systemctl enable kubelet Kubelet负责与其他节点集群通信，并进行本节点Pod和容器生命周期的管理。Kubeadm是Kubernetes的自动化部署工具，降低了部署难度，提高效率。Kubectl是Kubernetes集群管理工具，此处注意Kubectl的版本信息，后面会用到！  三、部署master节点 注：在master节点上进行如下操作</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/markd/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/markd/%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E/%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E/</guid>
      <description>决策引擎产品介绍 决策引擎承载的是风控业务的专家知识，基于变量和模型的输出，对用户进行分层、用户风险判断、以及用户风险定价的操作。其核心为判断流程的编制。 决策引擎产品提供可视化操作，支持判断逻辑的多种组合，流程链路配置，支持0开发部署上线，使得策略迭代速度能够得到最大的优化。
决策引擎功能模块： 策略画布 ![](imgs/v2-3ac12013d19f5a619d859d84afc03238_720w.jpg
策略画布是一个策略的主干，承担着执行链路配置的功能。画布中主要的组成部分如下：
 开始节点：开始节点为策略执行的第一步，开始节点上定义了策略基本信息，策略code、策略名称、策略版本描述。  ![img](imgs/v2-cb6cc8206e68dae55f8e4b07d490687c_720w.jpg
 缓存变量：缓存变量做为策略的一个临时容器，可以将某些值扔进来存储，以便后续使用。缓存变量的值，最后将作为策略结果进行输出。 节点：策略执行判断承载器，逻辑节点主要作用为 规则执行：逻辑节点绑定了策略中定义好的规则（可以参见组件-规则定义），逻辑节点运行会对规则进行执行，根据规则的结果（rule.result）进行综合输出，作为节点的输出（node.result）。综合逻辑为，取规则结果中最为严重的结果（reject&amp;gt;reference&amp;gt;pass）。 缓存变量赋值：缓存变量赋值主要是将某个执行结果的值赋予缓存变量，作为用户执行路径的记录。例如，走到a节点，用户就是好人；走到b节点，用户就是坏人，依此。 分流：分流作为判断节点下一步走到哪里，是逻辑分流的实现。  ![img](imgs/v2-cb6cc8206e68dae55f8e4b07d490687c_720w.jpg
 分流：  增加分流：可以在图中两个节点A，B之间进行连线，代表A的下一个执行节点为B。一个节点的分流可以有多个（开始节点除外），例如A节点可以和 B、C、D相互连接，形成以下三条路由： A -&amp;gt; B： A -&amp;gt; C： A -&amp;gt; D： 判断如何走到分支，由分流上的判断条件来判断。如下 分流1 A -&amp;gt; B： if judge_1 == true 分流2 A -&amp;gt; C： if judge_2 == ture 分流3 A -&amp;gt; D： 分流判断的条件从上到下顺序执行，满足一条条件则走该分流 最后的分流：示例中的 分流为兜底路由，如果上述两条分流的条件都不满足，则走该条分流。
 结束节点：  ![img](imgs/v2-632bce00462898962a53cb1368221060_720w.jpg
结束节点为最后结束的节点，所有分流都必须走到结束节点。结束节点没有后续连接的节点。结束节点中包含的内容为：输出变量配置，可以绑定的为 策略变量，进行策略变量的输出操作。 最后策略的输出为：
 result：策略判断结果，策略的结果为结束节点上游分支的判断结果 输出参数：结束节点中，输出参数中配置的策略变量，以及对应的值  策略组件 ![img](imgs/v2-fab26a61ecaf023062789890d0478a55_720w.jpg
策略组件有 规则、评分卡、决策表 三个类型构成，具体详情可见组件介绍。 组件血缘：记录了策略中组件相互之间关联的关系，从上最开始的策略到最下面的变量。依据血缘的引用，定义了组件的 引用和使用这两种状态：
 是否引用：组件的输出，是否被其他组件使用（往上走） 是否使用：是否使用：向上走是否能够走到某一节点  ![img](imgs/v2-5d3532a1540542b2b34cf9a872ded799_720w.jpg
血缘的引用关系将会在组件的修改过程中被检查：
 组件删除：需要检查该组件是否引用，防止删除之后程序不能运行 组件的输出删除：例如决策表的输出，输出如果被其他地方使用，该输出则不能删除  策略组件-规则 ![img](imgs/v2-74857caaaf3a0f98ba80329f9cbc2c94_720w.jpg
规则配置： 规则执行的是if…then…语句的判断，可以进行的操作有：配置 if的多层嵌套，条件可以是 并（and） 以及 或（or）。
![img](imgs/v2-405ff8374f06eaff6a71ace36571ee66_720w.jpg
上图中的执行语表示为：if { 1 and 2 and 3 and { 4 or 5 or 6}} 判断语句下拉框会根据选择的变量类型，来选择对应的匹配符，如果是数值型的变量，则提供 数值型判断（=, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=），如果是文本型的变量则提供（in，not in，contain，not contain，is null，is notnull，==，!=，~=）。 规则执行判断： 规则执行中一行条件为一个执行单位，执行单位根据组合的规则是否命中决定最后结果。一条规则中会有多个执行单位，规则将对执行单位的结果进行汇总，汇总的逻辑为 取最为严重的结果，如果执行单位中有 一个为reject，则规则结果为 reject。如果执行单位中 没有reject，执行单位中 有一个为 reference，则规则结果为 reference。如果执行单位结果全部为 pass，则最后结果为 pass。
策略组件-决策表 ![img](imgs/v2-d71ef33b3f4daea4080fcfe6a03216f5_720w.jpg
决策表介绍，决策表提供的是变量交叉组合之后给予特定结果。 决策表配置：决策表配置是以表格为基础的，每一列都有一个变量，分为输入和输出。每一行，是一个判断条件组合，表示 如果（变量1 条件， 变量2 条件，变量3 条件，…）都满足则，执行 输出（输出变量 =1， 输出变量 =2）。 决策表的变量支持：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/ecg/001-%E6%A0%87%E5%87%86%E5%9F%BA%E7%BA%BF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/ecg/001-%E6%A0%87%E5%87%86%E5%9F%BA%E7%BA%BF%E7%AE%97%E6%B3%95/</guid>
      <description>标准基线算法 class MedLvBo { private val data = IntArray(254) private var index = 0 fun init(v:Int):Int{ data[index++] = v if(index == 254)index=0 return data[index]-initAvg(initMid(v)) } private var avgI = 0 private val dI=IntArray(256) private var sum = 0 private fun initAvg(v:Int):Int{ sum-=dI[avgI] sum+=v dI[avgI++]=v if(avgI==256)avgI=0 return sum shr 8 } private var mPos: Int = 125 private var i = 0 private val d = IntArray(251) private val f = BooleanArray(251) { it &amp;lt; mPos } private var mV = 0 private fun initMid(a: Int): Int { d[i] = a if (f[i]) { if (a &amp;lt; mV) { f[i] = false f[mPos] = true mPos = i g(a) } } else if (a &amp;gt; mV) { f[i] = true mV = a mPos = i d.forEachIndexed { i, v -&amp;gt; if (f[i] &amp;amp;&amp;amp; v &amp;lt; mV) { mPos = i mV = v } } f[mPos] = false } else if (i == mPos &amp;amp;&amp;amp; mV !</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/ecg/002-%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/ecg/002-%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%95/</guid>
      <description>心率算法 class HeartUtils { private var lastMaxPos = 0 private var running = true private var index =0 private var maxPos = 0 private var maxValue = 0f fun init(index:Int,value:Float):Boolean{ if(maxValue&amp;lt;value){ maxPos = index maxValue = value return true } return false } private val size = 128 private val sizeX = 127 /** * 原始数据 */ private val src = FloatArray(size) /** * 平滑之后的数据 */ private val base = FloatArray(size) private val arg16 = FloatArray(size) private val sub = FloatArray(size) private val subtractsAbs = FloatArray(size) private val line = FloatArray(size) private var bIndex = 0; private var argIndex = size-16 private var nowIndex = 64 private val sm32 = Smooth16() private val sm16= Smooth16() private val xmf = CMidXFilter() private val rf = CMidRFilter() private val lf = CMidLFilter() private var flag = 0 private var rrDis=0; fun heart():Int{ if(rrDis!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/ecg/003-%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%952/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/ecg/003-%E5%BF%83%E7%8E%87%E7%AE%97%E6%B3%952/</guid>
      <description>心率算法2 package test import java.io.Closeable import java.io.PrintStream class HeartUtils { private val size = 256 private val sizeX = 255 /** * 原始数据 */ private val src = FloatArray(size) private val mSrc = FloatArray(size) private var nIndex =240 private var sIndex =137 private var mIndex =125 private var lIndex =0 private val line = FloatArray(size) private val absSub = FloatArray(size) private val sm32 = Smooth32() private val t=CMidXFilter() var c = PrintStream(&amp;quot;d:/c.txt&amp;quot;) var d = PrintStream(&amp;quot;d:/d.txt&amp;quot;) var s = PrintStream(&amp;quot;d:/s.txt&amp;quot;) var o = PrintStream(&amp;quot;d:/o.txt&amp;quot;) private var lastPos = 0 private var maxPos = 0 private var maxValue = 0f private val maxV = MaxVFiter() private var running = false private var index = 0 private var flag = 0; fun init(v:Float):Int { src[sIndex] = v val m = sm32.init(v) mSrc[mIndex] = m val a = kotlin.math.abs(src[mIndex] - m) absSub[mIndex] = a line[lIndex] = t.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/ecg/004-%E5%BF%83%E7%8E%87%E5%91%BC%E5%90%B8%E7%8E%87%E5%88%86%E7%A6%BB%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/ecg/004-%E5%BF%83%E7%8E%87%E5%91%BC%E5%90%B8%E7%8E%87%E5%88%86%E7%A6%BB%E7%AE%97%E6%B3%95/</guid>
      <description>心率呼吸率分离算法 基于毫米波雷达或者可穿戴心冲击检测设备，采集人的体征信号，心冲击信号，脉搏压力信号，根据得到的压力信号，进行下列步骤的算法分析： 一、心冲击信号数据分析 得到的信号如图1： 选取其中（0.2-3.4）×104这一段（即去除了首尾上下床的信号，只保留了中间平躺状态下的信号）来进行分析，选取其中一路信号（data4）进行分析，其波形如图2： 设该信号为X(n)，则可得到如下式子： x(n)=r(n)+h(n)+ε(n) 其中r(n)为呼吸信号，h(n)为心跳信号，ε(n)为其他噪声信号。
二、心跳信号处理 根据百科资料，安静状态下，成人正常心率为60～100次/分钟，理想心率应为55～70次/分钟，因此心跳信号的频率应该是在0.9-1.7Hz左右，呼吸信号的频率较低，成年人为大概16～20/分钟，频率低于0.5Hz，所以可以用一个带通滤波器滤去呼吸信号以及高频的噪声信号，选择滤波器为巴特沃斯滤波器，它的平方幅度函数定义为： 式中，N是滤波器的阶数，Ω_c称为3dB截止频率，ε是控制通带波纹幅度的参数。选定频带为0.7Hz~2Hz，可以得到滤波后的信号如图3： 图3 经过带通滤波器后的data4信号 针对该信号进行HHT（希尔伯特-黄变换），不同于傅里叶变换只能处理线性非平稳信号，这个变换可以分析非线性非平稳信号。并且傅立叶变换、短时傅立叶变换、小波变换都受Heisenberg测不准原理制约，即时间窗口与频率窗口的乘积为一个常数。这就意味着如果要提高时间精度就得牺牲频率精度，反之亦然，故不能在时间和频率同时达到很高的精度，这就给信号分析处理带来一定的不便。而HHT不受Heisenberg测不准原理制约，它可以在时间和频率同时达到很高的精度，这使它非常适用于分析突变信号。 该方法分为两步，第一步是先进行EMD（经验模态分解），这个过程依据信号特点自适应地把任意一个复杂信号分解为一系列本征模态函数(IMF)。它满足如下两个条件： (1) 信号极值点的数量与零点数相等或相差是一； (2) 信号的由极大值定义的上包络和由极小值定义的下包络的局部均值为零。 最终的信号可以表示为如下式子： 传统的傅里叶分析用一系列三角基函数对信号进行正交运算，但是对于非平稳信号，比如频率一直变化的信号，得到的傅里叶谱只是某一段时间内频率的均值，无法准确描述频率-时间的变化。瞬时频率的定义方法不唯一，但使用Hilbert变换来定义瞬时频率能够生成复解析信号，进而得到复平面上具有明确解析意义的瞬时频率。对于实信号x(t)，其复解析信号为 实部虚部的幅角对时间求导即得到瞬时频率。
对每个IMF进行Hilbert变换，原信号x(t)可以表示如下，即Hilbert谱 在经过经验模态分解后，得到7个IMF，如图4 图4 经过经验模态分解后的信号波形 下一步应当是进行HT变换，然后计算瞬时频率，这里尚未弄好代码，目前还无法得到，还在调试中。因此暂时先用傅里叶变换得到全局的频率，得到频谱图如图5，由频谱图可以确定能量最大对应的频率为0.9375Hz，所给的数据中说明实验者的心跳频率大约在1Hz。同理选择data1时测得频率为0.9375Hz，选择data2时测得频率为1.063Hz，选择data3时测得频率为0.875Hz，令data5=data2+data3-data1-data4，此时得到频率为0.9375Hz。 图5 信号频谱图 三、呼吸信号处理 根据资料，成年人的呼吸频率为12-20次/分。 1.低通 设定低通频率为0.4Hz，选用巴特沃斯滤波器，设定阶数为3，选取其中一路信号，得到滤波后的波形如下图： 图 6 滤波后的信号波形 然后进行fft变换得到频谱图如下，表明其中并没有周期信号，选择其他路信号以及综合几路信号均未检测到。 2.带通 设定带通频率为0.15-0.3Hz（邮件中说明该人呼吸频率为10次/分，大约为0.17Hz），选用巴特沃斯滤波器，设定阶数为2，选取其中一路信号，得到滤波后的波形如下图： 图 8 滤波后的信号波形 附：前人文献中查到的呼吸心跳波形 图10 正常心跳波形 图11 连续波雷达监测到的呼吸波形</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/framework/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A8%E9%9D%A2k8s%E5%8C%96%E7%9A%84%E9%9B%86%E7%BE%A4%E7%A8%B3%E5%AE%9A%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/framework/%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E5%85%A8%E9%9D%A2k8s%E5%8C%96%E7%9A%84%E9%9B%86%E7%BE%A4%E7%A8%B3%E5%AE%9A%E6%9E%B6%E6%9E%84/</guid>
      <description> 我司的集群时刻处于崩溃的边缘，通过近三个月的掌握，发现我司的集群不稳定的原因有以下几点：
1、发版流程不稳定
2、缺少监控平台【最重要的原因】
3、缺少日志系统
4、极度缺少有关操作文档
5、请求路线不明朗
总的来看，问题的主要原因是缺少可预知的监控平台，总是等问题出现了才知道。次要的原因是服务器作用不明朗和发版流程的不稳定。
解决方案 发版流程不稳定 重构发版流程。业务全面k8s化，构建以kubernetes为核心的ci/cd流程。
发版流程 有关发版流程如下：
浅析：研发人员提交代码到developer分支(时刻确保developer分支处于最新的代码)，developer分支合并到需要发版环境对应的分支，触发企业微信告警，触发部署在k8s集群的gitlab-runner pod，新启runner pod 执行ci/cd操作。在这个过程中需要有三个步骤：测试用例、打包镜像、更新pod。
第一次部署服务在k8s集群环境的时候可能需要：创建namespace、创建imagepullsecret、创建pv(storageclass)、创建deployment（pod controller）、创建svc、创建ingress、等。其中镜像打包推送阿里云仓库和从阿里云仓库下载镜像使用vpc访问，不走公网，无网速限制。流程完毕，runner pod 销毁，gitlab 返回结果。
需要强调的一点是，在这里的资源资源清单不包含configmap或者secret，牵扯到安全性的问题，不应该出
现在代码仓库中，我司是使用rancher充当k8s多集群管理平台，上述安全问题在rancher的dashboard中由运维来做的。
服务部署逻辑图 有关服务部署逻辑图如下：
image.png
根据发版流程的浅析，再根据逻辑图可以明确发版流程。在这里看到我司使用的是kong代替nginx，做认证、鉴权、代理。而slb的ip绑定在kong上。0，1，2属于test job；3属于build job；4，5，6，7属于change pod 阶段。并非所有的服务都需要做存储，需要根据实际情况来定，所以需要在kubernetes.sh里写判断。
在这里我试图使用一套CI应用与所有的环境，所以需要在kubernetes.sh中用到的判断较多，且.gitlab-ci.yml显得过多。建议是使用一个ci模版，应用于所有的环境，毕竟怎么省事怎么来。还要考虑自己的分支模式。
具体参考：
 https://www.cnblogs.com/zisefeizhu/p/13621797.html
 缺少监控预警平台 构建可信赖且符合我司集群环境的联邦监控平台，实现对几个集群环境的同时监控和预故障告警，提前介入。
监控预警逻辑图 有关监控预警逻辑图如下：
image.png
浅析：总的来说，我这里使用到的监控方案是prometheus+shell脚本或go脚本+sentry。使用到的告警方式是企业微信或者企业邮箱。
上图三种颜色的线代表三种监控方式需要注意。脚本主要是用来做备份告警、证书告警、抓贼等。prometheus这里采用的是根据prometheus-opertor修改的prometheus资源清单，数据存储在nas上。
sentry严格的来讲属于日志收集类的平台，在这里我将其归为监控类，是因为我看中了其收集应用底层代码的崩溃信息的能力，属于业务逻辑监控, 旨在对业务系统运行过程中产生的错误日志进行收集归纳和监控告警。
注意这里使用的是联邦监控平台，而部署普通的监控平台。
联邦监控预警平台逻辑图 多集群联邦监控预警平台逻辑图如下：
image.png
因为我司有几个k8s集群，如果在每个集群上都部署一套监控预警平台的话，管理起来太过不便，所以这里我采取的策略是使用将各监控预警平台实行一个联邦的策略，使用统一的可视化界面管理。
这里我将实现三个级别饿监控：操作系统级、应用程序级、业务级。对于流量的监控可以直接针对kong进行监控，模版7424。
缺少日志系统 随着业务全面k8s化进程的推进，对于日志系统的需求将更加渴望，k8s的特性是服务的故障日志难以获取。建立可观测的能过滤的日志系统可以降低对故障的分析难度。
有关日志系统逻辑图如下：
image.png
浅析：在业务全面上k8s化后，方便了管理维护，但对于日志的管理难度就适当上升了。我们知道pod的重启是有多因素且不可控的，而每次pod重启都会重新记录日志，即新pod之前的日志是不可见的。
当然了有多种方法可以实现日志长存：远端存储日志、本机挂载日志等。出于对可视化、可分析等的考虑，选择使用elasticsearch构建日志收集系统。
极度缺少有关操作文档 建立以语雀&amp;ndash;&amp;gt; 运维相关资料为中心的文档中心，将有关操作、问题、脚本等详细记录在案，以备随时查看。
image.png
浅析因安全性原因，不便于过多同事查阅。运维的工作比较特殊，安全化、文档化是必须要保障的。我认为不论是运维还是运维开发，书写文档都是必须要掌握的，为己也好，为他也罢。文档可以简写，但必须要含苞核心的步骤。我还是认为运维的每一步操作都应该记录下来。
请求路线不明朗 根据集群重构的新思路，重新梳理集群级流量请求路线，构建具备：认证、鉴权、代理、连接、保护、控制、观察等一体的流量管理，有效控制故障爆炸范围。
请求路线逻辑图如下：
image.png
浅析：客户访问https://www.cnblogs.com/zisefeizhu 经过kong网关鉴权后进入特定名称空间(通过名称空间区分项目)，因为服务已经拆分为微服务，服务间通信经过istio认证、授权，需要和数据库交互的去找数据库，需要写或者读存储的去找pv，需要转换服务的去找转换服务&amp;hellip;&amp;hellip; 然后返回响应。
总结 综上所述，构建以：以kubernetes为核心的ci/cd发版流程、以prometheus为核心的联邦监控预警平台、以elasticsearch为核心的日志收集系统、以语雀为核心的文档管理中心、以kong及istio为核心的南北东西流量一体化服务，可以在高平发，高可靠性上做到很好保障。
附：总体架构逻辑图
image.png
注：请根据箭头和颜色来分析。
浅析：上图看着似乎过于混乱，静下心来，根据上面的拆分模块一层层分析还是可以看清晰的。这里我用不同颜色的连线代表不同模块的系统，根据箭头走还是蛮清晰的。
根据我司目前的业务流量，上述功能模块，理论上可以实现集群的维稳。私认为此套方案可以确保业务在k8s集群上稳定的运行一段时间，再有问题就属于代码层面的问题了。
这里没有使用到中间件，倒是使用到了缓存redis不过没画出来。我规划在上图搞定后再在日志系统哪里和转换服务哪里增加个中间件kafka或者rq 看情况吧。
END 推荐好文 强大，10k+点赞的 SpringBoot 后台管理系统竟然出了详细教程！ 分享一套基于SpringBoot和Vue的企业级中后台开源项目，代码很规范！能挣钱的，开源 SpringBoot 商城系统，功能超全，超漂亮！  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/java/Java-%E9%9D%A2%E8%AF%95-150%E5%88%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E8%AE%A9%E4%BD%A0%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%88%B0offer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/java/Java-%E9%9D%A2%E8%AF%95-150%E5%88%B0%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E8%AE%A9%E4%BD%A0%E7%9B%B4%E6%8E%A5%E6%8B%BF%E5%88%B0offer/</guid>
      <description>title: Java 面试 150到面试题及答案让你直接拿到offer author: 知识铺 date: 2021-10-03 11:33:33 tags: [Java]
1. 什么是Java？ Java 是一种计算机编程语言，具有并发性、基于类和对象导向。对象导向软件开发的优势如下：
 代码的模块化开发，便于维护和修改。 代码的可重复性。 提高了代码的可靠性和灵活性。 加深对代码的理解。  2. OOP 的概念是什么？ 对象导向编程 （OOP） 包括：
 抽象化 封装 多态性 Inheritance 预定义的类型必须是对象 用户定义的类型必须是对象 操作必须通过向对象发送消息来执行  3. 提及Java的某些功能 在 java 的流行中发挥重要作用的一些功能如下：
 对象导向 独立平台 高性能 多线程 便携式 安全  java 中的 Helloworld 示例代码如下所示：
世界好
public class Helloworld{ public static void main(String args[]) { System.out.println(&amp;quot;Hello World&amp;quot;); } }  4. Java 是否 100% 面向对象？ 不是 100%Java 不满足所有 OOP 条件（预定义的类型必须是对象），因为它使用八种原始数据类型（Boolean、字节、字符、int、浮子、双、长、短）这些数据类型不是对象。
5. 什么是抽象？ 抽象是将想法与特定实例分离的过程，因此，根据它们自己的功能而不是实施细节来发展课程。Java 支持创建和存在暴露界面的抽象类，但不包括所有方法的实际实现。抽象技术旨在将一个类的实现细节与其行为分开。
摘要类 人如下。它有一个抽象的方法得到名。
抽象类人
public abstract class Person { public abstract String getName(); }  员工类扩展抽象类人员。方法获取名称返回员工的姓名属性。
员工类
public class Employee extends Person { private String name; public Employee(String name) { this.name = name; } public String getName() { return this.name; } public static void main (String args[]) { Employee employee = new Employee(&amp;quot;John Wilson&amp;quot;); System.out.println(&amp;quot;Employee&#39;s Name &amp;quot;+ employee.getName()); Person person = new Employee(&amp;quot;Thomas Smith&amp;quot;); System.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/pytorch/001-%E8%AE%A4%E8%AF%86Pytorch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/pytorch/001-%E8%AE%A4%E8%AF%86Pytorch/</guid>
      <description>什么是 PyTorch？ PyTorch 是基于以下两个目的而打造的python科学计算框架：
 无缝替换NumPy，并且通过利用GPU的算力来实现神经网络的加速。 通过自动微分机制，来让神经网络的实现变得更加容易。  本次教程的目标：  深入了解PyTorch的张量单元以及如何使用Pytorch来搭建神经网络。 自己动手训练一个小型神经网络来实现图像的分类。  注意
确保已安装torch和torchvision包。
张量
torch.autograd的简要介绍
神经网络简介
自己动手训练一个图像分类器</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/pytorch/002-Pytorch-%E5%BC%A0%E9%87%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/pytorch/002-Pytorch-%E5%BC%A0%E9%87%8F/</guid>
      <description>张量如同数组和矩阵一样, 是一种特殊的数据结构。在PyTorch中, 神经网络的输入、输出以及网络的参数等数据, 都是使用张量来进行描述。
张量的使用和Numpy中的ndarrays很类似, 区别在于张量可以在GPU或其它专用硬件上运行, 这样可以得到更快的加速效果。如果你对ndarrays很熟悉的话, 张量的使用对你来说就很容易了。如果不太熟悉的话, 希望这篇有关张量API的快速入门教程能够帮到你。
import torch import numpy as np复制ErrorOK!  张量初始化 张量有很多种不同的初始化方法, 先来看看四个简单的例子：
1. 直接生成张量
由原始数据直接生成张量, 张量类型由原始数据类型决定。
data = [[1, 2], [3, 4]] x_data = torch.tensor(data)复制ErrorOK!  2. 通过Numpy数组来生成张量
由已有的Numpy数组来生成张量(反过来也可以由张量来生成Numpy数组, 参考张量与Numpy之间的转换)。
np_array = np.array(data) x_np = torch.from_numpy(np_array)复制ErrorOK!  3. 通过已有的张量来生成新的张量
新的张量将继承已有张量的数据属性(结构、类型), 也可以重新指定新的数据类型。
x_ones = torch.ones_like(x_data) # 保留 x_data 的属性 print(f&amp;quot;Ones Tensor: \n {x_ones} \n&amp;quot;) x_rand = torch.rand_like(x_data, dtype=torch.float) # 重写 x_data 的数据类型 int -&amp;gt; float print(f&amp;quot;Random Tensor: \n {x_rand} \n&amp;quot;)复制ErrorOK!  显示:
Ones Tensor: tensor([[1, 1], [1, 1]]) Random Tensor: tensor([[0.0381, 0.5780], [0.3963, 0.0840]])复制ErrorOK!  4. 通过指定数据维度来生成张量
shape是元组类型, 用来描述张量的维数, 下面3个函数通过传入shape来指定生成张量的维数。
shape = (2,3,) rand_tensor = torch.rand(shape) ones_tensor = torch.ones(shape) zeros_tensor = torch.zeros(shape) print(f&amp;quot;Random Tensor: \n {rand_tensor} \n&amp;quot;) print(f&amp;quot;Ones Tensor: \n {ones_tensor} \n&amp;quot;) print(f&amp;quot;Zeros Tensor: \n {zeros_tensor}&amp;quot;)复制ErrorOK!  显示:
Random Tensor: tensor([[0.0266, 0.0553, 0.9843], [0.0398, 0.8964, 0.3457]]) Ones Tensor: tensor([[1., 1., 1.], [1., 1., 1.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/pytorch/003-Pytorch-torch.autograd-%E8%87%AA%E5%8A%A8%E5%B7%AE%E5%88%86%E5%BC%95%E6%93%8E/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/pytorch/003-Pytorch-torch.autograd-%E8%87%AA%E5%8A%A8%E5%B7%AE%E5%88%86%E5%BC%95%E6%93%8E/</guid>
      <description>torch.autograd是 PyTorch 的自动差分引擎，可为神经网络训练提供支持。 在本节中，您将获得有关 Autograd 如何帮助神经网络训练的概念性理解。
背景 神经网络（NN）是在某些输入数据上执行的嵌套函数的集合。 这些函数由*参数*（由权重和偏差组成）定义，这些参数在 PyTorch 中存储在张量中。
训练 NN 分为两个步骤：
正向传播：在正向传播中，NN 对正确的输出进行最佳猜测。 它通过其每个函数运行输入数据以进行猜测。
反向传播：在反向传播中，NN 根据其猜测中的误差调整其参数。 它通过从输出向后遍历，收集有关函数参数（*梯度*）的误差导数并使用梯度下降来优化参数来实现。 有关反向传播的更详细的演练，请查看 3Blue1Brown 的视频。
在 PyTorch 中的用法 让我们来看一个训练步骤。 对于此示例，我们从torchvision加载了经过预训练的 resnet18 模型。 我们创建一个随机数据张量来表示具有 3 个通道的单个图像，高度&amp;amp;宽度为 64，其对应的label初始化为一些随机值。
import torch, torchvision model = torchvision.models.resnet18(pretrained=True) data = torch.rand(1, 3, 64, 64) labels = torch.rand(1, 1000)  接下来，我们通过模型的每一层运行输入数据以进行预测。 这是正向传播。
prediction = model(data) # forward pass  我们使用模型的预测和相应的标签来计算误差（loss）。 下一步是通过网络反向传播此误差。 当我们在误差张量上调用.backward()时，开始反向传播。 然后，Autograd 会为每个模型参数计算梯度并将其存储在参数的.grad属性中。
loss = (prediction - labels).sum() loss.backward() # backward pass  接下来，我们加载一个优化器，在本例中为 SGD，学习率为 0.01，动量为 0.9。 我们在优化器中注册模型的所有参数。
optim = torch.optim.SGD(model.parameters(), lr=1e-2, momentum=0.9)  最后，我们调用.step()启动梯度下降。 优化器通过.grad中存储的梯度来调整每个参数。
optim.step() #gradient descent  至此，您已经具备了训练神经网络所需的一切。 以下各节详细介绍了 Autograd 的工作原理-随时跳过它们。
Autograd 的微分 让我们来看看autograd如何收集梯度。 我们用requires_grad=True创建两个张量a和b。 这向autograd发出信号，应跟踪对它们的所有操作。
import torch a = torch.tensor([2., 3.], requires_grad=True) b = torch.tensor([6., 4.], requires_grad=True)  我们从a和b创建另一个张量Q。
Q = 3*a**3 - b**2  假设a和b是神经网络的参数，Q是误差。 在 NN 训练中，我们想要相对于参数的误差，即
当我们在Q上调用.backward()时，Autograd 将计算这些梯度并将其存储在各个张量的.grad属性中。
我们需要在Q.backward()中显式传递gradient参数，因为它是向量。 gradient是与Q形状相同的张量，它表示Q相对于本身的梯度，即
同样，我们也可以将Q聚合为一个标量，然后隐式地向后调用，例如Q.sum().backward()。
external_grad = torch.tensor([1., 1.]) Q.backward(gradient=external_grad)  梯度现在沉积在a.grad和b.grad中
# check if collected gradients are correct print(9*a**2 == a.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/4-3-5-Chakra-UI/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/4-3-5-Chakra-UI/</guid>
      <description>Chakra UI 是一个简单的, 模块化的易于理解的 UI 组件库. 提供了丰富的构建 React 应用所需的 UI 组件. 文档: https://next.chakra-ui.com/docs/getting-started
 Chakra UI 内置 Emotion，是 CSS-IN-JS 解决方案的集大成者 基于 Styled-Systems https://styled-system.com/ 支持开箱即用的主题功能 默认支持白天和黑夜两种模式 拥有大量功能丰富且非常有用的组件 使响应式设计变得轻而易举 文档清晰而全面. 查找 API 更加容易 适用于构建用于展示的给用户的界面 框架正在变得越来越完善
//下载 npm install @chakra-ui/core@1.0.0-next.2   快速使用 克隆默认主题 Chakra-UI 提供的组件是建立在主题基础之上的, 只有先引入了主题组件才能够使用其他组件.
npm install @chakra-ui/theme
引入主题 import {ChakraProvider} from &#39;@chakra-ui/core&#39; import theme from &#39;@chakra-ui/theme&#39; &amp;lt;ChakraProvider theme={theme}&amp;gt; &amp;lt;App/&amp;gt; &amp;lt;/ChakraProvider&amp;gt;  引入 CSS 重置组件 import {CSSReset} from &#39;@chakra-ui/core&#39; &amp;lt;ChakraProvider theme={theme}&amp;gt; &amp;lt;CSSReset /&amp;gt; &amp;lt;App/&amp;gt; &amp;lt;/ChakraProvider&amp;gt;  Style Props 样式属性 Style Props 是用来更改组件样式的, 通过为组件传递属性的方式实现. 通过传递简化的样式属性以达到提升开发效率的目的.
import {Box} from &#39;@chakra-ui/core&#39; &amp;lt;Box w={200} h={200} bg=&#39;tomato&#39; p=&#39;3px&#39;&amp;gt;Hello&amp;lt;/Box&amp;gt;  主题 颜色模式 (color mode) chakra-ui 提供的组件都支持两种颜色模式, 浅色模式 (light) 和暗色模式(dark). 可以通过 useColorMode 进行颜色模式的更改.
import {userColorMode} from &#39;@chakra-ui/core&#39; const [colorMode, toggleColorMode] = useColorMode() &amp;lt;Text&amp;gt;当前颜色模式为{colorMode}&amp;lt;/Text&amp;gt; &amp;lt;Button onClick={toggleColorMode}&amp;gt;切换颜色模式&amp;lt;/Button&amp;gt;  Chakra 将颜色模式存储在 localStorage 中, 并使用类名策略来确保颜色模式是持久的.
根据颜色模式设置样式 chakra 允许在为元素设置样式时根据颜色模式产生不同值. 通过 useColorModeValue 钩子函数实现.
const bgColor = useColorModeValue(lightModeValue, darkModeValue) &amp;lt;Box bgColor={bgColor}&amp;gt;&amp;lt;/Box&amp;gt;  强制组件颜色模式 使组件不受颜色模式的影响, 始终保持在某个颜色模式下的样式.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/Golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/Golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 www.cnblogs.com
1、单元测试概述 1.1 什么是单元&amp;amp;单元测试 单元是应用的最小可测试部件，如函数和对象的方法 单元测试是软件开发中对最小单位进行正确性检验的测试工作 1.2 为什么进行单元测试 保证变更/重
 目录
 1、单元测试概述  1.1 什么是单元 &amp;amp; 单元测试 1.2 为什么进行单元测试 1.3 单元测试用例编写的原则 1.4 单测用例规定  2、golang 常用的单测框架  2.1 testing  2.1.1 单元测试 2.1.2 测试覆盖率 2.1.3 子测试 t.run  2.2 goconvey  2.2.1 基本使用 2.2.2 图形化使用  2.3 testify  2.3.1 简单使用 2.3.2 表驱动测试 2.3.3 mock 功能 2.3.4 单元测试覆盖率应用实例    1、单元测试概述 1.1 什么是单元 &amp;amp; 单元测试  单元是应用的最小可测试部件，如函数和对象的方法 单元测试是软件开发中对最小单位进行正确性检验的测试工作  1.2 为什么进行单元测试  保证变更 / 重构的正确性，特别是在一些频繁变动和多人合作开发的项目中 简化调试过程： 可以轻松的让我们知道哪一部分代码出了问题 单测最好的文档：在单测中直接给出具体接口的使用方法，是最好的实例代码  1.3 单元测试用例编写的原则  单一原则：一个测试用例只负责一个场景 原子性：结果只有两种情况：Pass、Fail 优先要核心组件和逻辑的测试用例 高频使用库，util，重点覆盖  1.4 单测用例规定  文件名必须要xx_test.go命名 测试方法必须是TestXXX开头 方法中的参数必须是t *testing.T 测试文件和被测试文件必须在一个包中  2、golang 常用的单测框架 2.1 testing https://golang.google.cn/pkg/testing/
2.1.1 单元测试 Go提供了test工具用于代码的单元测试，test工具会查找包下以_test.go结尾的文件，调用测试文件中以 Test或Benchmark开头的函数并给出运行结果
测试函数需要导入testing包，并定义以Test开头的函数，参数为testing.T指针类型，在测试函数中调用函数进行返回值测试，当测试失败可通过testing.T结构体的Error函数抛出错误
单元测试是对某个功能的测试
命令行执行
go test 包名 # 测试整个包 go test -v . go test 包名/文件名 # 测试某个文件  简单使用
准备待测代码compute.go
package pkg03 func Add(a, b int) int { return a + b } func Mul(a, b int) int { return a * b } func Div(a, b int) int { return a / b }  准备测试用例compute_test.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/React-%E7%BB%9D%E5%9C%B0%E5%8F%8D%E6%9D%80%E4%B9%8B%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/React-%E7%BB%9D%E5%9C%B0%E5%8F%8D%E6%9D%80%E4%B9%8B%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%B8%B2%E6%9F%93%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B/</guid>
      <description>React 15 架构分层 React 15 版本 (Fiber 以前) 整个更新渲染流程分为两个部分：
 Reconciler(协调器); 负责找出变化的组件
 Renderer(渲染器); 负责将变化的组件渲染到页面上
  Reconciler 在 React 中可以通过 setState、forceUpdate、ReactDOM.render 来触发更新。每当有更新发生时，Reconciler 会做如下工作：
 调用组件的 render 方法，将返回的 JSX 转化为虚拟 DOM
 将虚拟 DOM 和上次更新时的虚拟 DOM 对比
 通过对比找出本次更新中变化的虚拟 DOM
 通知 Renderer 将变化的虚拟 DOM 渲染到页面上
  Renderer 在对某个更新节点执行玩 Reconciler 之后，会通知 Renderer 根据不同的 &amp;ldquo;宿主环境&amp;rdquo; 进行相应的节点渲染 / 更新。
React 15 的缺陷 React 15 的 diff 过程是 递归执行更新 的。由于是递归，一旦开始就 &amp;ldquo;无法中断&amp;rdquo; 。当层级太深或者 diff 逻辑 (钩子函数里的逻辑) 太复杂，导致递归更新的时间过长，Js 线程一直卡主，那么用户交互和渲染就会产生卡顿。看个例子: count-demo
&amp;lt;button&amp;gt; click &amp;lt;button&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;4&amp;lt;li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;6&amp;lt;li&amp;gt;  当点击 button 后，列表从左边的 1、2、3 变为右边的 2、4、6。每个节点的更新过程对用户来说基本是同步，但实际上他们是顺序遍历的。具体步骤如下：
 点击 button，触发更新
 Reconciler 检测到需要变更为，则立刻通知 Renderer 更新 DOM。列表变成 2、2、3
 Reconciler 检测到需要变更为，通知 Renderer 更新 DOM。列表变成 2、4、3
 Reconciler 检测到需要变更为，则立刻通知 Renderer 更新 DOM。列表变成 2、4、6
  从此可见 Reconciler 和 Renderer 是交替工作 的，当第一个节点在页面上已经变化后，第二个节点再进入 Reconciler。由于整个过程都是同步的，所以在用户看来所有节点是同时更新的。如果中断更新，则会在页面上看见更新不完全的新的节点树！
假如当进行到第 2 步的时候，突然因为其他任务而中断当前任务，导致第 3、4 步无法进行那么用户就会看到:
&amp;lt;button&amp;gt; click &amp;lt;button&amp;gt; &amp;lt;li&amp;gt;1&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;li&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;2&amp;lt;li&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;li&amp;gt; -&amp;gt; &amp;lt;li&amp;gt;3&amp;lt;li&amp;gt;  这种情况是 React 绝对不希望出现的。但是这种应用场景又是十分必须的。想象一下，用户在某个时间点进行了输入事件，此时应该更新 input 内的内容，但是因为一个不在当前可视区域的列表的更新导致用户的输入更新被滞后，那么给用户的体验就是卡顿的。因此 React 团队需要寻找一个办法，来解决这个缺陷。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%8E%8C%E6%8F%A1%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%E6%8E%8C%E6%8F%A1%E8%BD%AF%E4%BB%B6%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-DDD/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 zhuanlan.zhihu.com
作者：faryrong，腾讯 CSIG 后台开发工程师 最近看了一本书《解构-领域驱动设计》，书中提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书…
 作者：faryrong，腾讯 CSIG 后台开发工程师
 最近看了一本书《解构 - 领域驱动设计》，书中提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。
 1. 背景 领域驱动设计（DDD）由 Eric Evans 提出，并一经《领域驱动设计：软件核心复杂性应对之道》的发布，在软件行业中引起了不少的轰动。DDD 提供的一种新颖的，甚至有点 “另类” 的思维方式，它在告诉软件开发者“我们要用业务方案来解决业务问题，而不是技术方案解决业务问题”，有点魔法打败魔法的意思。DDD 虽然让人眼前一亮，但是所提倡的理念有点“违背直觉”（对开发人员而言），因此，在当时并没有流行开来。
后来，微服务架构的兴起，大伙惊奇地发现 DDD 是作为划分 “微服务边界” 的一把利器，并且 DDD 提及的很多设计理念与微服务架构十分契合，因此 DDD 逐渐被开发者们接受并流行起来。毫不夸张地说，了解和学习 DDD 可以算得上是如今软件行业从业者的一门必修课了。
但是！DDD 的学习曲线较为陡峭。作为一个小白，翻阅过很多相关的书籍、KM 文章和分享，但始终觉得未得要领、一知半解。原因有二：a) DDD 涉及的概念繁多，且不同概念的抽象层次不一样，如果我们直白地去理解，往往会感到疑惑，比如：子域和限界上下文都是用于将问题进行归类和收敛，他们的区别是什么？b) 缺少过程指导，难以将概念有序的串联起来。作为方法论，DDD 给出了设计思想，核心原则以及常用工具，但是却缺少细致有序的方法步骤，导致难以上手实践。
幸运的是，最近看了一本书《解构 - 领域驱动设计》。这本书提出了领域驱动设计统一过程（DDDRUP），它指明了实践 DDD 的具体步骤，并很好地串联了各种概念、模式和思想。因此，我对书本内容做了梳理、简化，融入自己的理解，并结合之前阅读的书籍以及实践经验，最终形成这篇文章。希望可以帮助大伙理顺 DDD 的各种概念、模式和思想，降低上手 DDD 的门槛。
2.DDD 概要与实践感悟 经典必读书籍《领域驱动设计：软件核心复杂性应对之道》的书名包含了两个关键词：领域驱动和复杂性，分别代表了 DDD 的核心原则以及解决的问题。
2.1 复杂性 系统的复杂性往往并不在技术上，而是来自领域本身、用户的活动或业务服务。当这种领域复杂性在设计中没有得到解决时，基础技术的构思再好也是无济于事。而系统的复杂度体现在三个方面：规模、结构和变化。
规模：指的是系统所支持的功能点，以及功能点与功能点之间的的关系。DDD 通过子领域，限界上下文，聚合等模式对问题进行拆分和归类，不断收窄问题域，保证聚合边界内所解决的问题集合足够收敛和可控。
结构：指的是系统架构。系统架构是否分层；若分层，每层划分的职责边界是否清晰；架构的基本管理单元是什么，它决定了架构演进时的复杂度。DDD 通过分层架构，独立出领域层，且架构中的每层都有清晰的职责。整体架构的基本管理单元是聚合，它是一个完整的、自治的管理单元，当需要进行服务拆分时，可以直接以聚合作为基本单元进行拆分。
变化：指的是系统响应需求变化的能力。快速响应变化的有效手段是分离不易变逻辑和易变逻辑，&amp;rdquo;以不变应万变&amp;rdquo;。而通过分层架构独立的领域层正是不易变的逻辑。领域层是对领域知识的封装，其提供的领域服务具有经验性和前瞻性，是对领域内稳定的领域规则的表达。而领域层以外的应用层和基础设施层则是易变逻辑的封装。保证核心的独立和稳定，通过在调整应用层和基础设施层来实现快速响应需求变化。
2.2 领域驱动 领域驱动指的是以领域作为解决问题切入点，面对业务需求，先提炼出领域概念，并构建领域模型来表达业务问题，而构建过程中我们应该尽可能避免牵扯技术方案或技术细节。而编码实现更像是对领域模型的代码翻译，代码（变量名、方法名、类名等）中要求能够表达领域概念，让人见码明义。
结合实践经验，以下是本人对 “领域驱动” 的一些见解：
思维模式转变
实践 DDD 以前，我最常使用的是数据驱动设计。它的核心思路针对业务需求进行数据建模：根据业务需求提炼出类，然后通过 ORM 把类映射为表结构，并根据读写性能要求使用范式优化表与表之间的关联关系。数据驱动是从技术的维度解决业务问题，得出的数据模型是对业务需求的直接翻译，并没有蕴含稳定的领域知识 / 规则。一旦需求发生变化，数据模型就得发生变化，对应的库表的设计也需要进行调整。这种设计思维导致变化从需求穿透到了数据层，中间并没有稳定的，不易变的层级进行阻隔，最终导致系统响应变化的能力很差。
协同方式转变
过去由产品同学提出业务需求，研发同学根据业务需求的 tapd 进行技术方案设计，并编程实现。
这种协同方式的弊端在于：无法形成能够消除认知差异的模型。产品同学从业务角度提出用户需求，这些需求可能是易变的、定制化的，而研发同学在缺少行业经验的情况下，往往会选择直译，即根据需求直接转换为数据模型。而研发同学从技术实现角度设计技术方案，其中涉及很多的技术细节，产品同学无法从中判断是否与自己提出的业务诉求和产品规划相一致，最终形成认知差异。且认知差异会随着迭代不断被放大，最后系统变成一个大泥球。
DDD 通过解锁新角色” 领域专家 &amp;ldquo; 以及模型驱动设计，有效地降低产品和研发的认知差异。 领域专家是具有丰富行业经验和领域知识储备的人，他们能够在易变的、定制化的需求中提炼出清晰的边界，稳定的、可复用的领域概念和业务规则，并携手产品和研发共同构建出领域模型。领域模型是对业务需求的知识表达形式，它不涉及具体的技术细节（但能够指导研发同学进行编程实现），因此消除了产品和研发在需求认知上的鸿沟。而模型驱动设计则要求领域模型能够关联业务需求和编码实现，模型的变更意味着需求变更和代码变更，协作围绕模型为中心。
精炼循环
精炼循环指的是在统一语言，提炼领域概念，明确边界，构建模型，绑定实现过程中，这些环节相互影响和反馈，在不断的迭代试错 - 调整以最终沉淀出稳定的、深层次的模型的过程。比如，我们在提炼领域概念的时候会觉得统一语言定义不合理 / 有歧义，此时我们就会调整统一语言的定义，并重新进行提炼领域概念。通过精炼循环，我们逐步形成稳定的领域模型。在 DDD 中，让领域专家来主导概念提炼、边界划分等宏观设计，原因就在于领域专家的经验和行业洞见来源于过去已经迭代的无数个精炼循环，因此由这些宏观设计推导出来的领域模型，往往都是非常稳定的。
精炼循环的核心是循环，它避免知识只朝单一方向流动，最终因各环节上的认知差异，最终导致模型无法在产品、领域专家和研发中达成一致、模型与实现割裂。
2.3 怎么才算 DDD？ 我早期实践 DDD 的时候，认为代码分层遵循四层架构就是 DDD，抑或分离接口和实现，实现下沉至基础设施层就是 DDD，实则不然。结合上述内容，目前个人认为只要满足以下条件即为实践 DDD：
 构建出产品、领域专家和研发同学认知一致且便于交流的模型，并且模型与实现紧密绑定； 模型逐步演进，反复消化和精炼； 模型蕴含领域知识，足够稳定。  3. 问题空间 &amp;amp; 解空间 3.1 问题空间 &amp;amp; 解空间 问题空间和解空间并非 DDD 特有的概念，而是人们为了区分真实世界和理念世界而提出的概念。问题空间表示的是真实世界，是具体的问题、用户的诉求，而解空间则是针对问题空间求解后构建的理念世界，其中包括了解决方案、模型等。
DDD 提出的战略设计覆盖了问题空间和解空间，而战术设计则聚焦在解空间上。明确 DDD 中的概念是作用于问题空间还是解空间，更有助于我们理解它们。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/%E5%88%A9%E7%94%A8-nginx-%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E5%88%A9%E7%94%A8-nginx-%E8%AE%BE%E7%BD%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</guid>
      <description>本文由 简悦 SimpRead 转码， 原文地址 www.cnblogs.com
来源：利用nginx设置浏览器协商缓存 - debugger.wiki - debugger.wiki 用途：备忘 强缓存与协商缓存的区别 强缓存：浏览器不与服务端协商直接取浏览器缓存 协商缓存：浏览
 来源：利用 nginx 设置浏览器协商缓存 - debugger.wiki - debugger.wiki
用途：备忘
强缓存与协商缓存的区别
　强缓存：浏览器不与服务端协商直接取浏览器缓存
　协商缓存：浏览器会先向服务器确认资源的有效性后才决定是从缓存中取资源还是重新获取资源
协商缓存运作原理
　现在有一个这样的业务情景：后端的静态资源会不定时地发生更新，而因为浏览器默认使用强缓存，会默认从浏览器缓存中取到过时的资源。
　现在我们希望浏览器每次获取资源的时候都向后端确认资源是否更新，就要设置浏览器使用协商缓存
　那么后端如何判断资源是否更新了呢？这时就要用到 Etag 和 Last-Modified 两项响应头。
　每次收到一个静态资源的请求时，后端都将资源的最后修改时间（Last-Modified）、根据资源内容计算出来的 Etag 放在响应头给前端。
　前端收到响应后将这两项缓存起来，然后在下次请求同样资源的时候，将这两项的内容放到 If-Modified-Since 和 If-None-Match 这两项请求头中。
　服务端收到这两项后，会与资源当前生成的 Etag 和 Last-Modified 做比较，如果两者都一致，说明资源没有更新，服务端会返回 304 空响应；否则，说明资源有更新，服务端会将完整的资源内容返回
实现
　那么如何实现这样一个复杂的过程呢？其实很简单，只要使用 nginx 作为静态资源的服务器，再在响应头加上 Cache-Control:no-cache 就可以了。
　下面来分步骤实现一下
　1. 使用 nginx 作为静态资源的服务器
　在 nginx 的配置中，将对静态资源的请求映射到资源的磁盘路径上

 1 http { 2 server { 3 listen 80; 4 ... 5 location /picture/ { 6 alias D:/luozixi/tcp_test/picture/; 7 # alias是重定义路径 8 # 比如访问127.0.0.1/picture/1_new.gif，则会映射为访问D:/luozixi/tcp_test/picture/1_new.gif 9 # web应用根本不会收到请求，picture的请求都被nginx处理了 10 # alias是替换，root是拼接 11 autoindex on; 12 # 访问127.0.0.1/picture/，会得到目录的索引界面 13 } 14 } 15 }  
　2. 重新加载 nginx 配置
nginx -s reload  　3. 此时，请求静态资源的时候 nginx 会自动在 response 头中加上 Etag 和 Last-Modified 两项</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/%E5%A5%BD%E7%9C%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E4%BD%A0%E8%BF%98%E4%B8%8D-fork/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E5%A5%BD%E7%9C%8B%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%BD%91%E9%A1%B5%E4%BD%A0%E8%BF%98%E4%B8%8D-fork/</guid>
      <description>唔，这个本来是之前做的一个电商的项目，咱当时还没有学很多东西，就是粗略的做了一下，最近呢，咱改了一些样式以及增加了一些功能，就想着给大家康康，变好看了不少！✨
 🍉🍉🍉这是之前写的文章，~当时一下就冲上热榜了（bushi~
 话不多说，上项目！！ 大家先来康康效果图吧：
 最近新学的布局，点击就可以进入首页了呀！🍓🍓🍓
✨✨这里还有一个小惊喜哦，点击哪张图片哪张图片就会撑开让你看到全貌，有很不错的动画效果哦～
   进入首页后就可以看到我们的 VR 观景部分啦，每个图片都是一个 B 站的视频链接，但是由于水平有限做不成 VR 的效果，有无大佬可以指点指点，~求求了💦💦💦~
⛄⛄~（虽然这方面技术不行，但视频都是精心挑选的）~
  主页看完了，再来看看文创购买界面吧！
 这个界面布局大体沿用 VR 观景页面，不过有小细节哦！
鼠标悬停在商品上面可以看到图片正在缓缓的放大，是动画效果哦～
🐠🐠🐠
  开始页面源码：🐯 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;元之旅&amp;lt;/title&amp;gt; &amp;lt;link href=&#39;https://fonts.googleapis.com/css?family=Amatic+SC&#39; rel=&#39;stylesheet&#39; type=&#39;text/css&#39;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;style&amp;gt; html { box-sizing: border-box; background: #ffc600; font-family:&#39;helvetica neue&#39;; font-size: 20px; font-weight: 200; } body { margin: 0; } *,*:before,*:after { box-sizing: inherit; } .panels { min-height: 100vh; overflow: hidden; display: flex; } .panel { background: #6B0F9C; box-shadow: inset 0 0 0 5px rgba(255, 255, 255, 0.1); color: white; text-align: center; align-items: center; transition: font-size 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), /* flex的变化用0.7s的渐变动画，渐变动画的时间函数是贝塞尔曲线，具体参数就和他写的似的 */ flex 0.7s cubic-bezier(0.61,-0.19, 0.7,-0.11), /* 就是对于background的变化 采用0.2s的渐变动画 */ background 0.2s; font-size: 20px; background-size: cover; background-position: center; flex: 1; justify-content: center; align-items: center; display: flex; /* 属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。 */ flex-direction: column; } .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E5%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8D%B7%E7%A7%AF%E5%B1%82/</guid>
      <description>单隐藏层就已经需要14GB的参数了！平移不变性：识别器不会因为像素的位置而发生改变局部性：找Waldo只需要看局部的信息即可，不需要看全局的信息个人理解：由前面的例子可知，全连接层需要的参数量会非常多，这也就使得MLP受到了限制。但是为了解决问题，提出了“平移不变性”和“局部性”两个性质。我们从全连接层出发，应用两种性质，对原本的计算方式做一些改进，也就得到了卷积层的计算方式。相较于全连接，平移不变性使得卷积的权重在一定范围内，v是相同的；但是由于局&amp;hellip;
 单隐藏层就已经需要 14GB 的参数了！
平移不变性：识别器不会因为像素的位置而发生改变
局部性：找 Waldo 只需要看局部的信息即可，不需要看全局的信息
个人理解：由前面的例子可知，全连接层需要的参数量会非常多，这也就使得 MLP 受到了限制。但是为了解决问题，提出了 “平移不变性” 和“局部性”两个性质。我们从全连接层出发，应用两种性质，对原本的计算方式做一些改进，也就得到了卷积层的计算方式。相较于全连接，平移不变性使得卷积的权重在一定范围内，v 是相同的；但是由于局部性的存在，当 | a|，|b| &amp;gt; Δ的时候，v = 0。这样就极大地优化了参数量。由此，卷积层是一个特殊的全连接层，那么卷积层自然也像全连接层一样，能够进行梯度计算和反向传播从而学习到参数。
 import torch from torch import nn from d2l import torch as d2l def corr2d(X, K): &amp;quot;&amp;quot;&amp;quot;计算二维互相关运算&amp;quot;&amp;quot;&amp;quot; h, w = K.shape Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] = (X[i: i + h, j: j + w] * K).sum() return Y X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]]) K = torch.tensor([[0.0, 1.0], [2.0, 3.0]]) print(corr2d(X, K)) # 实现二维卷积层 class Conv2D(nn.Module): def __init__(self, kernel_size): super().__init__() self.weight = nn.Parameter(torch.rand(kernel_size)) self.bias = nn.Parameter(torch.zeros(1)) def forward(self, x): return corr2d(x, self.weight) + self.bias # 简单应用：检测图像中不同颜色的边缘 X = torch.ones((6, 8)) X[:, 2: 6] = 0 print(X) K = torch.tensor([[1.0, -1.0]]) Y = corr2d(X, K) print(Y) # 学习由X生成Y的卷积核 conv2d = nn.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/tlg/output/%E7%99%BD%E8%AF%9D%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%A4%A7%E5%8E%82%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84_%E5%B0%8F%E7%8E%8B%E6%9B%BE%E6%98%AF%E5%B0%91%E5%B9%B4%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN-%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E7%99%BD%E8%AF%9D%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E5%A4%A7%E5%8E%82%E6%98%AF%E6%80%8E%E4%B9%88%E7%8E%A9%E7%9A%84_%E5%B0%8F%E7%8E%8B%E6%9B%BE%E6%98%AF%E5%B0%91%E5%B9%B4%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN-%E5%8D%9A%E5%AE%A2/</guid>
      <description>上古时代的应用 用户访问请求通过各级负载均衡到达了反向代理层，反向代理层会把访问请求转到服务器集群中，这就是经典的单体应用 + 水平扩展
缺点：
 牵一发而动全身
每台服务器部署的代码都一样，每一个小的改动都很有可能影响到其它的功能点，所以每次改动都要做一个全链路回归
 回滚很痛苦
所有代码一起上线一起回滚，就有可能出现我写好了一个功能，但因为别人的 bug 而被回滚了
 发布周期长
平均半年才发布一次版本，无法快速适应市场需求
 应用复杂度很高
○ 代码会被混用，写的一个基础代码可能会被各个服务方共同使用，小的改动可能带来意料之外的影响。
○ 数据访问混乱，数据可能会被单体应用里的各个应用所引用（底层数据未做隔离的代价）
   这一类代码也就是程序员们经常调侃的 “屎山”，谁也不敢碰的代码
 996 时代的应用 当引入了微服务的架构之后，应用也来到了 996 的时代，此时，每一个服务器部署的应用都不一样，每个应用的底层数据库也是不同的，这就避免了底层数据模型的混乱
优点：
 小步快跑
每个应用都可以做独立演进、独立部署、快速迭代
 团队赋能
每一个微服务背后都有一个微服务的团队，包括前端、后端、测试等完整角色，这种情况下开发团队的话语权肯定要高于传统瀑布模型团队的
 边界清晰
○ 服务拆分：以大化小
○ 体现了分治思想：三高应用
  互联网精神：小步快跑 那么在微服务的架构下，大厂里的团队组成是什么样的呢？
 一般团队成员都是小规模，同时 Leader 也并不是专门管人的角色，可写代码可和产品拉扯
 阿里系都是小规模的微服务团队，比如订单域，订单和支付系统的对接可能由一个团队来负责，订单状态流转又是另一个团队来负责
 在每个精英团队都会做双备份机制，重沟通，轻文档，业务知识的积累一般是沉淀到个人，因此每个开发人员在自己业务线上积累的知识非常重要，快速定位问题、解决线上问题都需要这个人来参与，对每个重要功能点都会指定一个 Feature Owner，同时还会指定一个 Backup，保证有两个人能做线上的支持
 测试人员：阿里系推崇开发自测，功能和质量保证完全由个人承担。测试同学致力于测试平台、效能平台的搭建。对于功能性测试来说，一般不指派到各个团队中，而是指派到中间的职能方，它可能是支持当前事业部或多个团队的测试需求，从集成测试的角度衡量质量保证的计划
  从上面的团队架构也能看出来，每个人的代码能力都是硬指标，只会测试或 CRUD 的程序员在职场上的生命周期都很短
同时，架构师作为 “设计师” 的角色，阿里系大量采用了跨团队架构师的职责，因为架构师要有整体视角，所以要有整体的业务方向视角，同时还有其他的职能团队负责一些特殊的业务，比如为应用搭建手机端页面等等</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.1-static%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E9%80%94%E8%AF%B7%E8%87%B3%E5%B0%91%E8%AF%B4%E6%98%8E%E4%B8%A4%E7%A7%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.1-static%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E9%80%94%E8%AF%B7%E8%87%B3%E5%B0%91%E8%AF%B4%E6%98%8E%E4%B8%A4%E7%A7%8D/</guid>
      <description>题目： static有什么用途？（请至少说明两种） 参考答案： 1) 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。 2) 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。 3) 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.2-%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.2-%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>题目：引用与指针有什么区别？ 参考答案： 1) 引用必须被初始化，指针不必。 2) 引用初始化以后不能被改变，指针可以改变所指的对象。 3) 不存在指向空值的引用，但是存在指向空值的指针。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.3-%E6%8F%8F%E8%BF%B0%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.3-%E6%8F%8F%E8%BF%B0%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7/</guid>
      <description>题目：描述实时系统的基本特性 参考答案： 在特定时间内完成特定的任务，实时性与可靠性。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.4-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%BA%E5%88%AB%E5%A6%82%E6%9E%9C%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.4-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%BA%E5%88%AB%E5%A6%82%E6%9E%9C%E6%9C%89%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>题目：全局变量和局部变量在内存中是否有区别？如果有，是什么区别？ 参考答案： 全局变量储存在静态数据库，局部变量在堆栈。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>题目：什么是平衡二叉树？ 参考答案： 左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.6-%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%80%E8%88%AC%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.6-%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%80%E8%88%AC%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84/</guid>
      <description>题目：堆栈溢出一般是由什么原因导致的？ 参考答案： 没有回收垃圾资源。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.7-%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.7-%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0/</guid>
      <description>题目：什么函数不能声明为虚函数？ 参考答案： constructor函数不能声明为虚函数。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.8-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.8-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>题目： 冒泡排序算法的时间复杂度是什么？ 参考答案： 时间复杂度是O(n^2)。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.9.-Internet%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.1.9.-Internet%E9%87%87%E7%94%A8%E5%93%AA%E7%A7%8D%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E8%AF%A5%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</guid>
      <description>题目：Internet采用哪种网络协议？该协议的主要层次结构？ 参考答案： Tcp/Ip协议 主要层次结构为： 应用层/传输层/网络层/数据链路层/物理层。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.0-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%88%86%E4%B8%BA%E5%93%AA%E4%BF%A9%E9%83%A8%E5%88%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.0-IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BC%96%E7%A0%81%E5%88%86%E4%B8%BA%E5%93%AA%E4%BF%A9%E9%83%A8%E5%88%86/</guid>
      <description>题目：IP地址的编码分为哪俩部分？ 参考答案： IP地址由两部分组成，网络号和主机号。不过是要和“子网掩码”按位与上之后才能区分哪些是网络位哪些是主机位。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.1-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5MN%E5%80%BC%E4%BB%8E1%E8%87%B3N%E5%BC%80%E5%A7%8B%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%95%B0%E6%AF%8F%E6%95%B0%E5%88%B0M%E8%BE%93%E5%87%BA%E8%AF%A5%E6%95%B0%E5%80%BC%E7%9B%B4%E8%87%B3%E5%85%A8%E9%83%A8%E8%BE%93%E5%87%BA%E5%86%99%E5%87%BAC%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.1-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5MN%E5%80%BC%E4%BB%8E1%E8%87%B3N%E5%BC%80%E5%A7%8B%E9%A1%BA%E5%BA%8F%E5%BE%AA%E7%8E%AF%E6%95%B0%E6%95%B0%E6%AF%8F%E6%95%B0%E5%88%B0M%E8%BE%93%E5%87%BA%E8%AF%A5%E6%95%B0%E5%80%BC%E7%9B%B4%E8%87%B3%E5%85%A8%E9%83%A8%E8%BE%93%E5%87%BA%E5%86%99%E5%87%BAC%E7%A8%8B%E5%BA%8F/</guid>
      <description>题目：用户输入M,N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。 参考答案： 循环链表，用取余操作做</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.2-%E6%9F%9032%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8B-C&#43;&#43;%E7%A8%8B%E5%BA%8F%E8%AF%B7%E8%AE%A1%E7%AE%97sizeof-%E7%9A%84%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/02.%E5%8D%8E%E4%B8%BA%E7%AF%87/2.2.2-%E6%9F%9032%E4%BD%8D%E7%B3%BB%E7%BB%9F%E4%B8%8B-C&#43;&#43;%E7%A8%8B%E5%BA%8F%E8%AF%B7%E8%AE%A1%E7%AE%97sizeof-%E7%9A%84%E5%80%BC/</guid>
      <description> 题目：某32位系统下, C++程序，请计算sizeof 的值. 参考答案： char str[] = “http://www.ibegroup.com/” char *p = str ; int n = 10; 请计算 sizeof (str ) = ？（1） sizeof ( p ) = ？（2） sizeof ( n ) = ？（3） void Foo ( char str[100]){ 请计算 sizeof( str ) = ？（4） } void *p = malloc( 100 ); 请计算 sizeof ( p ) = ？（5） （1）17 （2）4 （3） 4 （4）4 （5）4  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/03.%E7%99%BE%E5%BA%A6%E7%AF%87/3.4.8-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B7%B2%E7%9F%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%BA%86%E4%B8%80%E5%8D%8A%E8%AF%B7%E7%94%A8On%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/03.%E7%99%BE%E5%BA%A6%E7%AF%87/3.4.8-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B7%B2%E7%9F%A5%E4%B8%80%E4%B8%AA%E6%95%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%BA%86%E4%B8%80%E5%8D%8A%E8%AF%B7%E7%94%A8On%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E7%AE%97%E6%B3%95%E6%89%BE%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0/</guid>
      <description> 题目：找出数组中出现次数超过一半的数，现在有一个数组，已知一个数出现的次数超过了一半，请用O(n)的复杂度的算法找出这个数。 出题人：阿里巴巴新零售技术质量部 参考答案： 遍历数组的同时用Object来储存每个元素出现的个数，每次遍历都跟max比较
参考代码： const arr =[1,2,3,4,5,6,7,8,89,9,9,9,9,99]; const maxNumObj =(arr)=&amp;gt;{ return arr.reduce((obj,cur)=&amp;gt;{ if(!obj[&#39;max&#39;]){ obj[&#39;max&#39;]=arr[0]; } obj[cur] = ++obj[cur]||1; if(obj[cur]&amp;gt;obj[&#39;max&#39;]){ obj[&#39;max&#39;] = obj[cur] } return obj; },{})[&#39;max&#39;]; }  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/03.%E7%99%BE%E5%BA%A6%E7%AF%87/3.4.9-%E6%89%BE%E5%87%BA%E8%A2%AB%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/03.%E7%99%BE%E5%BA%A6%E7%AF%87/3.4.9-%E6%89%BE%E5%87%BA%E8%A2%AB%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description> 题目： 找出被修改过的数字 出题人：阿里巴巴新零售技术质量部 参考答案： emmm假设背景是寻找数组中被修改的数字或者元素，我使用代理的方式来监听数组中元素的变化，并将变化的最后数值和次数储存在额外空间中
参考代码： const arr =[1,2,3,4,5,6,7,8,89,9,9,9,9,99]; const saveModifyNum={ } const watchNumChangeProxy=new Proxy(arr,{ set:function(target,key,value){ let {count} = Reflect.get(saveModifyNum,target[key])||{count:0,value}; ++count; return Reflect.set(saveModifyNum,target[key],{ count, value }); } }) watchNumChangeProxy[0]=2; watchNumChangeProxy[0]=3; watchNumChangeProxy[0]=4; //{ &#39;1&#39;: { count: 3, value: 4 } }  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/05.%E7%BE%8E%E5%9B%A2%E7%AF%87/5.2.0-%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/05.%E7%BE%8E%E5%9B%A2%E7%AF%87/5.2.0-%E6%B5%85%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B7%B1%E5%A4%8D%E5%88%B6%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%A4%8D%E5%88%B6/</guid>
      <description> 题目：浅复制和深复制？怎样实现深复制？ 出题人：阿里巴巴新零售技术质量部 参考答案： 参考代码; const isObject = (item)=&amp;gt;{ return Object.prototype.toString.call(item) === &#39;[object Object]&#39;; } const isArray = (item)=&amp;gt;{ return Object.prototype.toString.call(item) === &#39;[object Array]&#39;; } const deepClone=(obj)=&amp;gt;{ const cloneObj=isArray(obj)?[]:isObject(obj)?{}:&#39;&#39;; for(let key in obj){ if(isObject(obj[key])||isArray(obj[key])){ Object.assign(cloneObj,{ [key]: deepClone(Reflect.get(obj,key)) }); } else{ cloneObj[key] = obj[key]; } } return cloneObj; }  PS:可以处理这样的格式,仅处理了对象类型和数组类型
const obj111 ={ a:1, b:{ c:2, d:{ e:3 }, f:[1,{a:1,b:2},3] } }  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/06.%E5%A4%B4%E6%9D%A1%E7%AF%87/%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E9%80%9A%E8%B7%AF%E9%95%BF%E5%BA%A6%E5%8D%B3%E6%9C%80%E5%A4%A7%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/06.%E5%A4%B4%E6%9D%A1%E7%AF%87/%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E6%9C%80%E5%A4%A7%E9%80%9A%E8%B7%AF%E9%95%BF%E5%BA%A6%E5%8D%B3%E6%9C%80%E5%A4%A7%E5%B7%A6%E5%8F%B3%E5%AD%90%E6%A0%91%E9%AB%98%E5%BA%A6%E4%B9%8B%E5%92%8C/</guid>
      <description>题目：一棵二叉树，求最大通路长度（即最大左右子树高度之和） 参考答案： 该题与leetcode第104题同题型，定义TreeNode结构如下：
class TreeNode { int val; TreeNode left; TreeNode right; public TreeNode(int val) { this.val = val; } }  解法一(递归求解)
class Solution { public int maxHeight(TreeNode root) { if (root == null) { return 0; } return maxChildHeight(root.left) + maxChildHeight(root.right); } public int maxChildHeight(TreeNode root) { if (root == null) { return 0; } int leftHeight = maxChildHeight(root.left); int rightHeight = maxChildHeight(root.right); return Math.max(leftHeight, rightHeight) + 1; } }  解法二(迭代求解)
public class Solution { public int maxHeight(TreeNode root) { if (root == null) { return 0; } return maxChildHeight(root.left) + maxChildHeight(root.right); } public int maxChildHeight(TreeNode root) { int height = 0; Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;(); queue.add(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i &amp;lt; size; i++) { TreeNode node = queue.poll(); height++; if (node.left != null) { queue.add(node.left); } if (node.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/08.%E4%BA%AC%E4%B8%9C%E7%AF%87/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8Bhadoop%E5%92%8Cspark%E7%9A%84shuffle%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/08.%E4%BA%AC%E4%B8%9C%E7%AF%87/%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8Bhadoop%E5%92%8Cspark%E7%9A%84shuffle%E8%BF%87%E7%A8%8B/</guid>
      <description>问题：简单说一下hadoop和spark的shuffle过程 出题人：京东出题专家：阿昀/京东数据中台 参考答案： Hadoop：map端保存分片数据，通过网络收集到reduce端。
Spark：spark的shuffle实在DAGSchedular划分Stage的时候产生的，TaskSchedular要分发Stage到各个worker的executor。减少shuffle可以提高性能。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.0-%E4%B8%BB%E9%94%AE-%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E5%A4%96%E9%94%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.0-%E4%B8%BB%E9%94%AE-%E8%B6%85%E9%94%AE-%E5%80%99%E9%80%89%E9%94%AE-%E5%A4%96%E9%94%AE/</guid>
      <description>题目：主键 超键 候选键 外键是什么 定义 超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键
候选键(candidate key): 不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是键了！
主键(primary key): 用户选作元组标识的一个候选键程序主键
外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。
举例 比如有如下数据：
   学号 姓名 性别 年龄 系别 专业     20020612 李辉 男 20 计算机 软件开发   20060613 张明 男 18 计算机 软件开发   20060614 王小玉 女 19 物理 力学   20060615 李淑华 女 17 生物 动物学   20060616 赵静 男 21 化学 食品化学   20060617 赵静 女 20 生物 植物学     超键
在关系中能唯一标识元组的属性集称为关系模式的超键。
于是我们从例子中可以发现 学号是标识学生实体的唯一标识。那么该元组的超键就为学号。
除此之外我们还可以把它跟其他属性组合起来，比如：
(学号，性别)
(学号，年龄)
这样也是超键.
 候选键
不含多余属性的超键为候选键。
根据例子可知，学号是一个可以唯一标识元组的唯一标识，因此学号是一个候选键，实际上，候选键是超键的子集，比如 （学号，年龄）是超键，但是它不是候选键。因为它还有了额外的属性。
 主键
用户选择的候选键作为该元组的唯一标识，那么它就为主键。
简单的说，例子中的元组的候选键为学号，但是我们选定他作为该元组的唯一标识，那么学号就为主键。
 外键
外键是相对于主键的，比如在学生记录里，主键为学号，在成绩单表中也有学号字段，因此学号为成绩单表的外键，为学生表的主键。
  总结 主键为候选键的子集，候选键为超键的子集，而外键的确定是相对于主键的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E5%8F%8A%E5%90%AB%E4%B9%89/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%E5%8F%8A%E5%90%AB%E4%B9%89/</guid>
      <description> 题目：数据库事务的四个特性及含义 参考答案： 数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。
 原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
 一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
 隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。
 持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.2-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.2-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E8%A7%86%E5%9B%BE%E5%8F%AF%E4%BB%A5%E6%9B%B4%E6%94%B9%E4%B9%88/</guid>
      <description>题目：视图的作用，视图可以更改么？ 参考答案： 视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。
创建视图：create view XXX as XXXXXXXXXXXXXX;
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.3-dropdelete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.3-dropdelete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>题目：drop,delete与truncate的区别 参考答案： drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。
（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。
（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。
（3） 一般而言，drop &amp;gt; truncate &amp;gt; delete
（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view
（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。
（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。
（7） delete语句为DML（Data Manipulation Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。
（8） truncate、drop是DDL（Data Define Language),操作立即生效，原数据不放到 rollback segment中，不能回滚
（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老是想触发trigger,还是用delete。
（10） Truncate table 表名 速度快,而且效率高,因为: truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。
（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。
（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.4-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.4-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E7%A7%8D%E7%B1%BB/</guid>
      <description>题目：索引的工作原理及其种类 参考答案： 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。
在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。
创建索引可以大大提高系统的性能。
第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。
第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。
第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
同样，对于有些列不应该创建索引。一般来说，不应该创建索引的的这些列具有下列特点：
第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。
第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。
根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。
唯一索引
唯一索引是不允许其中任何两行具有相同索引值的索引。
当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引 数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。 在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引 在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。
如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。
局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
B-/+Tree索引的性能分析 到这里终于可以分析B-/+Tree索引的性能了。
上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。
B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。
综上所述，用B-Tree作为索引结构效率是非常高的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.5-%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A7%8D%E7%B1%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.5-%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A7%8D%E7%B1%BB/</guid>
      <description>题目：连接的种类 参考答案： 查询分析器中执行：
--建表table1,table2： create table table1(id int,name varchar(10)) create table table2(id int,score int) insert into table1 select 1,&#39;lee&#39; insert into table1 select 2,&#39;zhang&#39; insert into table1 select 4,&#39;wang&#39; insert into table2 select 1,90 insert into table2 select 2,100 insert into table2 select 3,70  如表:
------------------------------------------------- table1 | table2 | ------------------------------------------------- id name |id score | 1 lee |1 90| 2 zhang| 2 100| 4 wang| 3 70| -------------------------------------------------  以下均在查询分析器中执行 一、外连接 1.概念：包括左向外联接、右向外联接或完整外部联接
2.左连接：left join 或 left outer join (1)左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值(null)。 (2)sql 语句
select * from table1 left join table2 on table1.id=table2.id -------------结果------------- idnameidscore ------------------------------ 1lee190 2zhang2100 4wangNULLNULL ------------------------------  注释：包含table1的所有子句，根据指定条件返回table2相应的字段，不符合的以null显示
3.右连接：right join 或 right outer join (1)右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 (2)sql 语句
select * from table1 right join table2 on table1.id=table2.id -------------结果------------- idnameidscore ------------------------------ 1lee190 2zhang2100 NULLNULL370 ------------------------------  注释：包含table2的所有子句，根据指定条件返回table1相应的字段，不符合的以null显示
4.完整外部联接:full join 或 full outer join (1)完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 (2)sql 语句</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.6-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</guid>
      <description>题目：数据库范式 参考答案： 1 第一范式（1NF）
在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。简而言之，第一范式就是无重复的列。
2 第二范式（2NF）
第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。
3 第三范式（3NF）
满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。（我的理解是消除冗余）</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.7-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF/</guid>
      <description>题目：数据库优化的思路 参考答案： 这个我借鉴了慕课上关于数据库优化的课程。
1.SQL语句优化
 应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描。
 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
select id from t where num is null  可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：
select id from t where num=0  liueleven 的评论：
不是非我杠精，关于null,isNull,isNotNull其实是要看成本的，是否回表等因素总和考虑，才会决定是要走索引还是走全表扫描。  也给大家找了一个作者的博文（MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！），仅供参考！！！
[zhiyong0804d的意见]
之所以未把第二条删除还是考虑可能很多人都被误导了。那这样的组织能让大家兼听则明。
 很多时候用 exists 代替 in 是一个好的选择。
 用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤。
  2.索引优化
看上文索引  3.数据库结构优化
 范式优化： 比如消除冗余（节省空间。。）
 反范式优化：比如适当加冗余等（减少join）
 拆分表：分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
 拆分其实又分垂直拆分和水平拆分：
  案例： 简单购物系统暂设涉及如下表：
1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势）  以mysql为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万
垂直拆分：
解决问题：表与表之间的io竞争
不解决问题：单表中数据量增长出现的压力
方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上
水平拆分：
解决问题：单表中数据量增长出现的压力
不解决问题：表与表之间的io争夺
方案：用户表 通过性别拆分为男用户表和女用户表，订单表 通过已完成和完成中拆分为已完成订单和未完成订单，产品表 未完成订单放一个server上，已完成订单表盒男用户表放一个server上，女用户表放一个server上(女的爱购物 哈哈)。
4.服务器硬件优化
这个么多花钱咯！</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.8-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.8-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>题目：存储过程与触发器的区别 参考答案： 触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。
触发器是在一个修改了指定表中的数据时执行的存储过程。
通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。
触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.9-%E8%A7%A3%E9%87%8A-SQL-%E7%9A%84-left-join-%E5%92%8C-right-join/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/09.MySQL%E7%AF%87/9.1.9-%E8%A7%A3%E9%87%8A-SQL-%E7%9A%84-left-join-%E5%92%8C-right-join/</guid>
      <description> 题目：解释 SQL 的 left join 和 right join 出题人：阿里巴巴新零售技术质量部 参考答案： left join 和 right join 都是两个表进行 merge 的操作，left join 是将右边的表 merge 到左边，right join 是将左边的表 merge 到右边，通常我们会指定按照哪几列进行 merge
举个例子：
left table
   姓名 学号     小红 SZ1716029   小明 SZ1716030   小王 SZ1716031    right table
   学号 排名     SZ1716029 1   SZ1716030 2    left table left join right table on 学号
   学号 姓名 排名     SZ1716029 小红 1   SZ1716030 小明 2   SZ1716031 小王 NULL    left table right join right table on 学号
   学号 姓名 排名     SZ1716029 小红 1   SZ1716030 小明 2    </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.0-%E4%BD%BF%E7%94%A8Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.0-%E4%BD%BF%E7%94%A8Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84/</guid>
      <description>题目： 参考答案： (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
(2) 支持丰富数据类型，支持string，list，set，sorted set，hash
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.1-redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.1-redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF/</guid>
      <description>redis相比memcached有哪些优势？： 参考答案： (1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
(2) redis的速度比memcached快很多
(3) redis可以持久化其数据</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.2-redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.2-redis%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>题目：redis常见性能问题和解决方案 参考答案： (1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件
(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次
(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内
(4) 尽量避免在压力很大的主库上增加从库
(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &amp;lt;- Slave1 &amp;lt;- Slave2 &amp;lt;- Slave3&amp;hellip;
这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.3-MySQL%E9%87%8C%E6%9C%892000w%E6%95%B0%E6%8D%AEredis%E4%B8%AD%E5%8F%AA%E5%AD%9820w%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.3-MySQL%E9%87%8C%E6%9C%892000w%E6%95%B0%E6%8D%AEredis%E4%B8%AD%E5%8F%AA%E5%AD%9820w%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE/</guid>
      <description>题目：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据 参考答案： 相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。redis 提供 6种数据淘汰策略：
voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.3-zookeeper%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84znode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.3-zookeeper%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84znode/</guid>
      <description>题目：zookeeper的四种类型的znode 参考答案： 1、PERSISTENT-持久化目录节点 客户端与zookeeper断开连接后，该节点依旧存在 2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点 客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号 3、EPHEMERAL-临时目录节点 客户端与zookeeper断开连接后，该节点被删除 4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点 客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.4-Memcache%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.4-Memcache%E4%B8%8ERedis%E7%9A%84%E5%8C%BA%E5%88%AB%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description>题目：Memcache与Redis的区别都有哪些？ 参考答案： 1)、存储方式
Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。
Redis有部份存在硬盘上，这样能保证数据的持久性。
2)、数据支持类型
Memcache对数据类型支持相对简单。
Redis有复杂的数据类型。
3)、使用底层模型不同
它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
4），value大小
redis最大可以达到1GB，而memcache只有1MB</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.5-Redis-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.5-Redis-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/</guid>
      <description>题目：Redis 常见的性能问题都有哪些？如何解决？ 参考答案： 1) Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
2) Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
3) Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
4) Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.6-redis%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.6-redis%E6%9C%80%E9%80%82%E5%90%88%E7%9A%84%E5%9C%BA%E6%99%AF/</guid>
      <description>题目：redis 最适合的场景 参考答案： Redis最适合所有数据in-memory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached,何时使用Redis呢?
如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
1) Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 2) Redis支持数据的备份，即master-slave模式的数据备份。 3) Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.7-Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.7-Redis%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88/</guid>
      <description>题目：Redis的同步机制了解么？ 参考答案： 主从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.8-%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%87Redis%E9%9B%86%E7%BE%A4%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/10.Redis%E7%AF%87/10.1.8-%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%87Redis%E9%9B%86%E7%BE%A4%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>题目：是否使用过Redis集群，集群的原理是什么？ 参考答案： Redis Sentinel着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.0-%E4%BB%80%E4%B9%88%E6%98%AFMongoDB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.0-%E4%BB%80%E4%B9%88%E6%98%AFMongoDB/</guid>
      <description>题目：什么是MongoDB 参考答案： MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库。采用BSON存储文档数据。2007年10月，MongoDB由10gen团队所发展。2009年2月首度推出。获得安装包和查看详细的API可以访问官网网址www.mongodb.com</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.1-MongoDB%E6%98%AF%E7%94%B1%E5%93%AA%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.1-MongoDB%E6%98%AF%E7%94%B1%E5%93%AA%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84/</guid>
      <description>题目：MongoDB是由哪种语言写的 参考答案： MongoDB用c++编写的，流行的开源数据库MySQL也是用C++开发的。C++1983年发行是一种使用广泛的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程模式。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.2-MongoDB%E7%9A%84%E4%BC%98%E5%8A%BF%E6%9C%89%E5%93%AA%E4%BA%9B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.2-MongoDB%E7%9A%84%E4%BC%98%E5%8A%BF%E6%9C%89%E5%93%AA%E4%BA%9B/</guid>
      <description> 题目：MongoDB的优势有哪些 参考答案： 面向文档的存储：文档存储以BSON格式(有大小限制，最大16M), 内置GridFS文件系统(一般存储大于16M的文件)。
 任何属性都可以建立索引。
 复制以及高可扩展性。
 自动分片。
 丰富的查询功能。
 快速的即时更新。
 来自 MongoDB 的专业支持。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>题目：什么是数据库 参考答案： 数据库可以看成是一个电子化的文件柜,用户可以对文件中的数据运行新增、检索、更新、删除等操作。数据库是一个所有集合的容器，在文件系统中每一个数据库都有一个相关的物理文件。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.4-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.4-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%86%E5%90%88/</guid>
      <description>题目：什么是集合 参考答案： 集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.5-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3/</guid>
      <description>题目：什么是文档 参考答案： 文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型数据库中table中的每一条记录相当于MongoDB中的一个文档。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.6-MongoDB%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD%E5%AF%B9%E6%AF%94%E5%9B%BE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.6-MongoDB%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD%E5%AF%B9%E6%AF%94%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.7-%E4%BB%80%E4%B9%88%E6%98%AFmongod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.7-%E4%BB%80%E4%B9%88%E6%98%AFmongod/</guid>
      <description>题目：什么是”mongod“ 参考答案： mongod是处理MongoDB系统的主要进程。它处理数据请求，管理数据存储，和执行后台管理操作。当我们运行mongod命令意味着正在启动MongoDB进程,并且在后台运行。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.8-mongod%E5%8F%82%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.8-mongod%E5%8F%82%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88/</guid>
      <description>题目：&amp;rdquo;mongod&amp;rdquo;参数有什么 参考答案： 传递数据库存储路径，默认是&amp;rdquo;/data/db&amp;rdquo; 端口号 默认是 &amp;ldquo;27017&amp;rdquo;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.9-%E4%BB%80%E4%B9%88%E6%98%AFmongo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.1.9-%E4%BB%80%E4%B9%88%E6%98%AFmongo/</guid>
      <description>题目：什么是&amp;rdquo;mongo&amp;rdquo; 参考答案： 它是一个命令行工具用于连接一个特定的mongod实例。当我们没有带参数运行mongo命令它将使用默认的端口号和localhost连接。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.0-MongoDB%E5%93%AA%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.0-MongoDB%E5%93%AA%E4%B8%AA%E5%91%BD%E4%BB%A4%E5%8F%AF%E4%BB%A5%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description> 题目：MongoDB哪个命令可以切换数据库 参考答案： MongoDB 用use+数据库名称的方式来创建数据库。use会创建一个新的数据库，如果该数据库存在，则返回这个数据库。
 use database_name
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>题目：什么是非关系型数据库 参考答案： 非关系型数据库是对不同于传统关系型数据库的统称。非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。由于简单的设计和非常好的性能所以被用于大数据和Web Apps等</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.2-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.2-%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B/</guid>
      <description> 题目：非关系型数据库有哪些类型 参考答案：  Key-Value 存储 Eg:Amazon S3
 图表 Eg:Neo4J
 文档存储 Eg:MongoDB
 基于列存储 Eg:Cassandra   </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.3-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8MOngoDB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.3-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8MOngoDB/</guid>
      <description> 题目：为什么用MOngoDB？ 参考答案：  架构简单
 没有复杂的连接
 深度查询能力,MongoDB支持动态查询。
 容易调试
 容易扩展
 不需要转化/映射应用对象到数据库对象
 使用内部内存作为存储工作区,以便更快的存取数据。
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.4-%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8MongoDB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.4-%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%BD%BF%E7%94%A8MongoDB/</guid>
      <description> 题目：在哪些场景使用MongoDB 参考答案：  大数据
 内容管理系统
 移动端Apps
 数据管理
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.5-MongoDB%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.5-MongoDB%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</guid>
      <description>题目：MongoDB中的命名空间是什么意思? 参考答案： MongoDB内部有预分配空间的机制，每个预分配的文件都用0进行填充。
数据文件每新分配一次，它的大小都是上一个数据文件大小的2倍，每个数据文件最大2G。
MongoDB每个集合和每个索引都对应一个命名空间，这些命名空间的元数据集中在16M的*.ns文件中，平均每个命名占用约 628 字节，也即整个数据库的命名空间的上限约为24000。
如果每个集合有一个索引（比如默认的_id索引），那么最多可以创建12000个集合。如果索引数更多，则可创建的集合数就更少了。同时，如果集合数太多，一些操作也会变慢。
要建立更多的集合的话，MongoDB 也是支持的，只需要在启动时加上“&amp;ndash;nssize”参数，这样对应数据库的命名空间文件就可以变得更大以便保存更多的命名。这个命名空间文件（.ns文件）最大可以为 2G。
每个命名空间对应的盘区不一定是连续的。与数据文件增长相同，每个命名空间对应的盘区大小都是随分配次数不断增长的。目的是为了平衡命名空间浪费的空间与保持一个命名空间数据的连续性。
需要注意的一个命名空间$freelist，这个命名空间用于记录不再使用的盘区（被删除的Collection或索引）。每当命名空间需要分配新盘区时，会先查看$freelist是否有大小合适的盘区可以使用，如果有就回收空闲的磁盘空间。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.6-%E5%93%AA%E4%BA%9B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81MongoDB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.6-%E5%93%AA%E4%BA%9B%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81MongoDB/</guid>
      <description> 题目 ： 哪些语言支持MongoDB? 参考答案：  C
 C++
 C#
 Java
 Node.js
 Perl
 Php 等
  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.7-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.7-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description> 题目：在MongoDB中如何创建一个新的数据库 参考答案： MongoDB 用 use + 数据库名称 的方式来创建数据库。use 会创建一个新的数据库，如果该数据库存在，则返回这个数据库。
 use mydb switched to db mydb
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.8-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.8-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%97%E8%A1%A8/</guid>
      <description> 题目：在MongoDB中如何查看数据库列表 参考答案： 使用命令&amp;rdquo;show dbs&amp;rdquo;
 show dbs
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.9-MongoDB%E4%B8%AD%E7%9A%84%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.2.9-MongoDB%E4%B8%AD%E7%9A%84%E5%88%86%E7%89%87%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</guid>
      <description>题目：MongoDB中的分片是什么意思 参考答案： 分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。
参考：https://docs.mongodb.com/manual/sharding/</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.0-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8MongoDB%E7%9A%84%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.0-%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%BD%BF%E7%94%A8MongoDB%E7%9A%84%E8%BF%9E%E6%8E%A5/</guid>
      <description>如何查看使用MongoDB的连接Sharding - MongoDB Manual21.如何查看使用MongoDB的连接
使用命令&amp;rdquo;db.adminCommand(“connPoolStats”)&amp;rdquo;
 db.adminCommand(“connPoolStats”)
 </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%8D%E5%88%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.2-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.2-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.3-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E9%99%A4%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.3-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E9%99%A4%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.4-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.4-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.5-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.5-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%BB%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E9%9B%86%E5%90%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.6-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.6-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.7-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E5%99%A8/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.8-MongoDB%E6%94%AF%E6%8C%81%E4%B8%BB%E9%94%AE%E5%A4%96%E9%94%AE%E5%85%B3%E7%B3%BB%E5%90%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.8-MongoDB%E6%94%AF%E6%8C%81%E4%B8%BB%E9%94%AE%E5%A4%96%E9%94%AE%E5%85%B3%E7%B3%BB%E5%90%97/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.9-MongoDB%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.3.9-MongoDB%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>MongoDB支持以下数据类型：
 String（字符串）：存储字符序列，使用UTF-8编码。 Integer（整数）：存储32或64位的有符号整数。 Double（双精度浮点数）：存储64位的双精度浮点数。 Boolean（布尔值）：存储true或false。 Date（日期）：存储日期时间。 ObjectId（对象ID）：存储文档的唯一标识符。 Array（数组）：存储一个或多个值的数组。 Binary Data（二进制数据）：存储二进制数据。 Undefined（未定义）：已废弃，不再使用。 Null（空值）：存储空值。 Regular Expression（正则表达式）：存储正则表达式。 JavaScript（JavaScript代码）：存储JavaScript代码。 Symbol（符号）：已废弃，不再使用。 Timestamp（时间戳）：存储时间戳。 Max key（最大键）：已废弃，不再使用。 Min key（最小键）：已废弃，不再使用。  MongoDB还支持嵌入式文档和地理位置数据类型。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.0-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E7%94%A8Code%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.0-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E7%94%A8Code%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E7%94%A8Regular-Expression%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9C%A8MongoDB%E4%B8%AD%E7%94%A8Regular-Expression%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8MongoDB%E4%B8%AD%E4%BD%BF%E7%94%A8Object-ID%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.2-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8MongoDB%E4%B8%AD%E4%BD%BF%E7%94%A8Object-ID%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>不使用自增是分布式维护起来非常困难。使用ObjectId可以保证不同机器都能用全局唯一的同种方法生成它并且确保不重复</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.3-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.3-%E5%A6%82%E4%BD%95%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.4-ObjectID%E6%9C%89%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.4-ObjectID%E6%9C%89%E5%93%AA%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90/</guid>
      <description>一共有四部分组成：时间戳、客户端ID、客户进程ID、三个字节的增量计数器</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.5-%E5%9C%A8MongoDb%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.5-%E5%9C%A8MongoDb%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95/</guid>
      <description>索引是为了解决数据搜索效率低下引入的一种特殊的数据结构。索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。简单的说，索引就是将文档按照某个（或某些）字段顺序组织起来，以便能根据该字段高效的查询。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.6-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.6-%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95/</guid>
      <description>MongoDB支持多种类型的索引，包括单字段索引、复合索引、多key索引、文本索引等，每种类型的索引有不同的使用场合。
按照类型可分为：
 单字段索引
对`person`集合建立对`age`的索引。 `{age: 1}` 代表升序索引，也可以通过`{age: -1}`来指定降序索引，对于单字段索引，升序/降序效果是一样的。 2. 复合索引  db.person.createIndex( {age: 1, name: 1} ) ```
  他是单字段索引的升级，可以对多个字段进行索引。按第一个字段排序，第一个字段相同的文档按第二个字段排序。
 多key索引
{&amp;quot;name&amp;quot; : &amp;quot;jack&amp;quot;, &amp;quot;age&amp;quot; : 19, habbit: [&amp;quot;football, runnning&amp;quot;]} db.person.createIndex( {habbit: 1} ) // 自动创建多key索引 db.person.find( {habbit: &amp;quot;football&amp;quot;} )   当索引的字段为数组时，创建出的索引称为多key索引，多key索引会为数组的每个元素建立一条索引，比如person表加入一个habbit字段（数组）用于描述兴趣爱好，需要查询有相同兴趣爱好的人就可以利用habbit字段的多key索引。
 其他索引  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.7-MongoDB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E6%9B%BF%E4%BB%A3%E4%BA%A7%E5%93%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.7-MongoDB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E6%9B%BF%E4%BB%A3%E4%BA%A7%E5%93%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.8-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.8-%E5%A6%82%E4%BD%95%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.9-%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.4.9-%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.0-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8AND%E6%88%96OR%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.0-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8AND%E6%88%96OR%E6%9D%A1%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9F%A5%E8%AF%A2%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.1-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.1-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.2-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.2-%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E6%A1%A3/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.3-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.3-%E5%9C%A8MongoDB%E4%B8%AD%E5%A6%82%E4%BD%95%E6%8E%92%E5%BA%8F/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E5%90%88/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.5-%E5%9C%A8MongoDB%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%AF%E6%9C%AC%E9%9B%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.5-%E5%9C%A8MongoDB%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%AF%E6%9C%AC%E9%9B%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.6-Mongodb%E5%AD%98%E5%82%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/11.MongoDB%E7%AF%87/11.5.6-Mongodb%E5%AD%98%E5%82%A8%E7%89%B9%E6%80%A7%E4%B8%8E%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.0-zookeeper%E6%98%AF%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.0-zookeeper%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
      <description>参考答案：  A high-performance coordination service for distributed applications
 Zookeeper是基于Google Chubby论文的开源实现，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、配置管理 等等。 由于Hadoop生态系统中很多项目都依赖于zookeeper，如Pig，Hive等， 似乎很像一个动物园管理员，于是取名为Zookeeper。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.1-zookeeper%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.1-zookeeper%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88/</guid>
      <description>题目：zookeeper提供了什么？ 参考答案： 1、文件系统 2、通知机制</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.2-zookeeper%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.2-zookeeper%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>题目：zookeeper文件系统 参考答案： zookeeper提供一个类似unix文件系统目录的多层级节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得zookeeper不能用于存放大量的数据，每个节点的存放数据上限为1M。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.3-zookeeper%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84znode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.3-zookeeper%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84znode/</guid>
      <description>题目：zookeeper的四种类型的znode 参考答案： PERSISTENT 持久化节点
PERSISTENT_SEQUENTIAL 顺序自动编号持久化节点，这种节点会根据当前已存在的节点数自动加 1
EPHEMERAL 临时节点， 客户端session超时这类节点就会被自动删除
EPHEMERAL_SEQUENTIAL 临时自动编号节点</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.4-zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.4-zookeeper%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6/</guid>
      <description> 题目：zookeeper通知机制 参考答案： client端会对某个znode建立一个watcher事件，当该znode发生变化时，zk会主动通知watch这个znode的client，然后client根据znode的变化来做出业务上的改变等。
watcher的特点：  轻量级：一个callback函数。 异步性：不会block正常的读写请求。 主动推送：Watch被触发时，由Zookeeper服务端主动将更新推送给客户端。 一次性：数据变化时，Watch只会被触发一次。如果客户端想得到后续更新的通知，必须要在 Watch 被触发后重新注册一个 Watch。 仅通知：仅通知变更类型，不附带变更后的结果。 顺序性：如果多个更新触发了多个Watch，那 Watch 被触发的顺序与更新顺序一致。  使用watch的注意事项：  由于watcher是一次性的，所以需要自己去实现永久watch 如果被watch的节点频繁更新，会出现“丢数据”的情况 watcher数量过多会导致性能下降  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.5-zookeeper%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.5-zookeeper%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>题目：zookeeper有哪些应用场景 参考答案： 1、名字服务
2、配置管理
3、集群管理
4、分布式锁
5、队列管理
6、消息订阅</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.6-zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.6-zk%E7%9A%84%E5%91%BD%E5%90%8D%E6%9C%8D%E5%8A%A1/</guid>
      <description>题目： zk的命名服务 参考答案： 命名服务是指通过指定的名字来获取资源或者服务的地址，利用zk创建一个全局的路径，即是唯一的路径，这个路径就可以作为一个名字，指向集群中的集群，提供的服务的地址，或者一个远程的对象等等。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.7-zk%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.7-zk%E7%9A%84%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1/</guid>
      <description>题目：zk的配置管理 参考答案： 程序分布式的部署在不同的机器上，将程序的配置信息放在zk的znode下，当有配置发生改变时，也就是znode发生变化时，可以通过改变zk中某个目录节点的内容，利用watcher通知给各个客户端，从而更改配置。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.8-zk%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.8-zk%E7%9A%84%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/</guid>
      <description>题目：zookeeper集群管理 参考答案： 所谓集群管理无在乎两点：是否有机器退出和加入、选举master。 对于第一点，所有机器约定在父目录下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道：它上船了。 新机器加入也是类似，所有机器收到通知：新兄弟目录加入，highcount又有了，对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.9-zk%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.1.9-zk%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>题目：zookeeper分布式锁 参考答案： 有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。 对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。 对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。
获取分布式锁的流程
在获取分布式锁的时候在locker节点下创建临时顺序节点，释放锁的时候删除该临时节点。客户端调用createNode方法在locker下创建临时顺序节点， 然后调用getChildren(“locker”)来获取locker下面的所有子节点，注意此时不用设置任何Watcher。客户端获取到所有的子节点path之后，如果发现自己创建的节点在所有创建的子节点序号最小，那么就认为该客户端获取到了锁。如果发现自己创建的节点并非locker所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时对其注册事件监听器。之后，让这个被关注的节点删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是locker子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。当前这个过程中还需要许多的逻辑判断。
代码的实现主要是基于互斥锁，获取分布式锁的重点逻辑在于BaseDistributedLock，实现了基于Zookeeper实现分布式锁的细节。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.0-zk%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.0-zk%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86/</guid>
      <description>题目：zk队列管理 参考答案： 两种类型的队列： 1、同步队列，当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达。 2、队列按照 FIFO 方式进行入队和出队操作。 第一类，在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 第二类，和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。在特定的目录下创建PERSISTENT_SEQUENTIAL节点，创建成功时Watcher通知等待的队列，队列删除序列号最小的节点用以消费。此场景下Zookeeper的znode用于消息存储，znode存储的数据就是消息队列中的消息内容，SEQUENTIAL序列号就是消息的编号，按序取出即可。由于创建的节点是持久化的，所以不必担心队列消息的丢失问题。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.1-zk%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.1-zk%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6/</guid>
      <description>题目：zk数据复制 参考答案： Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。  数据复制的好处：  1、容错：一个节点出错，不致于让整个系统停止工作，别的节点可以接管它的工作；  2、提高系统的扩展能力 ：把负载分布到多个节点上，或者增加节点来提高系统的负载能力；  3、提高性能：让客户端本地访问就近的节点，提高用户访问速度。  
从客户端读写访问的透明度来看，数据复制集群系统分下面两种：  1、写主(WriteMaster) ：对数据的修改提交给指定的节点。读无此限制，可以读取任何一个节点。这种情况下客户端需要对读与写进行区别，俗称读写分离；  2、写任意(Write Any)：对数据的修改可提交给任意的节点，跟读一样。这种情况下，客户端对集群节点的角色与变化透明。 
对zookeeper来说，它采用的方式是写任意。通过增加机器，它的读吞吐能力和响应能力扩展性非常好，而写，随着机器的增多吞吐能力肯定下降（这也是它建立observer的原因），而响应能力则取决于具体实现方式，是延迟复制保持最终一致性，还是立即复制快速响应。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.2-zk%E4%B8%ADzab%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.2-zk%E4%B8%ADzab%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</guid>
      <description>题目：zk中zab的工作原理 参考答案： ZAB 是 ZooKeeper Atomic Broadcast （ZooKeeper 原子广播协议）的缩写，它是特别为 ZooKeeper 设计的崩溃可恢复的原子消息广播算法。ZooKeeper 使用 Leader来接收并处理所有事务请求，并采用 ZAB 协议，将服务器数据的状态变更以事务 Proposal 的形式广播到所有的 Follower 服务器上去。这种主备模型架构保证了同一时刻集群中只有一个服务器广播服务器的状态变更，因此能够很好的保证事物的完整性和顺序性。
Zab协议有两种模式，它们分别是恢复模式(recovery)和广播模式(broadcast)。当服务启动或者在leader崩溃后，Zab就进入了恢复模式，当leader被选举出来，且大多数follower完成了和leader的状态同步以后， 恢复模式就结束了，ZAB开始进入广播模式。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.3-zk%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.3-zk%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7/</guid>
      <description>题目：zookeeper是如何保证事务的顺序一致性的？ 参考答案： zookeeper采用了递增的事务Id来标识，所有的proposal（提议）都在被提出的时候加上了zxid，zxid实际上是一个64位的数字，高32位是epoch（时期; 纪元; 世; 新时代）用来标识leader是否发生改变，如果有新的leader产生出来，epoch会自增，低32位用来递增计数。当新产生proposal的时候，会依据数据库的两阶段过程，首先会向其他的server发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.4-zk%E9%9B%86%E7%BE%A4%E4%B8%8Bserver%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.4-zk%E9%9B%86%E7%BE%A4%E4%B8%8Bserver%E5%B7%A5%E4%BD%9C%E7%8A%B6%E6%80%81/</guid>
      <description>题目：zk集群下server工作状态 参考答案： 每个Server在工作过程中有四种状态：
LOOKING：当前Server不知道leader是谁，正在搜寻
LEADING：当前server角色为leader
FOLLOWING：当前server角色为follower
OBSERVING：当前server角色为observer</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.5-zk%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BELeader%E7%9A%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.5-zk%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BELeader%E7%9A%84/</guid>
      <description>题目：zookeeper是如何选举Leader的? 参考答案： 当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。
1、Zookeeper选主流程(basic paxos) （1）选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server； （2）选举线程首先向所有Server发起一次询问(包括自己)； （3）选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(id,zxid)，并将这些信息存储到当次选举的投票记录表中； （4）收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server； （5）线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数，设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1. 每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。
2、Zookeeper选主流程(fast paxos) fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.6-zk%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.6-zk%E5%90%8C%E6%AD%A5%E6%B5%81%E7%A8%8B/</guid>
      <description>题目：zookeeper同步流程 参考答案： 选完Leader以后，zk就进入状态同步过程。
 Leader等待Follower和Observer连接；
 Follower连接leader，将最大的zxid发送给leader；
 Leader根据follower的zxid确定同步点；
 完成同步后通知follower 已经成为uptodate状态；
 Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。
  数据同步的4种方式：
1、SNAP-全量同步 - 条件：peerLastZxid&amp;lt;minCommittedLog - 说明：证明二者数据差异太大，follower数据过于陈旧，leader发送快照SNAP指令给follower全量同步数据，即leader将所有数据全量同步到follower
2、DIFF-增量同步 - 条件：minCommittedLog&amp;lt;=peerLastZxid&amp;lt;=maxCommittedLog - 说明：证明二者数据差异不大，follower上有一些leader上已经提交的提议proposal未同步，此时需要增量提交这些提议即可
3、TRUNC-仅回滚同步 - 条件：peerLastZxid&amp;gt;maxCommittedLog - 说明：证明follower上有些提议proposal并未在leader上提交，follower需要回滚到zxid为maxCommittedLog对应的事务操作
4、TRUNC+DIFF-回滚+增量同步 - 条件：minCommittedLog&amp;lt;=peerLastZxid&amp;lt;=maxCommittedLog - 说明：leader a已经将事务truncA提交到本地事务日志中，但没有成功发起proposal协议进行投票就宕机了；然后集群中剔除原leader a重新选举出新leader b，又提交了若干新的提议proposal，然后原leader a重新服务又加入到集群中说明：此时a,b都有一些对方未提交的事务，若b是leader, a需要先回滚truncA然后增量同步新leader b上的数据。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.7-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5%E5%92%8C%E5%8D%8F%E8%B0%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.7-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E7%9F%A5%E5%92%8C%E5%8D%8F%E8%B0%83/</guid>
      <description>题目：分布式通知和协调 参考答案： 对于系统调度来说：操作人员发送通知实际是通过控制台改变某个节点的状态，然后zk将这些变化发送给注册了这个节点的watcher的所有客户端。
对于执行情况汇报：每个工作进程都在某个目录下创建一个临时节点。并携带工作的进度数据，这样汇总的进程可以监控目录子节点的变化获得工作进度的实时的全局情况。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.8-zk%E7%9A%84session%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/12.Zookeeper%E7%AF%87/12.2.8-zk%E7%9A%84session%E6%9C%BA%E5%88%B6/</guid>
      <description> 题目：zk的session机制 参考答案： zookeeper会为每个客户端分配一个session，类似于web服务器一样，用来标识客户端的身份。
session的作用：
 客户端标识 超时检查 请求的顺序执行 维护临时节点的生命周期 watcher通知  session的状态：
 CONNECTING CONNECTED RECONNECTING RECONNECTED CLOSED  session的属性：
 SessionID：会话ID，全局唯一 TimeOut：会话超时时间 TickTime：下次会话超时时间点 isClosing：会话是否已经被关闭  sessionID的构成：
 高8位代表创建Session时所在的zk节点的id 中间40位代表zk节点当前角色在创建的时候的时间戳 低16位是一个计数器，初始值为0  </description>
    </item>
    
    <item>
      <title></title>
      <link>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/21.%E9%9D%A2%E7%BB%8F/2020%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/%E9%9D%A2%E8%AF%95/21.%E9%9D%A2%E7%BB%8F/2020%E7%A7%8B%E6%8B%9B%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</guid>
      <description>@LiuYongQiang6
目标岗位 本硕均为机电专业相关，比赛和项目也是软硬件结合，个人软开背景中学已经学过pascal和数据结构与算法，大学本科除了C语言和微机原理基本没学过CS相关课程，研究生才把操作系统、组原以及计算机网络补上，顺便补了个c++,抽空玩linux，秋招前3个月开始刷题(牛客300,力扣350)。 第一目标岗位：嵌入式软件。 第二目标岗位：C++后台开发。 第三目标岗位：游戏相关岗位以及硬件。 投递公司：大疆深圳（嵌入式软件，offer），华为杭州（操作系统内核开发，offer,签约），小米武汉（物联网嵌入式软件，offer），远景智能（C++后台，offer），网易雷火游戏服务器提前批(笔试挂)，网易雷火游戏测试开发(offer)，中兴南京（软件开发，offer），网易互娱游戏策划（一面挂），腾讯（c++后台，笔试挂），oppo(c/c++软件开发，笔试通过拒绝面试)，小马智行/图森未来（简历石沉大海），株洲中车时代电气（大数据智能部门？,offer），。
前期准备 今年秋招前期体验十分艰难，十分庆幸当时没有轻信师兄做深度学习，学完吴恩达的机器学习课程及时刹车选择了做自己喜欢的嵌入式linux开发方向，顺便利用学习下来的东西一个人参加了下中兴算法大赛，摸了个名次，并且找了个学校附近的物联网公司做嵌入式linux的实习，下班复习基础与刷题：  1. 笔试刷题 ，非常重要，不然面试机会都没有，leetcode感觉是普通应用题，实际笔试可能是综合应用题，我采取的是专题速刷，半个月回顾一次；  2. 专业面试准备 ，重点复习数据结构、操作系统与计算机网络，我采取的方式先看别人的面经总结，并结合笔记，最后结合书籍构建系统，有时间可以看看源码，个人除了后台相关重点关注了嵌入式相关的总结以及linux源码分析，深入理解linux内核，linux驱动开发。  3. 综合面试准备，个人项目精炼，个人职责，亮点总结，个人项目介绍从结构、硬件、软件角度分析，完成的工作，可采用第一点、第二点等方法表示，个人项目逐点介绍采用为什么？怎么做？取得的效果？流程介绍，并准备一两个超级亮点和超级难点（你并未解决）。
面经 1.大疆：  一面，仔细询问笔试细节，并且挖深，被仔细询问了在笔试中用的bitmap算法，为何要用，有什么特点，怎么做的，然后抓住linux驱动开发项目追问细节，并引申，open/read/write等函数具体是怎么工作的，从用户态的系统调用闻到内核态的数据结构，基数树等，内存管理相关问到了linux系统中页缓存、缓存命中以及mmap相关的问题，比如两个大文件需要进行交互如何做，中断的上半部以及下半部等，为何要设置上半部和下半部，怎么做的，自旋锁和互斥锁的区别以及应用场景，如何实现一把自旋锁。  二面，基本就是问项目，RM比赛中学到了什么，比赛看了没有，觉得有什么问题，哪些可以改进，如果让你重新设计一个机器人，你希望设计出什么新功能可以在比赛中取到突出的效果。项目中涉及到硬件电路设计，被问到了信号链如何分析以及电源管理如何设计，开关电源与线性稳压器的对比，能接受提前实习么？  三面，应该是个pm,项目介绍，你觉得你做的最好的是哪块，最差的是哪块，个人优缺点，合作中出现问题应该怎么做，然后就是介绍公司业务和发展。 
2.华为：  一面，笔试回顾，个人情况特殊，笔试40分钟A了两个题便出去做oppo笔试，第三题没看，面试官看提交情况很好，只有3次提交，便放我一马，没问第三题，然后询问项目，细节记不大清，都是基本操作，最后做算法题，leetcode原题，打家劫舍，简单动态规划，分析一下算法复杂度。  二面，说一面面试官评价不错，直接跳过了项目介绍与询问，问中学时候参加信息学竞赛的经历以及中兴算法大赛，最后环节是算法题，消灭进程树，hash表加队列。  三面，项目介绍，什么是一份好的代码，了解操作系统么，做过哪些相关的工作，看过哪些相关的书籍。 
3.小米：  一面，询问项目细节，RTOS与linux的区别，如果让你写一个RTOS你应该写哪些功能，哪些是必须的，会用到哪些重要的数据结构，指针熟悉么，和C++中的引用的区别，什么时候用二级指针，C++中动态数组vector是怎么实现的，C语言中的设计模式了解么，最后做了一个简单的题，找出区间内乘积最大的两个素数。  二面，基本是项目，没啥印象了，然后问拿了哪些offer。 
4.远景：  一面，项目细节，三次握手以及四次挥手，超时重传算法，如何给一个超大文件进行排序，hash分桶；  二面，跟大疆三面差不多；  三面，跟hr聊天；  终面，会什么，能做什么，然后就是岗位介绍画饼。 
总结 时间过了太久，只有大疆印象深刻，其他基本忘得差不多，网易雷火游戏测试那部分虽然5面，刷人较多，但是看完牛客上的面经应该问题不大，唯一有点难度的是总监面时的算法题，当时做的一个dfs，比较复杂，分4种情况。中兴和中车感觉只要是个985应该问题不大，中兴一面讲了一下epoll的实现面试官眼睛都亮了，强行给我加上了南京的软件岗，中车同上，背景相关即可。
后台面试虽然准备了很多，但是由于基本找的都是C相关的底层岗位，基本没怎么问，redis和ngix基本没问，数据库相关的问题基本没碰到，可能第一目标岗位面试比较顺利便没怎么投C++后台相关的岗位开发，简历上基本没写C++后台相关的项目。 
以上，重点还是代码基础，也就是数据结构和算法，和项目结合的代码的逻辑实现，CS基础知识个人认为自己用的少的把面经看完即可，把自己做的项目细节融汇贯通，能抗住连环5问即可，答不上来避免强答，然后整理思路理清条理，平时多思考为什么怎么做有什么效果，然后干净一点吐词清晰即可，给自己一个好的面试体验以及给面试官一个好的面试体验，回答的时候尽量看着面试官（虽然有时候面试官在敲代码），最后，网易的小姐姐很漂亮。</description>
    </item>
    
    <item>
      <title>flutter NoMethodError - undefined method `size&#39; for nil:NilClass错误排查</title>
      <link>https://geek.zshipu.com/post/flutter/flutter-pod-nil-class/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/flutter/flutter-pod-nil-class/</guid>
      <description>错误描述: pod install时发生错误 ### Error ​``` NoMethodError - undefined method `size&#39; for nil:NilClass /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/macho_file.rb:455:in `populate_mach_header&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/macho_file.rb:233:in `populate_fields&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/macho_file.rb:55:in `initialize_from_bin&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/macho_file.rb:33:in `new_from_bin&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/fat_file.rb:365:in `block in populate_machos&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/fat_file.rb:364:in `each&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/fat_file.rb:364:in `populate_machos&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/fat_file.rb:156:in `populate_fields&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho/fat_file.rb:95:in `initialize&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho.rb:31:in `new&#39; /Library/Ruby/Gems/2.6.0/gems/ruby-macho-1.4.0/lib/macho.rb:31:in `open&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/xcode/linkage_analyzer.rb:16:in `dynamic_binary?&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/sandbox/file_accessor.rb:171:in `block in vendored_dynamic_frameworks&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/sandbox/file_accessor.rb:170:in `select&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/sandbox/file_accessor.rb:170:in `vendored_dynamic_frameworks&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/sandbox/file_accessor.rb:179:in `vendored_static_frameworks&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/sandbox/file_accessor.rb:292:in `vendored_static_artifacts&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:82:in `each&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:82:in `flat_map&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:82:in `block (2 levels) in verify_no_static_framework_transitive_dependencies&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:74:in `each_key&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:74:in `block in verify_no_static_framework_transitive_dependencies&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:73:in `each&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:73:in `verify_no_static_framework_transitive_dependencies&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer/xcode/target_validator.rb:38:in `validate!&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer.rb:595:in `validate_targets&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/installer.rb:162:in `install!&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/command/install.rb:52:in `run&#39; /Library/Ruby/Gems/2.6.0/gems/claide-1.0.3/lib/claide/command.rb:334:in `run&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/lib/cocoapods/command.rb:52:in `run&#39; /Library/Ruby/Gems/2.6.0/gems/cocoapods-1.10.0/bin/pod:55:in `&amp;lt;top (required)&amp;gt;&#39; /usr/local/bin/pod:23:in `load&#39; /usr/local/bin/pod:23:in `&amp;lt;main&amp;gt;&#39; ​``` ――― TEMPLATE END ―――――――――――――――――――――――</description>
    </item>
    
    <item>
      <title>如何使用 Python 基于 PyQt5 第三方库，进行实现 exe 桌面应用软件开发</title>
      <link>https://geek.zshipu.com/post/tlg/output/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Python-%E5%9F%BA%E4%BA%8E-PyQt5-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0-exe-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/post/tlg/output/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Python-%E5%9F%BA%E4%BA%8E-PyQt5-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0-exe-%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/</guid>
      <description>安装 PyQt5 第三方库开发环境 下面直接使用 pip 来安装 PyQt5，此处可能是 pip/pip3，或者两者皆可，后面不再重复 直接 pip 安装 PyQt5，当然也可以加镜像加快安装 pip install PyQt5 由于 Qt Designer 已经在 Python3.5 版本从 PyQt5 转移到了 tools，因此我们还需要安装 pyqt5-tools pip install pyqt5-tools 然后键盘按下 Win+S 呼出 Cornata 主面板（搜索框），输入 desi</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://geek.zshipu.com/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>https://geek.zshipu.com/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://geek.zshipu.com/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>